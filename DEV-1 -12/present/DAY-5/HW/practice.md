
# ПРАКТИКА

## Практика-15 Arrays

### 15.1

1. Создайте функцию add_book для добавления новой книги. 

Функция должна принимать два параметра — название книги и массив идентификаторов авторов —и возвращать идентификатор новой книги. 

Проверьте, что в приложении появилась возможность добавлять книги.

### 15.2*

1. Реализуйте функцию map, принимающую два параметра:массив вещественных чисел и название вспомогательной функции, принимающей один параметр вещественного типа. Функция возвращает массив, полученный из исходного применением вспомогательной функции к каждому элементу.

2. Реализуйте функцию reduce, принимающую два параметра:массив вещественных чисел и название вспомогательной функции, принимающей два параметра вещественного типа. Функция возвращает вещественное число, полученное последовательной сверткой массива слева направо.

3. Сделайте функции map и reduce полиморфными

```
1. Например:map(ARRAY[4.0,9.0],'sqrt') → ARRAY[2.0,3.0]

2. Например:reduce(ARRAY[1.0,3.0,2.0,0.5],'greatest') → 3.0

В этом случае значение вычисляется какgreatest( greatest( greatest(1.0,3.0), 2.0 ), 0.5 )

```

## Практика-16 Исключения

### 16.1

1. Если при добавлении новой книги указать одного и того же автора несколько раз, произойдет ошибка.

Измените функцию add_book: перехватите ошибку нарушения уникальности и вместо нее вызовите ошибкус понятным текстовым сообщением. 

Проверьте изменения в приложении.

### 16.2

1. Ряд языков имеет конструкцию try … catch … finally …,в которой try соответствует BEGIN, catch — EXCEPTION,а операторы из блока finally срабатывают всегда, независимо от того, возникло ли исключение и было ли оно обработано блоком catch. Предложите способ добиться подобного эффекта в PL/pgSQL.

2. Сравните стеки вызовов, получаемые конструкциями GET STACKED DIAGNOSTICS с элементом pg_exception_contextи GET [CURRENT] DIAGNOSTICS с элементом pg_context.

3. Напишите функцию getstack, возвращающую текущий стек вызовов в виде массива строк. Сама функция getstack не должна фигурировать в стеке


## Практика-17 Триггеры

### 17.1

1. Создайте триггер, обрабатывающий обновление поля onhand_qty представления catalog_v. Проверьте, что в «Каталоге» появилась возможность заказывать книги.

2. Обеспечьте выполнение требования согласованности: количество книг на складе не может быть отрицательным (нельзя купить книгу, которой нет в наличии). 

Внимательно проверьте правильность реализации, учитывая, что с приложением могут одновременно работать несколько пользователей



## Практика-18 Отладка

### 18.1

1. Измените функцию get_catalog так, чтобы динамически формируемый текст запроса записывался в журнал сообщений сервера.

 В приложении выполните несколько раз поиск, заполняя разные поля, и убедитесь, что команды SQL формируются правильно.


2. Включите трассировку команд SQL на уровне сервера. 

Поработайте в приложении и проверьте, какие команды попадают в журнал сообщений. Выключите трассировку.


## Практика-19 Разграничение доступа

### 19.1

1. Создайте две роли (пароль должен совпадать с именем):– employee — сотрудник магазина,– buyer — покупатель. 

Убедитесь, что созданные роли могут подключиться к БД.

2. Отзовите у роли public права выполнения всех функцийи подключения к БД.

3. Разграничьте доступ таким образом, чтобы:– сотрудник мог только заказывать книги, а также – добавлять авторов и книги,– покупатель мог только приобретать книги. 

Проверьте выполненные настройки в приложении.


## Практика-20 Разграничение доступа

### 20.1

1. Создайте резервную копию базы данных bookstoreв формате custom. 

«Случайно» удалите все записи из таблицы authorship. Проверьте, что приложение перестало отображать названия книг на вкладках «Магазин», «Книги», «Каталог». 

Используйте резервную копию для восстановления потерянных данных в таблице.

Проверьте, что нормальная работа книжного магазина восстановилась.