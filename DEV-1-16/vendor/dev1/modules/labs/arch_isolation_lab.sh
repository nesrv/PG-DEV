#!/bin/bash

. ../lib

init

psql_open A 2

start_here

###############################################################################
h '1. Фантомное чтение на уровне Read Committed'

s 1 "CREATE DATABASE $TOPIC_DB;"
s 1 "\c $TOPIC_DB"

c 'Пустая таблица:'

s 1 'CREATE TABLE t(id integer);'

c 'Во втором сеансе начнем транзакцию Read Committed и выполним запрос.'

s 2 "\c $TOPIC_DB"
s 2 "BEGIN;"
s 2 'SELECT * FROM t;'

c 'Вставим новую строку в таблицу (изменения фиксируются).'

s 1 "INSERT INTO t VALUES (1);"

s 2 'SELECT * FROM t;'

c 'Транзакция Read Committed видит добавленную строку.'
c 'Отличие от аномалии неповторяющегося чтения (при которой транзакция видит зафиксированные изменения в уже существовавших строках) состоит в том, что здесь видны строки, которых не было раньше.'

s 2 "COMMIT;"

###############################################################################
h '2. На какой момент времени видны данные?'

c 'Открываем транзакцию Repeatable Read:'

s 2 'BEGIN ISOLATION LEVEL REPEATABLE READ;'

c 'Добавляем строку в таблицу (изменения фиксируются):'

s 1 "INSERT INTO t VALUES (2);"

c 'Проверяем содержимое таблицы в открытой транзакции:'

s 2 'SELECT * FROM t;'

c 'Почему видны обе строки?. Дело в том, что транзакции Repeatable Read (и Serializable) видят данные на момент начала первой команды, а не на момент выполнения BEGIN.'
c 'Если сейчас добавить в таблицу еще строк, результат повторной выборки уже не изменится.'

s 1 "INSERT INTO t VALUES (3);"
s 2 'SELECT * FROM t;'

s 2 'COMMIT;'

###############################################################################
h '3. Транзакционность DDL'

c 'Откроем транзакцию и удалим таблицу t.'
s 1 'BEGIN;'
s 1 'DROP TABLE t;'
s 1 'SELECT * FROM t;'
c 'Таблица удалена.'

c 'Теперь откатим транзакцию:'
s 1 'ROLLBACK;'

s 1 'SELECT * FROM t;'
c 'Удаление отменено, таблица опять существует.'

stop_here
cleanup
