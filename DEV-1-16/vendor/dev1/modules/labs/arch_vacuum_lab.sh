#!/bin/bash

. ../lib

init

start_here ...

###############################################################################
h '1. Пакетное обновление'

s 1 "CREATE DATABASE $TOPIC_DB;"
s 1 "\c $TOPIC_DB"

c 'Создадим таблицу, сходную с той, что использовалась в демонстрации, и наполним ее данными:'

s 1 "CREATE TABLE t(
    id integer PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    n float,
    processed boolean DEFAULT false
);"
s 1 "INSERT INTO t(n) SELECT random() FROM generate_series(1,100_000);"

c 'Для упрощения задачи мы отказались от столбца с внешним хранением (TOAST), а дополнительный столбец processed пригодится нам для пакетного обновления.'

c 'Размер таблицы:'

s 1 "SELECT pg_size_pretty(pg_relation_size('t'));"

c 'Еще раз проверим показанное в демонстрации. Обновляем все строки:'

s 1 "UPDATE t SET n = n + 1;"

c 'Размер таблицы после обновления:'

s 1 "SELECT pg_size_pretty(pg_relation_size('t'));"

c 'Таблица увеличилась в два раза.'

c 'Теперь нам надо очистить таблицу, поэтому заодно засечем время выполнения команды TRUNCATE:'

s 1 '\timing on'
s 1 "TRUNCATE t;"
s 1 '\timing off'

c 'Заново вставляем те же строки:'

s 1 "INSERT INTO t(n) SELECT random() FROM generate_series(1,100_000);"
s 1 "SELECT pg_size_pretty(pg_relation_size('t'));"

c 'Для того чтобы контролировать обработанные строки, будем использовать столбец processed. Для удобства создадим функцию, выполняющую обновление пакета строк, причем размер пакета задается параметром:'

s 1 "CREATE FUNCTION do_update(batch_size integer) RETURNS void
LANGUAGE sql VOLATILE
BEGIN ATOMIC
    WITH batch AS (
        -- отбираем необработанные строки для пакета
        -- и блокируем их, пропуская уже заблокированные
        SELECT * FROM t
        WHERE NOT processed
        LIMIT batch_size
        FOR UPDATE SKIP LOCKED
    )
    UPDATE t
    SET n = n + 1,
        processed = true
    WHERE id IN (SELECT id FROM batch);
END;"

c 'Предложение FOR UPDATE SKIP LOCKED будет подробнее рассмотрено в теме «Блокировки». Такой способ даст необходимое количество необработанных строк (из числа имеющихся в таблице), причем выполнение не будет задержано другими обновлениями, которые могут выполняться в это же время. Удобно также, что этот способ не требует вычисления каких-либо диапазонов. Обновление просто надо продолжать до тех пор, пока в таблице не останется необработанных строк.'

c 'Поскольку выполнение команды VACUUM не допускается в блоке транзакции, воспользуется средствами bash, чтобы выполнить нужные команды:'

e "for i in {1..100}
do
  psql -d $TOPIC_DB -c 'SELECT do_update(1000);'
  psql -d $TOPIC_DB -c 'VACUUM;'
done >/dev/null
"

c 'Проверим, что все строки обработаны:'

s 1 "SELECT count(*) FROM t WHERE NOT processed;"

c 'Размер таблицы после пакетного обновления:'

s 1 "SELECT pg_size_pretty(pg_relation_size('t'));"

c 'Таблица увеличилась чуть больше, чем на 2%.'

###############################################################################
h '2. Удаление строк'

s 1 '\timing on'
s 1 "DELETE FROM t;"
s 1 '\timing off'

c 'Удаление всех строк командой DELETE выполняется значительно дольше, чем TRUNCATE. Кроме того, после DELETE в таблице остаются удаленные версии строк, которые должны быть очищены.'
c 'По принципу работы команда TRUNCATE напоминает VACUUM FULL: она заменяет файл данных новым (пустым) файлом, и для этого полностью блокирует работу с таблицей для других транзакций.'

###############################################################################

stop_here
cleanup
