#!/bin/bash

. ../lib

init
roll_to 20

# Этот скрипт сначала создает и наполняет базу данных bookstore
# перед тем, как демонстрировать приложение в начале темы.

###############################################################################
start_here 4
h 'Демонстрация приложения'

c 'В этой демонстрации мы показываем приложение «Книжный магазин» в том виде, в котором оно будет после завершения всех практических заданий. Приложение откроется в отдельной вкладке браузера виртуальной машины курса:'
open-file http://localhost

###############################################################################
P 12
h 'Схема данных приложения'

# Надо вернуться к результату практики этой темы, чтобы показать таблицы в первозданном виде.
roll_to 8

c 'Итак, схема данных приложения состоит из четырех таблиц:'

s 1 '\dt'

p

###############################################################################
h 'Книги'

s 1 '\d books'

c 'Здесь мы используем типы данных:'
ul 'integer — целое число;'
ul 'text — символьный, текстовая строка произвольной длины.'

c 'А также используем ограничение целостности:'
ul 'PRIMARY KEY — первичный ключ.'

p

c 'Конструкция GENERATED AS IDENTITY служит для автоматической генерации уникальных значений (в версиях до 10 для этого использовался псевдотип serial).'

c 'Строки столбцов, объявленных как GENERATED AS IDENTITY, получают значения из специальных объектов базы данных — последовательностей. Имя использованной последовательности можно узнать так:'

s 1 "SELECT pg_get_serial_sequence('books','book_id');"

c 'Последовательности можно при необходимости создавать вручную, а также обращаться к ним непосредственно:'

s 1 "SELECT nextval('books_book_id_seq');"

c 'Последовательность — самый эффективный способ генерации уникальных номеров. Но следует иметь в виду, что последовательность не гарантирует:'

ul "отсутствия пропусков в нумерации (так как изменение происходит не транзакционно);"
ul "монотонного возрастания номеров (если используется кеширование значений в сеансах)."

p

c 'Вот какие данные находятся в таблице книг:'

s 1 "SELECT * FROM books \gx"

c 'Обратите внимание, что названия могут быть длинными. Мы используем расширенный формат вывода psql, а появившийся в PostgreSQL 16 параметр xheader_width поможет обрезать строку заголовка "широкого" столбца:'

s 1 '\pset xheader_width 40'

c 'Сравните вывод:'

s 1 "SELECT * FROM books \gx"

p

###############################################################################
h 'Авторы'

s 1 '\d authors'

c 'Здесь дополнительно используется ограничение целостности:'
ul 'NOT NULL — обязательность, то есть недопустимость неопределенных значений.'

s 1 "SELECT * FROM authors;"

c 'Обратите внимание, что отчество может отсутствовать (или быть заданным пустой строкой).'

p

c 'Ограничение PRIMARY KEY в выводе команды \d упоминалось вместе со словами «индекс» и «btree».'

c 'Btree (B-дерево) — основной тип индекса, используемый в базах данных для ускорения поиска и для поддержки ограничений целостности (первичного ключа и уникальности).'

c 'Представим себе, что в магазине продаются книги миллиона авторов-однофамильцев:'

s 1 "BEGIN; -- начнем транзакцию, чтобы откатить потом изменения"
s 1 "INSERT INTO authors(first_name, last_name)
    SELECT 'Графоман', 'Графоманов' FROM generate_series(1, 1_000_000);"

c 'Сколько времени занимает поиск одного автора в такой таблице?'

# втихую отключаем параллельные планы, чтобы вывод был попроще
si 1 "SET max_parallel_workers_per_gather = 0;" >/dev/null

s 1 '\timing on'
s 1 "SELECT * FROM authors WHERE last_name = 'Пушкин';"
s 1 '\timing off'

c 'Если попросить оптимизатор показать план запроса, мы увидим в нем Seq Scan — последовательное сканирование всей таблицы в поисках нужного значения (Filter):'

s 1 "EXPLAIN (costs off)
SELECT * FROM authors WHERE last_name = 'Пушкин';"

c 'А если искать по полю, которое проиндексировано?'

s 1 '\timing on'
s 1 "SELECT * FROM authors WHERE author_id = 1;"
s 1 '\timing off'

c 'Время уменьшилось на несколько порядков.'

c 'А в плане запроса появился индекс:'

s 1 'EXPLAIN (costs off) 
SELECT * FROM authors WHERE author_id = 1;'

c 'Можно создать индекс и по фамилии (и проанализировать таблицу, чтобы собрать актуальную статистику):'

s 1 'ANALYZE authors;'
s 1 'CREATE INDEX ON authors(last_name);'
s 1 "EXPLAIN (costs off) 
SELECT * FROM authors WHERE last_name = 'Пушкин';"

c 'Однако индекс не является универсальным средством увеличения производительности. Обычно индекс очень полезен, если из таблицы требуется выбрать небольшую долю всех имеющихся строк. Если нужно прочитать много данных, индекс будет только мешать, и оптимизатор это понимает:'

s 1 "EXPLAIN (costs off) 
SELECT * FROM authors WHERE last_name = 'Графоманов';"

c 'Кроме того, надо учитывать накладные расходы на обновление индексов при изменении таблицы и занимаемое ими место на диске.'

c 'Отменим все наши изменения (включая создание индекса):'

s 1 "ROLLBACK;"
s 1 'ANALYZE authors;'

p

###############################################################################
h 'Авторства'

c 'С помощью этой таблицы реализуется связь «многие ко многим».'

s 1 '\d authorship'

c 'Здесь к уже использованным ограничениям добавляется ограничение ссылочной целостности:'
ul 'FOREIGN KEY — внешний ключ.'

c 'Фактически таблица содержит два внешних ключа: один ссылается на таблицу книг, другой — на таблицу авторов.'

c 'Столбец seq_num определяет последовательность, в которой должны перечисляться авторы одной книги, если их несколько.'

c 'Также обратите внимание на то, что первичный ключ — составной.'

s 1 "SELECT * FROM authorship;"

p

###############################################################################
h 'Операции'

s 1 '\d operations'

c 'В этой таблице используется еще один тип данных:'
ul 'date — дата (без указания времени).'

c 'Для столбца date_created указано значение по умолчанию (DEFAULT) — текущая дата.'

s 1 "SELECT * FROM operations;"

p

c 'Кроме тех типов данных, которые используются в таблицах приложения, мы постоянно будем встречаться с логическим типом (boolean). Например, такой тип имеют логические выражения в условии WHERE.'
c 'Важно помнить, что, в отличие от традиционных языков программирования, SQL использует трехзначную логику: кроме значений true и false, логическое значение может принимать неопределенное значение NULL (которое можно понимать как «значение неизвестно»).'
c 'В примерах встречаются и некоторые другие типы данных, информацию о работе с ними можно найти в материалах курса («Основные типы данных и функции», datatypes.pdf).'

c 'Кроме того, в курсе мы подробно рассмотрим более сложные типы:'
ul 'составной — записи, аналогичные строкам таблиц (в теме «SQL. Составные типы»);'
ul 'массивы (в теме «PL/pgSQL. Массивы»).'

P 16

###############################################################################
h 'Представления'

c 'Представление — запрос, у которого есть имя. Например, можно создать представление, которое показывает только авторов без отчества:'

s 1 "CREATE VIEW authors_no_middle_name AS
    SELECT author_id, first_name, last_name
    FROM authors
    WHERE nullif(middle_name,'') IS NULL;"

c 'Теперь имя представления можно использовать в запросах практически так же, как и таблицу:'

s 1 'SELECT * FROM authors_no_middle_name;'

c 'В простом случае с представлением будут работать и другие операции, например:'

s 1 'UPDATE authors_no_middle_name SET last_name = initcap(last_name);'

c 'С помощью триггеров можно сделать так, чтобы и в сложных случаях для представлений работали вставка, обновление и удаление строк. Мы рассмотрим это в теме «PL/pgSQL. Триггеры».'

c 'При планировании запроса представление «разворачивается» до базовых таблиц:'

s 1 'EXPLAIN (costs off) 
SELECT * FROM authors_no_middle_name;'

p

c 'Приложение использует три представления. Сначала они будут очень простыми, но в следующих темах мы перенесем в них часть логики приложения.'

c 'Представление для авторов — конкатенация фамилии, имени и отчества (если оно есть):'

s 1 "SELECT * FROM authors_v;"

c 'Представление для каталога книг — пока просто название книги:'

s_bare 1 '\pset xheader_width 70' > /dev/null

s 1 "SELECT * FROM catalog_v \gx"

c 'Представление для операций — дополнительно определяет тип операции (поступление или покупка):'

s 1 "SELECT * FROM operations_v;"

###############################################################################

stop_here
cleanup
demo_end
