#!/bin/bash

. ../lib

init

# При значении по умолчанию (5 минут) контрольная точка успевает прийти, пока рассказываешь
# (применится при перезагрузке; отменится как-нибудь при случае - безобидный параметр).
s 1 "ALTER SYSTEM SET checkpoint_timeout = '2h';"

psql_open A 2

start_here 5

###############################################################################
h 'Буферный кеш'

s 1 "CREATE DATABASE $TOPIC_DB;"
s 1 "\c $TOPIC_DB"

c 'Создадим таблицу.'

s 1 "CREATE TABLE t(
    id integer,
    s char(100) DEFAULT ''
) WITH (autovacuum_enabled = off);"
s 1 'INSERT INTO t(id) SELECT g.id FROM generate_series(1,1000) g(id);'

c 'В состав PostgreSQL входит расширение, которое позволяет посмотреть, что происходит в буферном кеше.'

s 1 'CREATE EXTENSION pg_buffercache;'

c 'Размер кеша определяется конфигурационным параметром:'

s 1 "SHOW shared_buffers;"

c 'Расширение показывает каждый буфер как отдельную строку одноименного представления:'

s 1 "SELECT count(*), pg_size_pretty(count(*) * 8192) FROM pg_buffercache;"

P 11

###############################################################################
h 'Использование буферного кеша'

c 'Перезапустим сервер, чтобы очистить буферный кеш.'

psql_close 1
pgctl_restart A
psql_open A 1 $TOPIC_DB

c 'С помощью расширения можно убедиться, что в кеше нет буферов, относящихся к нашей таблице:'

s 1 "SELECT isdirty, usagecount, count(*)
FROM pg_buffercache b
WHERE b.relfilenode = pg_relation_filenode('t'::regclass)
GROUP BY isdirty, usagecount;"

c 'Теперь выполним запрос, который прочитает все страницы таблицы. Команда EXPLAIN ANALYZE с параметром BUFFERS покажет, какое количество обращений к буферам потребовалось для выполнения.'

s 1 "EXPLAIN (analyze, buffers, costs off, timing off)
SELECT * FROM t;"

c 'В данном случае запрос прочитал 18 страниц, ни одной из которых не оказалось в кеше (read).'
c 'А почему эти страницы были изменены (dirtied)?'

p

c 'Как рассматривалось в теме «Многоверсионность», при первом чтении новых версий строк в заголовках этих версий проставляется статус транзакции (зафиксирована или оборвана). Это вызывает изменение страницы.'
c 'Что теперь мы обнаружим в кеше?'

s 1 "SELECT isdirty, usagecount, count(*)
FROM pg_buffercache b
WHERE b.relfilenode = pg_relation_filenode('t'::regclass)
GROUP BY isdirty, usagecount;"

c 'Как раз 18 буферов заполнены данными таблицы.'
c 'А как изменится выполнение того же самого запроса?'

s 1 "EXPLAIN (analyze, buffers, costs off, timing off)
SELECT * FROM t;"

c 'Теперь все данные были взяты из кеша (hit) и время выполнения запроса уменьшилось. Именно с наличием кеша и связан тот факт, что при повторном выполнении запросы обычно работают быстрее.'

P 16

###############################################################################
h 'Устройство журнала'

c 'Начнем транзакцию.'

s 1 "BEGIN;"

c 'Текущая позиция в журнале:'

s 1 "SELECT pg_current_wal_insert_lsn();"
export START_LSN=`sudo -i -u $OSUSER psql -A -t -X -d $TOPIC_DB -c "SELECT pg_current_wal_insert_lsn()"`

c 'LSN выводится как два 32-битных числа в шестнадцатеричной системе через косую черту.'

c 'Выполним какое-нибудь действие, например, изменим строку в таблице:'

s 1 "UPDATE t SET s = 'FOO' WHERE id = 1;"

c 'Изменится ли позиция в журнале?'

s 1 "SELECT pg_current_wal_insert_lsn();"

c 'Позиция увеличилась.'
c 'Завершим теперь транзакцию.'

s 1 "COMMIT;"

c 'Позиция в журнале снова изменилась:'

s 1 "SELECT pg_current_wal_insert_lsn();"
export END_LSN=`sudo -i -u $OSUSER psql -A -t -X -d $TOPIC_DB -c "SELECT pg_current_wal_insert_lsn()"`

c 'Размер журнальных записей (в байтах), соответствующих нашей транзакции, можно узнать простым вычитанием одной позиции из другой:'

s 1 "SELECT '$END_LSN'::pg_lsn - '$START_LSN'::pg_lsn;"

c 'Безусловно, в журнал попадает информация обо всех действиях во всем кластере, но в данном случае мы считаем, что в нашей системе больше ничего не происходит.'

P 19

###############################################################################
h 'Контрольная точка'

c 'Сейчас в буферном кеше находится несколько грязных буферов:'

s 1 "SELECT count(*)
FROM pg_buffercache b
WHERE isdirty;"

c 'Контрольная точка выполняется сервером периодически, но ее можно вызвать и вручную.'

s 1 "CHECKPOINT;"

c 'Поскольку по умолчанию буферный кеш имеет небольшой размер, контрольная точка выполняется очень быстро. Но в реальных системах, использующих большой буферный кеш, это может занимать существенное время.'
c 'Сколько грязных буферов останется в буферном кеше?'

s 1 "SELECT count(*)
FROM pg_buffercache b
WHERE isdirty;"

c 'Ни одного. Хотя, если бы в нашей системе была какая-то активность, грязные буферы — появившиеся уже после начала контрольной точки — могли бы остаться.'

###############################################################################

stop_here
cleanup
demo_end
