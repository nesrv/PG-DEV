#!/bin/bash

. ../lib

init

s 1 "CREATE DATABASE $TOPIC_DB;"
s 1 "\c $TOPIC_DB"

start_here 6

###############################################################################
h 'Установка и управление'

c 'В виртуальной машине курса установка выполнена из пакета. Каталог установки PostgreSQL:'
e "ls -l $BINLIB_A"

c 'Владелец ПО сервера — пользователь root.'

p

c "Кластер баз данных автоматически инициализируется при установке из пакета и находится в каталоге $PGDATA_A." 
c 'В последующих темах мы будем ссылаться на этот каталог как PGDATA, по имени переменной ОС, которую можно установить для использования в некоторых утилитах сервера.'

c 'Владельцем каталога является пользователь postgres. Вот содержимое каталога:'
e "sudo ls -l $PGDATA_A"

p

c 'При установке из пакета в настройки запуска ОС добавляется автоматический запуск PostgreSQL. Поэтому после загрузки операционной системы отдельно стартовать PostgreSQL не нужно.'

c 'Можно явным образом управлять сервером с помощью следующих команд, которые выдаются от имени привилегированного пользователя ОС через sudo:'

c 'Остановить сервер:'
e_fake_p "sudo pg_ctlcluster $VERSION_A $CLUSTER_A stop"

c 'Запустить сервер:'
e_fake_p "sudo pg_ctlcluster $VERSION_A $CLUSTER_A start"

c 'Перезапустить:'
e_fake_p "sudo pg_ctlcluster $VERSION_A $CLUSTER_A restart"

c 'Обновить конфигурацию:'
e_fake_p "sudo pg_ctlcluster $VERSION_A $CLUSTER_A reload"

c 'Получить информацию о сервере:'
e "sudo pg_ctlcluster $VERSION_A $CLUSTER_A status"

c 'Список установленных экземпляров (можно без sudo):'
e "pg_lsclusters"

P 8

###############################################################################
h 'Журнал сообщений сервера'

c 'Журнал сообщений сервера находится здесь:'

e "ls -l $LOG_A"

c 'Заглянем в конец журнала:'

e "tail -n 10 $LOG_A"

P 10

###############################################################################
h 'Параметры конфигурации'

c 'Основной файл конфигурации postgresql.conf расположен в этом каталоге:'
e "ls -l $CONF_A"

c 'Здесь же находятся и другие конфигурационные файлы.'

c 'Проверим значение параметра work_mem:'
s 1 'SHOW work_mem;'

c 'Параметр work_mem задает объем памяти, который будет использоваться для внутренних операций сортировки и размещения хеш-таблиц, прежде чем будут задействованы временные файлы на диске.'
c '4MB — это значение по умолчанию и оно слишком мало. Допустим, мы хотим увеличить его до 16MB для всего экземпляра. Для этого есть различные пути.'

c 'Во-первых, можно внести изменение в postgresql.conf, раскомментировав и изменив строку, где определяется параметр:'

e "grep '#work_mem' $CONF_A/postgresql.conf" conf

c "Во-вторых, можно поместить определение параметра в файл с суффиксом .conf в каталоге $CONF_A/conf.d или в пользовательский файл конфигурации, местоположение которого следует задать в директиве include основного конфигурационного файла postgresql.conf."

c 'В-третьих, можно изменить значение параметра с помощью команды SQL — что мы и сделаем:'

s 1 "ALTER SYSTEM SET work_mem TO '16MB';"

c 'Такое изменение попадает не в postgresql.conf, а в файл postgresql.auto.conf, который находится в каталоге PGDATA:'

e "sudo cat $PGDATA_A/postgresql.auto.conf" conf

c 'Чтобы изменение вступило в силу, нужно перечитать конфигурационные файлы. Для этого можно воспользоваться pg_ctlcluster, либо использовать функцию SQL:'

s 1 "SELECT pg_reload_conf();"

c 'Убедимся, что новое значение параметра применилось. Кроме команды SHOW, можно сделать это таким образом:'

s 1 "SELECT current_setting('work_mem');"

c 'Чтобы восстановить значение параметра по умолчанию, достаточно вместо SET использовать команду RESET (и, конечно, перечитать конфигурационные файлы):'

s 1 "ALTER SYSTEM RESET work_mem;"
s 1 "SELECT pg_reload_conf();"

p

c 'Большинству параметров можно установить новое значение для текущего сеанса прямо во время его выполнения. Например, если мы собираемся выполнить запрос, сортирующий большой объем данных, то для сеанса можно увеличить значение work_mem:'

s 1 "SET work_mem = '64MB';"

c 'Новое значение действует только в текущем сеансе или даже в текущей транзакции (при указании SET LOCAL).'

p

c 'Еще один способ проверить текущее значение — выполнить запрос к представлению:'

s 1 "SELECT name, setting, unit FROM pg_settings WHERE name = 'work_mem';"

c 'Можно увидеть значение параметра и с помощью команды \dconfig:'

s 1 '\dconfig work_mem'

P 12

###############################################################################
h 'Подключение'

c 'При запуске psql нужно указать параметры подключения. К обязательным параметрам относятся:'

ul 'имя базы данных, по умолчанию совпадает с именем пользователя;'
ul 'имя пользователя (роль), по умолчанию совпадает с именем пользователя ОС;'
ul 'узел (host), по умолчанию — локальное соединение;'
ul 'порт, по умолчанию — обычно 5432.'

c 'Параметры указываются так:'

e_fake 'psql -d база -U роль -h узел -p порт'

c 'Настройки, сделанные в виртуальной машине курса, позволяют подключаться к PostgreSQL без указания параметров:'

psql_open A 1 

c 'Проверим текущее подключение:'
s 1 '\conninfo'

c 'Команда \connect выполняет новое подключение, не покидая psql. Ее можно сократить до \c. Мы будем указывать необязательную часть имени команды в квадратных скобках: \c[onnect].'

p

###############################################################################
h 'Справочная информация'

c 'Справку по psql можно получить не только в документации, но и прямо в системе. Команда'

e_fake 'psql --help'

c 'выдает справку по запуску. А если PostgreSQL устанавливался с документацией, то справочное руководство можно получить командой'

e_fake 'man psql'

p

c 'Утилита psql умеет выполнять команды SQL и свои собственные команды, которые начинаются с обратной косой черты, как \conninfo. Команды psql всегда однострочные — в отличие от команд SQL.'
c 'Внутри psql есть возможность получить список и краткое описание его собственных команд:'
ul '\? выдает список команд psql,'
ul '\h[elp] выдает список команд SQL, которые поддерживает сервер, а также синтаксис конкретной команды SQL.'

p

###############################################################################
h 'Форматирование вывода'

c 'Клиент psql умеет выводить результаты запросов в разных форматах:'
ul 'формат с выравниванием значений;'
ul 'формат без выравнивания;'
ul 'расширенный формат.'

c 'Формат с выравниванием используется по умолчанию:'

s 1 'SELECT name, setting, unit FROM pg_settings LIMIT 7;'

c 'Ширина столбцов выровнена по значениям. Также выводится строка заголовков и итоговая строка.'

c 'Команды psql для переключения режима выравнивания:'
ul '\a — переключатель режима: с выравниванием/без выравнивания.'
ul '\t — переключатель отображения строки заголовка и итоговой строки.'

c 'Отключим выравнивание, заголовок и итоговую строку:'
s 1 '\a \t'
s 1 'SELECT name, setting, unit FROM pg_settings LIMIT 7;'
s 1 '\a \t'

c 'Такой формат неудобен для просмотра, но может оказаться полезным для автоматической обработки результатов.'

p

c 'Расширенный формат удобен, когда нужно вывести много столбцов для одной или нескольких записей. Для этого вместо точки с запятой указываем в конце команды \gx:'

s 1 "SELECT name, setting, unit, category, context, vartype,
    min_val, max_val, boot_val, reset_val
    FROM pg_settings
    WHERE name = 'work_mem' \gx"

c 'Если расширенный формат нужен не для одной команды, а постоянно, можно включить его переключателем \x. Все возможности форматирования результатов запросов доступны через команду \pset.'

p

###############################################################################
h 'Взаимодействие с ОС и выполнение скриптов'

c 'Из psql можно выполнять команды shell:'

s 1 '\! pwd'

c 'С помощью запроса SQL можно сформировать несколько других запросов SQL и записать их в файл, используя команду \o[ut]:'

s 1 "\a \t \pset fieldsep ''"
s 1 "\o dev1_tools.sql"
s 1 "SELECT format('SELECT %L AS tbl, count(*) FROM %I;', tablename, tablename)
FROM pg_tables LIMIT 3;"

c 'На экран (в стандартный вывод) ничего не попало. Посмотрим в файле:'

s 1 '\! cat dev1_tools.sql' pgsql

c 'Вернем вывод на экран и восстановим форматирование по умолчанию.'
s 1 '\o \t \a'

c 'Выполним теперь эти команды из файла с помощью \i[nclude]:'

s 1 '\i dev1_tools.sql'

c 'Есть и другие способы выполнить команды, в том числе из файлов. После выполнения команд сеанс psql будет завершен:'
ul "psql < имя_файла"
ul "psql -f имя_файла"
ul "psql -c 'команда' (работает только для одной команды)"

p

###############################################################################
h 'Переменные psql'

c 'По аналогии с shell, psql имеет собственные переменные.'
c 'Установим переменную:'

s 1 '\set TEST Hi!'

c 'Чтобы подставить значение переменной, надо предварить ее имя двоеточием:'

s 1 '\echo :TEST'

c 'Значение переменной можно сбросить:'

s 1 '\unset TEST'
s 1 '\echo :TEST'

c 'Переменные можно использовать, например, для хранения текста часто используемых запросов. Вот запрос на получение списка пяти самых больших по размеру таблиц:'

s 1 "\set top5 'SELECT tablename, pg_total_relation_size(schemaname||''.''||tablename) AS bytes FROM pg_tables ORDER BY bytes DESC LIMIT 5;'"

c 'Для выполнения запроса достаточно набрать:'

s 1 ":top5"

c 'Присвоение значения переменной top5 удобно записать в стартовый файл .psqlrc в домашнем каталоге пользователя. Команды из .psqlrc будут автоматически выполняться каждый раз при старте psql.'

p

c 'Без параметров \set выдает значения всех переменных, включая встроенные. Справку по встроенным переменным можно получить так:'

s_fake 1 '\? variables'

c 'Выйти из psql можно с помощью команд \q[uit], quit, exit или нажав Ctrl+D:'

psql_close 1

###############################################################################

stop_here
cleanup
demo_end
