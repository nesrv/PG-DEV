#!/bin/bash

. ../lib
init

start_here 12

###############################################################################
h 'pg_variables'

c 'Установим расширение в базе данных:'

s 1 "CREATE DATABASE $TOPIC_DB;"
s 1 "\c $TOPIC_DB"

s 1 "CREATE EXTENSION pg_variables;"

c 'Расширение оперирует термином «пакет», под которым понимается пространство имен переменных. Команды ниже автоматически создадут пакет vars, поместят в него две переменные скалярного типа и зададут им значения.'

c 'Первая переменная нетранзакционная (по умолчанию):'
s 1 "SELECT pgv_set('vars', 'int_n', 10);"

c 'Вторая — транзакционная (последний параметр is_transactional в вызове функции):'
s 1 "SELECT pgv_set('vars', 'int_t', 20, true);"

c 'С помощью функций можно прочитать значения переменных и получить дополнительную информацию о них:'

s 1 "SELECT pgv_get('vars', 'int_n', NULL::int), pgv_get('vars', 'int_t', NULL::int);"
s 1 "SELECT * FROM pgv_list() ORDER BY package, name;"

c 'Вторая переменная будет корректно работать и с точками сохранения:'

s 1 'BEGIN;'
s 1 'SAVEPOINT sp;'
s 1 "SELECT pgv_set('vars', 'int_n', 111), pgv_set('vars', 'int_t', 222, true);"
s 1 'ROLLBACK TO sp;'

c 'Фиксируем транзакцию и читаем значения переменных:'
s 1 'COMMIT;'
s 1 "SELECT pgv_get('vars', 'int_n', NULL::int), pgv_get('vars', 'int_t', NULL::int);"

c 'Обратите внимание, что необходимо указывать флаг is_transactional при каждом изменении значения транзакционной переменной. В противном случае произойдёт ошибка:'
s 1 "SELECT pgv_set('vars', 'int_t', 333);"

p

c 'Рассмотрим также пример с использованием переменных-записей.'

c 'Запрос ниже вставляет в коллекцию tbl_1 пакета tbls несколько записей. Если пакет или коллекция не существуют (как в нашем случае), они будут созданы автоматически:'

s 1 "SELECT pgv_insert('tbls', 'tbl_1', tbl) FROM
   (SELECT gs, 'Line_' || gs FROM generate_series(1, 4) AS gs) AS tbl;"

c 'Первый столбец каждой записи — первичный ключ. В случае, если при вставке обнаружится запись с таким же ключом, будет выдана ошибка:'
s 1 "SELECT pgv_insert('tbls', 'tbl_1', (2, 'Another 2nd line'));"

c 'Мы можем изменять или удалять записи, обращаясь к ним по значению ключа:'

s 1 "SELECT pgv_update('tbls', 'tbl_1', (2, '2nd line again'));"
s 1 "SELECT pgv_delete('tbls', 'tbl_1', 3);"
s 1 "SELECT pgv_delete('tbls', 'tbl_1', 5);  -- записи с таким ключом нет, результат будет false"

c 'Что получилось в результате? Прочитаем все данные из коллекции:'
s 1 "SELECT pgv_select('tbls', 'tbl_1');"

c 'По записям переменных-коллекций удобно передвигаться с помощью итераторов pgv_first, pgv_last, pgv_next, pgv_prior. Эти функции возвращают соответствующие значения ключей. Для pgv_first и pgv_last последний параметр необходим для определения типа возвращаемого значения:'

s 1 "SELECT pgv_first('tbls', 'tbl_1', NULL::int);"
s 1 "SELECT pgv_next('tbls', 'tbl_1', 2);"

c 'Количество элементов в коллекции вернет функция pgv_count:'

s 1 "SELECT pgv_count('tbls', 'tbl_1');"

c 'Данные в коллекциях хранятся в порядке возрастания. Для ключей типа text требуется правило сортировки для определения порядка элементов. Если при вставке первого элемента правило сортировки не указано, используется правило сортировки по умолчанию.'

c 'Получить список созданных пакетов и объем памяти, используемый переменными можно так:'
s 1 'SELECT * FROM pgv_stats();'

p

c 'Удалить переменную и весь пакет целиком можно при помощи функции pgv_remove:'
s 1 "SELECT pgv_remove('vars', 'int_n');  -- удаляем переменную"
s 1 "SELECT pgv_exists('vars', 'int_n');  -- проверка существования переменной: ее уже нет"

s 1 "SELECT pgv_remove('vars');  -- удаляем весь пакет"
s 1 "SELECT pgv_exists('tbls');  -- этот пакет пока не удален"

c 'Функция pgv_free удаляет все пакеты и переменные:'
s 1 'SELECT pgv_free();'

c 'Если вызовы функций pgv_free или pgv_remove откатываются, то затрагиваемые транзакционные переменные восстанавливаются, а нетранзакционные удаляются необратимо.'

P 14

##############################################################################
h 'in_memory'

c 'Для работы расширения необходимо загрузить библиотеку и перезапустить СУБД:'
s 1 "ALTER SYSTEM SET shared_preload_libraries = 'in_memory';"

pgctl_restart A
psql_open A 1

c "Теперь установим расширение в базу $TOPIC_DB:"

s 1 "\c $TOPIC_DB"
s 1 "CREATE EXTENSION in_memory;"

c 'Доступ к оперативным таблицам организуется с помощью обертки сторонних данных, для этого создан сервер внешних данных in_memory:'

s 1 '\des'

c 'Далее нам следует создать внешнюю таблицу на этом сервере — это и будет наша оперативная таблица:'

s 1 "CREATE FOREIGN TABLE optable (id int NOT NULL, note text) SERVER in_memory;"

c 'По умолчанию в таблице будет создан уникальный индекс B-tree по первому столбцу, с сортировкой по возрастанию. При необходимости можно воспользоваться указанием INDICES в предложении OPTIONS, чтобы определить другую структуру индекса, например так:'

s 1 "CREATE FOREIGN TABLE optable_bis (id int, note text NOT NULL) SERVER in_memory
   OPTIONS (INDICES 'UNIQUE (note)');"

c 'Все столбцы, используемые в индексе B-tree, должны иметь тип, для которого имеется класс операторов B-tree по умолчанию.'

s 1 '\det+'

c 'Оперативная таблица создана и теперь с ней можно выполнять все основные операции DML. Внесем в таблицу данные и прочитаем несколько строк:'

s 1 "INSERT INTO optable (SELECT gs, 'Line_' || gs FROM generate_series(1, 100) AS gs);"
s 1 "SELECT * FROM optable LIMIT 3;"

c 'Статистику по страницам оперативных таблиц можно получить так:'

s 1 'SELECT * FROM in_memory_page_stats();'

c 'Функция возвращает количество всех использованных и свободных страниц, а также общее число страниц, выделенных для оперативных таблиц. При удалении строк из оперативных таблиц с помощью DELETE страницы данных не освобождаются. Чтобы их освободить, можно выполнить опустошение (TRUNCATE) или удаление таблицы:'

s 1 'DELETE FROM optable;'

s 1 'SELECT * FROM in_memory_page_stats();'

s 1 'TRUNCATE optable;'

s 1 'SELECT * FROM in_memory_page_stats();'

s 1 'DROP FOREIGN TABLE optable;'

s 1 'SELECT * FROM in_memory_page_stats();'

########################################################################

stop_here
cleanup
demo_end
