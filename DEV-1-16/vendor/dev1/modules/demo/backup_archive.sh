#!/bin/bash

. ../lib
init

start_here 5
###############################################################################
h 'Настройка непрерывной архивации'

c "Архив будем хранить в каталоге $H/archive. Он должен быть доступен пользователю-владельцу PostgreSQL."
eu student "sudo -u postgres mkdir $H/archive"
c 'В реальной практике архив может размещаться на отдельном сервере или дисковой системе с доступом по сети.'

c 'Включим режим архивирования и установим команду копирования заполненных сегментов журнала.'
s 1 '\c - postgres'
s 1 'ALTER SYSTEM SET archive_mode = on;'

c 'В archive_command можно указать произвольную команду (например, cp), лишь бы она завершалась со статусом 0 только в случае успеха. Можно организовать сжатие архивируемых сегментов WAL:'
s 1 "ALTER SYSTEM SET archive_command = '[ -f $H/archive/%f.gz ] || gzip < %p > $H/archive/%f.gz';"
c 'В этой команде сначала проверяется командой test (она же квадратная скобка), существует ли файл в архиве. Если нет - помещаем сжатый gzip файл в архив.'

c 'В идеале команда архивирования должна выполнять sync, чтобы файл гарантированно попал в энергонезависимую память. Иначе при сбое он может пропасть из архива, а сервер может успеть стереть его из каталога pg_wal.'

c 'В общем случае удобно поместить всю необходимую логику архивирования в отдельный скрипт и вызывать его:'
s 1 "-- SET archive_command = 'archive.sh \"%f\" \"%p\"';"

p

c 'Изменение archive_mode требует рестарта сервера.'
pgctl_restart A

c 'Проверим работу архивации. Создадим базу и таблицу.'
psql_open A 1
s 1 "CREATE DATABASE $TOPIC_DB;"
s 1 "\c $TOPIC_DB"
s 1 'CREATE TABLE t(s text);'
s 1 "INSERT INTO t VALUES ('Строка №1');"

c 'Вот какой сегмент WAL используется сейчас:'
s 1 'SELECT pg_walfile_name(pg_current_wal_lsn());'
c 'Обратите внимание: первые восемь цифр в имени файла — номер текущей линии времени.'

c 'Чтобы заполнить файл, пришлось бы выполнить большое количество операций. В тестовых целях проще принудительно переключить сегмент:'
e "psql -U postgres -c 'SELECT pg_switch_wal()'"
s 1 "INSERT INTO t VALUES ('И еще одна строка');"

c 'Сегмент сменился:'
s 1 'SELECT pg_walfile_name(pg_current_wal_lsn());'

c 'А предыдущий должен был попасть в архив. Проверим:'
e "sudo ls -lh $H/archive"

c 'Текущий статус архивации показывает представление pg_stat_archiver:'
s 1 "SELECT * FROM pg_stat_archiver \gx"
c 'Таким образом, файловая архивация настроена и работает.'

P 7

###############################################################################
h 'Потоковый архив'

c 'Чтобы настроить пополнение архива по протоколу потоковой репликации, остановим сначала файловую архивацию.'
s 1 '\c - postgres'
s 1 'ALTER SYSTEM RESET archive_mode;'
s 1 'ALTER SYSTEM RESET archive_command;'
pgctl_restart A

c 'Текущее состояние архива.'
e "sudo ls -lh $H/archive"

c 'Сначала попросим утилиту pg_receivewal создать слот, чтобы гарантировать получение всех записей журнала.'
eu postgres "pg_receivewal --create-slot --slot=archive"

c 'Затем запустим ее фоном в режиме архивации. Увидев, что в архиве уже есть файлы, утилита запросит у сервера следующий сегмент, чтобы в архиве не было пропусков.'
eu_runbg postgres "pg_receivewal -D $H/archive --slot=archive --compress=gzip"

c 'Добавим в таблицу много строк и удалим их.'
psql_open A 1 -d $TOPIC_DB
s 1 "INSERT INTO t SELECT 'И снова здравствуйте.' FROM generate_series(1,200000);"
s 1 "DELETE FROM t WHERE s = 'И снова здравствуйте.';"
s 1 "VACUUM t;"

c 'В архиве появились новые файлы.'
e "sudo ls -lh $H/archive"

c 'Последний файл, скорее всего, имеет суффикс .partial — в него идет запись.'
c 'Теперь мы настроили потоковую архивацию.'

P 9

###############################################################################
h 'Базовая резервная копия'

c 'Поскольку архив пополняется автоматически, попросим pg_basebackup не добавлять файлы журнала к резервной копии:'
e "pg_basebackup --wal-method=none -D /home/student/tmp/backup"

c 'В каталоге pg_wal резервной копии сегментов WAL нет:'
e "ls -l /home/student/tmp/backup/pg_wal/"

c 'Зато в архиве прибавилось файлов:'
e "sudo ls -lh $H/archive"

c 'Заглянем в сгенерированный файл метки:'
e "cat /home/student/tmp/backup/backup_label"

c 'Главная информация в этом файле — номер линии времени (строка START TIMELINE) и указание начальной точки для восстановления (START WAL LOCATION). Теоретически восстановление можно начать и с более ранней (но не более поздней) позиции, но это потребует больше времени.'

P 14

###############################################################################
h 'Восстановление из базовой резервной копии'

c 'Зададим настройки восстановления на сервере beta (до версии 12 их нужно помещать в отдельный файл recovery.conf). В простейшем случае достаточно указать команду восстановления, которая будет копировать указанный сегмент WAL обратно из архива по указанному пути:'

e "echo \"restore_command = 'zcat $H/archive/%f.gz > %p'\" >> /home/student/tmp/backup/postgresql.auto.conf"

c 'Если не указана целевая точка восстановления (один из параметров recovery_target*), то к базовой резервной копии будут применены записи WAL из всех файлов в архиве.'

p

c 'Наличие файла recovery.signal — указание серверу при старте войти в режим управляемого восстановления:'
e "touch /home/student/tmp/backup/recovery.signal"

c 'Выкладываем резервную копию в каталог данных сервера beta и запускаем его.'

pgctl_status B
e "sudo rm -rf $PGDATA_B"
e "sudo mv /home/student/tmp/backup $PGDATA_B"
e "sudo chown -R postgres:postgres $PGDATA_B"
pgctl_start B

c 'После успешного восстановления файл recovery.signal удаляется, а файл метки переименовывается в backup_label.old:'
e "sudo ls -l $PGDATA_B | egrep 'recovery|backup_label'"

c 'Проверим, что восстановлено в таблице:'
psql_open B 2 -p 5433 -d $TOPIC_DB
s 2 "SELECT * FROM t;"

P 16

###############################################################################
h 'Линии времени'

c 'Что стало с линией времени после восстановления?'
s 2 'SELECT pg_walfile_name(pg_current_wal_lsn());'

c 'Номер увеличился на единицу.'
c 'В каталоге pg_wal появился файл истории, соответствующий этой ветви:'
export TIMELINE=`psql -A -t -X -p 5433 -c "SELECT left(pg_walfile_name(pg_current_wal_lsn()),8)"`
eu postgres "ls -l $PGDATA_B/pg_wal/$TIMELINE.history"

c 'В нем есть информация о «точках ветвления», через которые мы пришли в данную линию времени:'
e "sudo cat $PGDATA_B/pg_wal/$TIMELINE.history"

c 'Эти файлы PostgreSQL использует, когда мы указываем линию времени в параметре recovery_target_timeline. Поэтому файлы истории подлежат архивации вместе с сегментами WAL, и удалять из архива их не надо.'

P 18

###############################################################################
h 'Очистка архива'

c 'Сейчас архив первого сервера содержит ненужные файлы, они попали туда до формирования базовой копии:'
e "sudo ls -lh $H/archive"

c 'Утилите pg_archivecleanup нужно передать путь к архиву и имя последнего сохраняемого сегмента WAL (его можно найти в файле backup_label).'
e "sudo head -n 1 $PGDATA_B/backup_label.old"

# pg_archivecleanup'у вместо номера сегмента можно дать имя файла *.backup,
# такие файлы появляются в pg_wal при каждом формировании базовой копии.
# Эти файлы попадают в файловый архив, но не попадают в потоковый,
# поэтому приходится извлекать номер сегмента из первой строки backup_label.
e "sudo pg_archivecleanup -x.gz $H/archive $(sudo head -n 1 $PGDATA_B/backup_label.old | egrep -o '[[:xdigit:]]{24}')"

c 'Посмотрим, какие файлы остались в архиве:'
e "sudo ls -lh $H/archive"

c 'Архив очищен.'

c 'Чтобы архив очищался по окончании восстановления, можно задать параметр'
s 1 "-- SET recovery_end_command = 'pg_archivecleanup $H/archive %r'"

###############################################################################
stop_here
cleanup
demo_end
