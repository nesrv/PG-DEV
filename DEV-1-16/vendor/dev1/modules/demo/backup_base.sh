#!/bin/bash


. ../lib
init

start_here 5
###############################################################################
h 'Холодная файловая копия'

c 'Файлы остановленного кластера можно скопировать и запустить с ними второй сервер. При этом не важно, был ли сервер остановлен корректно.'

c 'Создадим базу данных и таблицу.'

pgctl_start A
psql_open A 1

s 1 "CREATE DATABASE $TOPIC_DB;"
s 1 "\c $TOPIC_DB"
s 1 'CREATE TABLE t(s text);'
s 1 "INSERT INTO t VALUES ('Строка вставлена на α...');"

c 'Аварийно останавливаем сервер и копируем файлы на сервер beta:'

kill_postgres A

pgctl_status B
e "sudo rm -rf $PGDATA_B"
e "sudo cp -a $PGDATA_A $PGDATA_B"

c 'Beta восстанавливает согласованность и запускается:'

pgctl_start B

e "sudo tail -n 5 $LOG_B"

psql_open B 2 -p 5433 -d $TOPIC_DB
s 2 "SELECT * FROM t;"

P 13
###############################################################################
h 'Базовая резервная копия'

c 'Теперь мы хотим сделать базовую копию работающего сервера альфа и восстановить ее на бете.'

pgctl_start A

psql_open A 1 -U postgres

c 'Значения параметров по умолчанию позволяют сразу использовать протокол репликации:'
s 1 "\dconfig (wal_level|max_wal_senders|max_replication_slots)"

c 'Разрешение на локальное подключение по протоколу репликации в pg_hba.conf уже имеется:'
s 1 "SELECT type, database, user_name, address, auth_method
FROM pg_hba_file_rules() WHERE 'replication' = ANY(database);"

c "Чтобы утилита pg_basebackup могла подключиться к серверу под ролью $OSUSER, эта роль должна иметь атрибут REPLICATION:"
s 1 "\du $OSUSER"

p

c 'Единственный обязательный ключ -D (--pgdata) утилиты pg_basebackup указывает целевой каталог для записи копии. Каталог создается автоматически, но если он уже существует, он должен быть пуст.'
c 'Остановим сервер бета и удалим каталог данных этого сервера.'
pgctl_stop B
e "sudo rm -rf $PGDATA_B"

p

c 'Задача скопировать данные с альфы на бету, выполнив сжатие на стороне источника (то есть, альфы). Для этого не подходит потоковый метод передачи WAL по отдельному соединению, использующийся по умолчанию. Можно использовать метод --wal-method=fetch (-Xf). Однако, в этом случае сегменты WAL будут сохраняться на сервере-источнике и передаваться на целевой лишь в конце копирования. Поэтому следует задать достаточное значение параметра wal_keep_size (в мегабайтах).'
s 1 'ALTER SYSTEM SET wal_keep_size = 32;'
s 1 'SELECT pg_reload_conf();'

c 'Выполним копирование.'
eu student "sudo -u postgres pg_basebackup -D $PGDATA_B -Xf -Z server-gzip -c fast"

c 'Использованные здесь параметры командной строки:'
ul '-D - целевой каталог для копирования (--pgdata);'
ul '-Xf - метод передачи WAL в копию (--wal-method=fetch);'
ul '-Z server-gzip - сжатие методом gzip на стороне сервера-источника, данные передаются в сжатом виде;'
ul '-c fast выполнить быструю контрольную точку.'

c "По умолчанию на восстановленный каталог данных устанавливаются права только для владельца."
eu student "sudo -u postgres ls -ld $PGDATA_B" 

c "Все необходимые файлы журнала находятся в каталоге pg_wal:"
eu student "sudo -u postgres ls -l $PGDATA_B/pg_wal"

p

###############################################################################
h 'Проверка целостности'

c 'Резервная копия содержит файл манифеста, вот его начало и конец:'
eu student "sudo -u postgres head -5 $PGDATA_B/backup_manifest"
eu student "sudo -u postgres tail -6 $PGDATA_B/backup_manifest"

c 'Проверим целостность копии утилитой pg_verifybackup:'
eu student "sudo -u postgres ${BINPATH_B}pg_verifybackup $PGDATA_B"
c 'Утилита проверяет по манифесту наличие файлов, их контрольные суммы, а также наличие и возможность чтения всех записей WAL, необходимых для восстановления.'

p

###############################################################################
h 'Восстановление из копии'

c 'Запускаем второй сервер.'
pgctl_start B

c 'Теперь оба сервера работают одновременно и независимо. Проверим:'
psql_open B 2 -p 5433 -d $TOPIC_DB
s 2 "SELECT * FROM t;"

###############################################################################
stop_here
cleanup
demo_end
