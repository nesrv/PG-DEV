#!/bin/bash

. ../lib

init

start_here 5

###############################################################################
h 'Влияние буферного кеша на выполнение запросов'

c 'Создаем новую БД в кластере и подключаемся к ней (подробнее про базы данных — в модуле «Организация данных»):'

s 1 "CREATE DATABASE $TOPIC_DB;"
s 1 "\c $TOPIC_DB"

c 'Создадим таблицу:'

s 1 'CREATE TABLE t(n integer);'

c 'Заполним таблицу некоторым количеством строк:'

s 1 'INSERT INTO t SELECT id FROM generate_series(1,100_000) AS id;'
echo $(s_bare 1 'VACUUM ANALYZE t;') > /dev/null  # чтобы не объяснять dirtied в следующем EXPLAIN, скрыть команду, чтобы вообще  вопрос не возникал?

c 'Размер буферного кеша показывает параметр shared_buffers:'

s 1 "SHOW shared_buffers;"

c 'Значение по умолчанию слишком мало; в любой реальной системе его требуется увеличить сразу после установки сервера (изменение требует перезапуска).'

c 'Теперь перезапустим сервер, чтобы содержимое буферного кеша сбросилось.'

psql_close 1
pgctl_restart A
psql_open A 1 $TOPIC_DB

c 'Сравним, что происходит при первом и при втором выполнении одного и того же запроса. В этом курсе мы не рассматриваем подробно планы запросов, но иногда будем в них заглядывать. Сейчас мы воспользуемся командой EXPLAIN ANALYZE, которая выполняет запрос и выводит не только план выполнения, но и дополнительную информацию:'

s 1 "EXPLAIN (analyze, buffers, costs off, timing off)
SELECT * FROM t;"

c 'Строка «Buffers: shared»  показывает использование буферного кеша.'
ul 'read — количество буферов, в которые пришлось прочитать страницы с диска.'

s 1 "EXPLAIN (analyze, buffers, costs off, timing off)
SELECT * FROM t;"

ul 'hit — количество буферов, в которых нашлись нужные для запроса страницы.'
c 'Обратите внимание, что во второй раз уменьшилось и время выполнения запроса, и время его планирования (потому что таблицы системного каталога тоже кешируются).'

P 7

###############################################################################
h 'Журнал предзаписи'

c 'Логически журнал можно представить в виде непрерывного потока записей. Каждая запись имеет номер, называемый LSN (Log Sequence Number). Это 64-разрядное число — смещение записи в байтах относительно начала журнала.'
c 'Текущую позицию показывает функция pg_current_wal_lsn:'

# что-то попадает в журнал после обращения
s 1 "SELECT pg_current_wal_lsn();"
export POS1=$(s_bare 1 "SELECT pg_current_wal_lsn();")

c 'Позиция записывается как два 32-разрядных числа через косую черту. Запомним это значение.'
c 'Выполним теперь какие-нибудь операции и посмотрим, как изменилась позиция.'

s 1 "UPDATE t SET n = 100_001 WHERE n = 1;"
s 1 "SELECT pg_current_wal_lsn();"
export POS2=$(s_bare 1 "SELECT pg_current_wal_lsn();")

c 'Интересны не абсолютные числа, а их разница, которая показывает размер сгенерированных журнальных записей в байтах:'

s 1 "SELECT '$POS2'::pg_lsn - '$POS1'::pg_lsn AS bytes;"

c 'Физически журнал хранится в файлах в отдельном каталоге (PGDATA/pg_wal). По умолчанию файлы имеют размер 16 Мбайт, задать другой размер можно при инициализации кластера баз данных.'

c 'На файлы можно взглянуть не только средствами файловой системы, но и с помощью функции:'

s 1 'SELECT * FROM pg_ls_waldir() ORDER BY name LIMIT 10;'

P 9

###############################################################################
h 'Восстановление при помощи журнала'

c 'Измененные табличные страницы находятся в буферном кеше, но еще не записаны на диск. При обычной остановке сервер выполняет контрольную точку, чтобы записать все грязные страницы на диск, но мы сымитируем сбой системы, послав сигнал процессу postmaster.'

kill_postgres A

c 'При старте произойдет восстановление согласованности данных с помощью журнала. Проверим:'

pgctl_start A
psql_open A 1 $TOPIC_DB

s 1 "SELECT min(n), max(n) FROM t;"

c 'Все изменения были восстановлены.'

c 'PostgreSQL автоматически удаляет журнальные файлы, не требующиеся для восстановления, после выполнения контрольной точки.'

###############################################################################
stop_here
cleanup
demo_end
