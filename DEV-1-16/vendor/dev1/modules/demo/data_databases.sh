#!/bin/bash


. ../lib

init

start_here 4

###############################################################################
h 'Базы данных'

c 'Список имеющихся баз показывает команда \l[ist]:'

s 1 '\l'

c 'В списке присутствует четвертая база данных student, которая не создается при инициализации кластера. Она была создана для целей курса, чтобы при запуске psql не указывать базу данных: ведь по умолчанию используется база данных с таким же именем, как и пользователь ОС.'

p

c 'Список баз данных можно посмотреть и в самой базе данных:'

s 1 'SELECT datname, datistemplate, datallowconn, datconnlimit FROM pg_database;'

ul 'datistemplate — является ли база данных шаблоном;'
ul 'datallowconn  — разрешены ли соединения с базой данных;'
ul 'datconnlimit  — максимальное количество соединений (-1 = без ограничений).'

p

###############################################################################
h 'Создание базы из шаблона'

c 'Подключимся к шаблонной базе template1:'

s 1 '\c template1'

c 'Проверим, доступна ли функция digest, вычисляющая хеш-код текстовой строки:'

s 1 "SELECT digest('Hello, world!', 'md5');"

c 'Такой функции нет.'

c 'На самом деле digest определена в пакете pgcrypto. Установим его:'

s 1 'CREATE EXTENSION pgcrypto;'

p

c 'Теперь нам доступны функции, входящие в расширение pgcrypto. Например, можно вычислить MD5-дайджест:'

s 1 "SELECT digest('Hello, world!', 'md5');"

c 'Чтобы шаблон можно было использовать для создания базы, к нему не должно быть активных подключений, поэтому отключимся от базы template1.'

s 1 '\c student'

c 'Для создания новой базы данных служит команда CREATE DATABASE:'

s 1 'CREATE DATABASE db;'
s 1 '\c db'

c 'Базу данных можно создать и из операционной системы утилитой createdb.'

s 1 'SELECT datname, datistemplate, datallowconn, datconnlimit FROM pg_database;'

c 'Поскольку по умолчанию для создания используется шаблон template1, в новой базе также будут доступны функции пакета pgcrypto:'

s 1 "SELECT digest('Hello, world!', 'md5');"

p

###############################################################################
h 'Управление базами данных'

c 'Созданную базу данных можно переименовать (к ней не должно быть подключений):'

s 1 '\c student'
s 1 'ALTER DATABASE db RENAME TO appdb;'
s 1 'SELECT datname, datistemplate, datallowconn, datconnlimit FROM pg_database;'

c 'Можно изменить и другие параметры, например, ограничить количество подключений:'

s 1 'ALTER DATABASE appdb CONNECTION LIMIT 10;'
s 1 'SELECT datname, datistemplate, datallowconn, datconnlimit FROM pg_database;'

p

###############################################################################
h 'Размер базы данных'

c 'Размер базы данных можно узнать с помощью функции:'

s 1 "SELECT pg_database_size('appdb');"

c 'Чтобы не считать разряды, можно вывести размер в читаемом виде:'

s 1 "SELECT pg_size_pretty(pg_database_size('appdb'));"

c 'В этой базе данных еще нет пользовательских объектов (кроме расширения pgcrypto); фактически, это размер «пустой» базы.'

P 7

###############################################################################
h 'Схемы'

s 1 '\c appdb'

c 'Список схем можно узнать командой psql (dn = describe namespace):'

s 1 '\dn'

c 'Создадим новую схему:'

s 1 'CREATE SCHEMA app;'
s 1 '\dn'

c 'Теперь создадим таблицу — по умолчанию она будет создана в схеме public:'

s 1 'CREATE TABLE t(s text);'
s 1 "INSERT INTO t VALUES ('Я - таблица t');"

c 'Список таблиц можно получить командой \dt:'

s 1 '\dt'

c 'Объект можно перемещать между схемами. Поскольку речь идет о логической организации, перемещение происходит только в системном каталоге; сами данные физически остаются на месте.'

s 1 'ALTER TABLE t SET SCHEMA app;'

c 'Теперь к таблице t можно обращаться с явным указанием схемы:'

s 1 'SELECT * FROM app.t;'

c 'Но если опустить имя схемы, таблица не будет найдена:'

s 1 'SELECT * FROM t;'

c 'Как же работать с объектами, располагающимися в разных схемах?'

P 10

###############################################################################
h 'Путь поиска'

c 'Разберемся, почему новая таблица создается в схеме public. Для этого надо посмотреть на путь поиска:'

s 1 'SHOW search_path;'

c "Конструкция \"\$user\" обозначает схему с тем же именем, что и имя текущего пользователя (в нашем случае — $USER). Поскольку такой схемы нет, она игнорируется, и таблица создается в схеме public."

p

c 'Чтобы не думать над тем, какие схемы существуют, каких нет, и какие не указаны явно, можно воспользоваться следующей функцией:'

s 1 'SELECT current_schemas(true);'
c 'Если функция вызывается с аргументом true, в результат включаются системные схемы, например, pg_catalog.'

c 'Установим путь поиска, например, так:'

s 1 'SET search_path = public, app;'

c 'Теперь таблица t будет найдена:'

s 1 'SELECT * FROM t;'

c 'Здесь мы установили конфигурационный параметр на уровне сеанса (при повторном подключении значение пропадет). Устанавливать такое значение на уровне всего кластера тоже не правильно — возможно, этот путь нужен не всегда и не всем.'
c 'Но параметр можно установить и на уровне отдельной базы данных:'

s 1 'ALTER DATABASE appdb SET search_path = public, app;'

c 'Теперь он будет устанавливаться для всех новых подключений к базе appdb. Проверим:'

s 1 '\c appdb'
s 1 'SHOW search_path;'
s 1 'SELECT current_schemas(true);'

c 'Еще одна функция — current_schema — возвращает первое имя схемы, не являющейся системной. Это имя той обычной схемы, в которой будут создаваться новые объекты.'
s 1 'SELECT current_schema();'

P 12

###############################################################################
h 'Временные таблицы и pg_temp'

c 'Создадим временную таблицу:'

s 1 'CREATE TEMP TABLE t(s text);'
s 1 '\dt'

c 'Таблица создана в специальной схеме. Каждому сеансу выделяется отдельная «временная» схема, так что он может видеть только свои собственные временные таблицы.'
c 'Но куда пропала из списка обычная таблица t?'

p

c 'Ответ дает развернутый путь поиска: в него теперь подставлена временная схема, и объект в ней «перекрывает» одноименный объект схемы app.'

s 1 'SELECT current_schemas(true);'
s 1 "INSERT INTO t VALUES ('Я - временная таблица');"

c 'Тем не менее, к каждой из таблиц можно обращаться с явным указанием схемы. Для временной таблицы надо использовать псевдосхему pg_temp — она автоматически отображается в нужную схему pg_temp_N:'

s 1 "SELECT * FROM app.t;"
s 1 "SELECT * FROM pg_temp.t;"

c 'В принципе, во временной схеме можно создавать не только таблицы.'

s 1 'CREATE VIEW v AS SELECT * FROM pg_temp.t;'

c 'Временные таблицы и данные в них могут иметь различные сроки жизни (в зависимости от указания ON COMMIT DELETE, PRESERVE или DROP). В любом случае при переподключении все объекты во временной схеме уничтожаются:'

s 1 '\c appdb'
s 1 'SELECT current_schemas(true);'
s 1 "SELECT * FROM pg_temp.v;"
s 1 "SELECT * FROM pg_temp.t;"

p

###############################################################################
h 'Удаление объектов'

c 'Схему нельзя удалить, если в ней находятся какие-либо объекты:'

s 1 'DROP SCHEMA app;'

c 'Но можно удалить схему вместе со всеми ее объектами:'

s 1 'DROP SCHEMA app CASCADE;'

c 'Если база данных больше не нужна, ее также можно удалить.'

s 1 '\conninfo'
s 1 '\c student'
s 1 'DROP DATABASE appdb;'


###############################################################################
stop_here
cleanup
demo_end
