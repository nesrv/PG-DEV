#!/bin/bash

. ../lib
init

start_here 7
###############################################################################
h 'Логическая репликация'

c 'Мы собираемся настроить логическую репликацию таблицы test с сервера alpha на сервер beta.'
c 'Для начала создадим базу данных.'

s 1 "CREATE DATABASE replica_logical;"
s 1 '\c replica_logical'

c 'Второй кластер изначально будет копией первого, поэтому выполним резервное копирование в каталог PGDATA второго сервера.'

e "pg_basebackup --checkpoint=fast --pgdata=/home/$OSUSER/tmp/backup"
pgctl_status B
e "sudo rm -rf $PGDATA_B"
e "sudo mv /home/$OSUSER/tmp/backup $PGDATA_B"
e "sudo chown -R postgres:postgres $PGDATA_B"

c 'Запускаем второй сервер.'

pgctl_start B

c 'Теперь на первом сервере создадим таблицу и заполним ее данными.'

s 1 'CREATE TABLE test(id int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, descr text);'
s 1 "INSERT INTO test(descr) VALUES ('Раз'), ('Два'), ('Три');"

p

c 'Для работы логической репликации понадобится изменить уровень журнала.'

if [ "$OSUSER" != "postgres" ]; then
  e "psql -U postgres -c \"ALTER SYSTEM SET wal_level = logical\""
else
  s 1 "ALTER SYSTEM SET wal_level = logical;"
fi
pgctl_restart A

c 'На втором сервере таблицы test нет. Поскольку команды DDL не реплицируются, таблицу необходимо создать вручную. При этом таблица подписчика может содержать и дополнительные столбцы, если это необходимо.'

psql_open B 2 -p 5433 -d replica_logical

s 2 'CREATE TABLE test(id int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, descr text, additional text);'

c 'На первом сервере создаем публикацию для таблицы test. Публикация относится к конкретной базе данных; в нее можно включить и несколько таблиц, а можно даже все таблицы сразу (FOR ALL TABLES).'

psql_open A 1 -d replica_logical
s 1 'CREATE PUBLICATION test_pub FOR TABLE test;'

s 1 '\dRp+'

c 'На втором сервере подписываемся на публикацию. При этом на публикующем сервере будет создан слот логической репликации.'
c 'Подписку может создать только суперпользователь. А роль для подключения к публикующему серверу должна иметь атрибуты REPLICATION и LOGIN, и также право чтения публикуемых таблиц — роль student подходит под эти требования.'

s 2 '\c - postgres'

s 2 "CREATE SUBSCRIPTION test_sub
CONNECTION 'port=5432 user=student dbname=replica_logical'
PUBLICATION test_pub;"

s 2 '\c - student'

s 2 '\dRs'

c 'По умолчанию данные сначала синхронизируются между серверами, и только после этого запускается процесс репликации. Это выполняется «бесшовно» с гарантией того, что никакие изменения не будут потеряны.'

s 2 'SELECT * FROM test;'

c 'Проверим, как работает репликация изменений.'

s 1 "INSERT INTO test(descr) VALUES ('Четыре');"
wait_sql 2 "SELECT count(*)=1 FROM test WHERE descr='Четыре';"

s 2 'SELECT * FROM test;'

c 'Состояние подписки можно посмотреть в представлении:'

s 2 'SELECT * FROM pg_stat_subscription \gx'

ul 'received_lsn   — позиция в журнале, до которой получены изменения;'
ul 'latest_end_lsn — позиция в журнале, подтвержденная процессу wal sender.'

c 'К процессам сервера добавился logical replication worker (его номер указан в pg_stat_subscription.pid):'

e 'ps -o pid,command --ppid `sudo head -n 1 '$PGDATA_B'/postmaster.pid`'

P 9
###############################################################################
h 'Слот и логическое декодирование'

c 'Что происходит при логическом декодировании?'
c 'Создадим вручную слот логической репликации. Для передачи изменений подписчику используется модуль вывода pgoutput, а для наблюдения удобнее модуль test_decoding:'

s 1 "SELECT pg_create_logical_replication_slot('test_slot','test_decoding');"

c 'Теперь на сервере alpha два слота:'

s 1 "SELECT slot_name, plugin, slot_type, active FROM pg_replication_slots;"

c 'В отдельном сеансе начнем транзакцию и вставим строку в таблицу:'

psql_open A 4 -d replica_logical
s 4 "BEGIN;"
s 4 "INSERT INTO test(descr) VALUES ('Пять');"

c 'Модуль вывода может запросить у слота изменения:'

s 1 "SELECT * FROM pg_logical_slot_get_changes('test_slot', NULL, NULL);"

c 'Транзакция не завершена, модуль вывода пока ничего не получил. Сделаем еще изменение и завершим транзакцию.'
s 4 "UPDATE test SET descr = 'Beş' WHERE id = 5;"
s 4 "COMMIT;"

s 1 "SELECT * FROM pg_logical_slot_get_changes('test_slot', NULL, NULL);"

c 'Теперь модуль вывода получил изменения.'
p

c 'Удалим тестовый слот, иначе он будет препятствовать удалению сегментов WAL.'
s 1 "SELECT pg_drop_replication_slot('test_slot');"

P 11
###############################################################################
h 'Конфликты'

c 'Заметим, что последовательности не реплицируются. На втором сервере создалась своя собственная последовательность:'

s 2 "INSERT INTO test(descr) VALUES ('Шесть - локально');"

c 'А вот так получится:'

s 2 "INSERT INTO test VALUES (6, 'Шесть - локально');"

c 'Что произойдет, если значение с таким же ключом (6) появится на публикующем сервере?'

s 1 "INSERT INTO test(descr) VALUES ('Шесть');"
s 1 "INSERT INTO test(descr) VALUES ('Семь');"
wait_sql 2 "SELECT pid IS NULL FROM pg_stat_subscription;"

c 'При репликации возникнет конфликт, и она будет приостановлена.'

s 2 'SELECT * FROM test;'

c 'Фактически, процесс logical replication worker будет периодически перезапускаться, проверяя, не устранен ли конфликт. Поэтому информация в pg_stat_subscription пропадает:'

s 2 'SELECT * FROM pg_stat_subscription \gx'

c 'В журнал сообщений будут попадать записи о нарушении ограничений целостности:'

e "sudo tail -n 3 $LOG_B"

c 'Чтобы разрешить этот конфликт, удалим конфликтующую строку из таблицы и немного подождем:'

s 2 'DELETE FROM test WHERE id = 6;'
wait_sql 2 "SELECT count(*)=7 FROM test;"

c 'Проверим:'

s 2 'SELECT * FROM test;'

c 'Данные появились, репликация восстановлена.'

p

###############################################################################
h 'Триггеры на подписчике'

c 'На подписчике могут выполняться триггеры, но если просто создать триггер, то он не отработает. Это удобно, если на обоих серверах созданы одинаковые таблицы с одинаковым набором триггеров: в таком случае триггер уже отработал на публикующем сервере, его не надо выполнять на подписчике.'
c 'Попробуем.'

s 2 "CREATE OR REPLACE FUNCTION change_descr() RETURNS trigger AS \$\$
BEGIN
  NEW.additional := 'из публикации';
  RETURN NEW;
END;
\$\$ LANGUAGE plpgsql;"

s 2 "CREATE TRIGGER test_before_row
BEFORE INSERT OR UPDATE ON test
FOR EACH ROW
EXECUTE FUNCTION change_descr();"

s 1 "INSERT INTO test(descr) VALUES ('Восемь');"

wait_sql 2 "SELECT count(*)=8 FROM test;"
s 2 'SELECT * FROM test;'

c 'Можно изменить таблицу, чтобы триггер срабатывал только при репликации:'
s 2 'ALTER TABLE test ENABLE REPLICA TRIGGER test_before_row;'

c 'Или в обоих случаях: и при репликации, и при локальных изменениях.'
s 2 'ALTER TABLE test ENABLE ALWAYS TRIGGER test_before_row;'

c 'Различить эти ситуации можно с помощью параметра session_replication_role:'

s 2 "CREATE OR REPLACE FUNCTION change_descr() RETURNS trigger AS \$\$
BEGIN
  NEW.additional := current_setting('session_replication_role');
  RETURN NEW;
END;
\$\$ LANGUAGE plpgsql;"

c 'Добавляем по одной строке на каждом сервере:'
s 1 "INSERT INTO test(descr) VALUES ('Девять');"
s 2 "INSERT INTO test(id,descr) VALUES (10,'Десять');"

wait_sql 2 "SELECT count(*)=10 FROM test;"
s 2 'SELECT * FROM test;'

c 'Триггер сработал в обоих случаях, причем понятно, откуда пришла строка.'
p

###############################################################################
h 'Удаление подписки'

c 'Если репликация больше не нужна, надо удалить подписку — иначе на публикующем сервере останется открытым репликационный слот.'

s 2 '\c - postgres'
s 2 'DROP SUBSCRIPTION test_sub;'

###############################################################################
stop_here
cleanup
demo_end
