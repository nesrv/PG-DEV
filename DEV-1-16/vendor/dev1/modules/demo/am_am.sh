#!/bin/bash

. ../lib
init

start_here 4

###############################################################################

h 'Последовательное сканирование'

c 'В плане выполнения запроса последовательное сканирование представлено узлом Seq Scan:'

s 1 "EXPLAIN (buffers) SELECT * FROM flights;"

c 'В скобках приведены важные значения:'

ul 'cost  — оценка стоимости;'
ul 'rows  — оценка числа строк, возвращаемых операцией;'
ul 'width — оценка среднего размера одной строки в байтах.'

c 'Стоимость указывается в некоторых условных единицах и состоит из двух компонент.'
c 'Первое число показывает начальную стоимость вычисления узла. Для последовательного сканирования это ноль — чтобы начать возвращать данные, никакой подготовки не требуется.'
c 'Второе число показывает полную стоимость получения всех данных.'
c 'Как считается полная стоимость?'

p

c 'Оптимизатор PostgreSQL учитывает ввод-вывод и ресурсы процессора. Составляющая ввода-вывода рассчитывается как произведение числа страниц в таблице и условной стоимости чтения одной страницы:'

s 1 "SELECT relpages, current_setting('seq_page_cost'),
  relpages * current_setting('seq_page_cost')::real AS total
FROM pg_class WHERE relname = 'flights';"

c 'Составляющая ресурсов процессора складывается из стоимости обработки каждой строки:'

s 1 "SELECT reltuples, current_setting('cpu_tuple_cost'),
  reltuples * current_setting('cpu_tuple_cost')::real AS total
FROM pg_class WHERE relname = 'flights';"

###############################################################################

h 'Последовательное сканирование и мертвые версии строк'

c 'Создадим копию таблицы flights, отключив для нее автоочистку, чтобы мертвые версии строк не удалялись автоматически:'

s 1 "CREATE TABLE flights_copy
  WITH (autovacuum_enabled = false)
  AS SELECT * FROM flights;"

c 'И проверим размер полученной таблицы:'

s 1 "SELECT pg_size_pretty(pg_total_relation_size('flights_copy'));"

c 'Удалим все строки из этой таблицы:'

s 1 "DELETE FROM flights_copy;"

c 'Мертвые версии строк останутся в файле таблицы до ближайшей очистки, поэтому размер таблицы останется прежним:'

s 1 "SELECT pg_size_pretty(pg_total_relation_size('flights_copy'));"

c 'Получим план запроса с параметрами analyze и buffers — обратите внимание на количество страниц в Buffers и стоимость:'

s 1 "EXPLAIN (analyze, buffers, timing off)
SELECT count(*) FROM flights_copy;"

c 'Прочитано более двух тысяч страниц.'
c 'Очистим таблицу вручную и снова проверим размер таблицы:'

s 1 "VACUUM flights_copy;"
s 1 "SELECT pg_size_pretty(pg_total_relation_size('flights_copy'));"

c 'Мертвые версии строк удалены, размер таблицы уменьшился. Снова получим план запроса:'

s 1 "EXPLAIN (analyze, buffers, timing off)
SELECT count(*) FROM flights_copy;"

c 'Таблица пуста — не прочитано ни одной версии строки, стоимость плана минимальна.'
c 'Время, затраченное на обработку неактуальных версий строк, может быть существенным для таблиц большего размера.'

s 1 "DROP TABLE flights_copy;"

###############################################################################
P 6
h 'Массовое вытеснение'

c 'Сбросим текущие значения статистики ввода-вывода:'

s 1 "SELECT pg_stat_reset_shared('io');"

c 'Прочитаем все строки из таблицы, размер которой больше четверти shared_buffers:'

s 1 "EXPLAIN (buffers, analyze, costs off)
SELECT * FROM tickets;"

PAGES_READ=$(s_bare 1 "SELECT pg_relation_size('tickets')/8192;")
c "Прочитано ${PAGES_READ} страниц."

FROM_WHERE="FROM pg_stat_io
WHERE context = 'bulkread' -- сканирование больших таблиц
AND object = 'relation'
AND backend_type = 'client backend'"

wait_sql 1 "SELECT reads+hits+reuses>0 ${FROM_WHERE};"

c 'Накопленную статистику показывает представление pg_stat_io:'

s 1 "SELECT reads, hits, reuses
${FROM_WHERE};"

PAGES_REUSED=$(s_bare 1 "SELECT reuses ${FROM_WHERE};")

c "Всего было прочитано (reads) ${PAGES_READ} страниц, из них (reuses) ${PAGES_REUSED} страниц были загружены в кеш с вытеснением. Таким образом, для сканирования использовалось буферное кольцо размером ${PAGES_READ} − ${PAGES_REUSED} = $((${PAGES_READ}-${PAGES_REUSED})) страницы."

c 'Снова сбросим статистику и повторно обратимся к той же таблице:'
s 1 "SELECT pg_stat_reset_shared('io');"
s 1 "EXPLAIN (buffers, analyze, costs off)
SELECT * FROM tickets;"

wait_sql 1 "SELECT reads+hits+reuses>0 ${FROM_WHERE};"

s 1 "SELECT reads, hits, reuses
${FROM_WHERE};"

PAGES_READ=$(s_bare 1 "SELECT reads ${FROM_WHERE};")
PAGES_REUSED=$(s_bare 1 "SELECT reuses ${FROM_WHERE};")

c "Теперь видим, что 32 страницы уже находились в кеше после прошлого чтения (hits), так что серверу пришлось прочитать оставшиеся ${PAGES_READ} страниц (reads), и при этом из кеша вытеснилось ${PAGES_REUSED} страниц (reuses). Снова размер кольца составляет ${PAGES_READ} − ${PAGES_REUSED} = $((${PAGES_READ}-${PAGES_REUSED})) буферов, но в них уже находились другие страницы, а не те, что использовались в первый раз."

###############################################################################
P 10
h 'Сканирование индекса'

c 'Рассмотрим таблицу бронирований:'

s 1 '\d bookings'

c 'Столбец book_ref является первичным ключом и для него автоматически был создан индекс bookings_pkey.'

c 'Проверим план запроса с поиском одного значения:'

s 1 "EXPLAIN SELECT * FROM bookings WHERE book_ref = 'CDE08B';"

c 'Выбран метод доступа Index Scan, указано имя использованного индекса. Здесь обращение и к индексу, и к таблице представлено одним узлом плана. Строкой ниже указано условие доступа.'

p

c 'Начальная стоимость индексного доступа — оценка ресурсов для спуска к листовому узлу. Она зависит от высоты дерева. При оценке считается, что необходимые страницы окажутся в кеше, и оцениваются только ресурсы процессора: цифра получается небольшой.'

c 'Полная стоимость добавляет оценку чтения необходимых листовых страниц индекса и табличных страниц.'

c 'В данном случае, поскольку индекс уникальный, модель рассчитывает на то, что будет прочитана одна индексная страница и одна табличная. Стоимость каждого из чтений оценивается параметром random_page_cost:'

s 1 "SELECT current_setting('random_page_cost');"

c 'Его значение обычно больше, чем seq_page_cost, поскольку произвольный доступ стоит дороже (хотя для SSD-дисков этот параметр следует существенно уменьшить).'

c 'Итого получаем 8, и еще немного добавляет оценка процессорного времени на обработку строк.'

p

c 'В строке Index Cond плана указываются только те условия, по которым происходит обращение к индексу или которые могут быть проверены на уровне индекса.'
 c 'Дополнительные условия, которые можно проверить только по таблице, отображаются в отдельной строке Filter:'

s 1 "EXPLAIN
SELECT * FROM bookings
WHERE book_ref = 'CDE08B' AND total_amount > 1000;"

###############################################################################
P 12
h 'Поиск по диапазону'

c 'Мы получаем данные из индекса, спускаясь от корня дерева к левому листовому узлу и проходя по списку листовых страниц. Поэтому индексное сканирование всегда возвращает данные в том порядке, в котором они хранятся в дереве индекса и который был указан при его создании:'

s 1 "EXPLAIN (costs off)
SELECT * FROM bookings
WHERE book_ref > '000900' AND book_ref < '000939'
ORDER BY book_ref;"

p

c 'Тот же самый индекс может использоваться и для получения строк в обратном порядке:'

s 1 "EXPLAIN (analyze, buffers, costs off, timing off, summary off)
SELECT * FROM bookings
WHERE book_ref > '000900' AND book_ref < '000939'
ORDER BY book_ref DESC;"

c 'В этом случае мы спускаемся от корня дерева к правому листовому узлу и проходим по списку листовых страниц в обратную сторону. Обратите внимание на количество страниц (Buffers), которое потребовалось прочитать.'

p

c 'Сравним поиск по диапазону с повторяющимся поиском отдельных значений. Получим тот же результат с помощью конструкции IN, и посмотрим, сколько страниц потребовалось прочитать в этом случае:'

s 1 "EXPLAIN (analyze, buffers, costs off) 
SELECT * FROM bookings
WHERE book_ref IN ('000906','000909','000917','000930','000938')
ORDER BY book_ref DESC;"

c 'Количество страниц увеличилось, поскольку в этом случае приходится спускаться от корня к каждому значению. В версии 17 этот запрос выполняется так же эффективно, как и поиск по диапазону.'

###############################################################################
P 15
h 'Сканирование по битовой карте'

c 'Будем рассматривать таблицу бронирований bookings. Создадим на ней два дополнительных индекса:'

s 1 "CREATE INDEX ON bookings(book_date);"
s 1 "CREATE INDEX ON bookings(total_amount);"

c 'Посмотрим, какой метод доступа будет выбран для поиска диапазона.'

s 1 "EXPLAIN
SELECT * FROM bookings WHERE total_amount < 5000;"

c 'Чтобы упорядочить сканирование большого числа страниц, планировщик выбрал сканирование по битовой карте. Этот метод состоит из двух узлов:'
ul 'Bitmap Index Scan читает индекс и строит битовую карту;'
ul 'Bitmap Heap Scan читает табличные страницы, используя построенную карту.'
c 'Обратите внимание на стоимости: карта должна быть построена полностью, прежде чем ее можно будет использовать.'

p

###############################################################################

h 'Объединение битовых карт'

c 'Кроме того, что битовая карта позволяет избежать повторных чтений табличных страниц, с ее помощью можно объединять несколько условий:'

s 1 "EXPLAIN (costs off)
SELECT * FROM bookings
WHERE total_amount < 5000 OR total_amount > 500000;"

c 'Здесь сначала были построены две битовые карты — по одной на каждое условие, а затем объединены побитовой операцией «или».'

p

c 'Таким же образом могут быть использованы и разные индексы:'

s 1 "EXPLAIN (costs off)
SELECT * FROM bookings
WHERE total_amount < 5000
   OR book_date = bookings.now() - INTERVAL '1 day';"

###############################################################################
P 18
h 'Неточные фрагменты'

c 'Узел Bitmap Heap Scan показывает условие перепроверки (Recheck Cond). Сама же перепроверка выполняется не всегда, а только при потере точности, когда битовая карта не помещается в память.'

c 'Повторим запрос, изменив условие: будем искать бронирования с суммой до 5 тысяч ₽, сделанные за последний месяц.'

month_ago_sql="SELECT bookings.now() - INTERVAL '1 months';"
month_ago=$(s_bare 1 "$month_ago_sql")

s 1 "$month_ago_sql"
s 1 "\bind '$month_ago'"

s 1 "EXPLAIN (analyze, costs off, timing off)
SELECT count(*) FROM bookings
WHERE total_amount < 5000 AND book_date > \$1;"

c 'Строка «Heap Blocks: exact» говорит о том, что все фрагменты битовой карты построены с точностью до строк — перепроверка не выполняется.'

p

c 'Уменьшим размер выделяемой памяти.'

s 1 "SET work_mem = '64kB';"

s 1 "\bind '$month_ago'"

s 1 "EXPLAIN (analyze, costs off, timing off)
SELECT count(*) FROM bookings
WHERE total_amount < 5000 AND book_date > \$1;"

c 'Здесь появились lossy-фрагменты битовой карты — с точностью до страниц. '\
'Также указано, сколько строк не прошло перепроверку условия (Rows Removed by Index Recheck).'

p

c 'Восстановим значение параметра.'

s 1 "RESET work_mem;"

###############################################################################
P 20
h 'Кластеризация'

c 'Если строки таблицы упорядочены так же, как и индекс, битовая карта становится излишней. Продемонстрируем это с помощью команды CLUSTER.'
c 'Сейчас строки таблицы физически упорядочены по номеру бронирования:'

s 1 'SELECT * FROM bookings LIMIT 10;'

p

c 'Переупорядочим строки в соответствии с индексом по столбцу total_amount.'

c 'Пока идет процесс, обратите внимание:'

ul 'Команда CLUSTER устанавливает исключительную блокировку, поскольку полностью перестраивает таблицу (как VACUUM FULL);'
ul 'Строки упорядочиваются, но не поддерживаются в упорядоченном виде — в процессе работы кластеризация будет ухудшаться.'

s 1 "CLUSTER bookings USING bookings_total_amount_idx;"
s 1 "VACUUM ANALYZE bookings;"

c 'Убедимся, что строки упорядочены по стоимости:'

s 1 'SELECT * FROM bookings LIMIT 10;'

p

s 1 "EXPLAIN (costs off)
SELECT * FROM bookings
WHERE total_amount < 5000;"

c 'До кластеризации использовалось сканирование по битовой карте, но теперь проще и выгодней сделать обычное индексное сканирование.'

###############################################################################
P 22
h 'Сканирование только индекса'

c 'Если вся необходимая информация содержится в самом индексе, то нет необходимости обращаться к таблице — за исключением проверки видимости:'

s 1 "EXPLAIN (costs off)
SELECT total_amount FROM bookings
WHERE total_amount > 200000;"

c 'Посмотрим план этого запроса с помощью EXPLAIN ANALYZE:'

s 1 "EXPLAIN (analyze, costs off, timing off, summary off)
SELECT total_amount FROM bookings
WHERE total_amount > 200000;"

c 'Строка Heap Fetches показывает, сколько версий строк было проверено с помощью таблицы. В данном случае карта видимости содержит актуальную информацию, обращаться к таблице не потребовалось.'

p

c 'Обновим первую строку таблицы:'

s 1 "UPDATE bookings
SET total_amount = total_amount
WHERE book_ref = '00F39E';"

c 'Сколько версий строк придется проверить теперь?'

p

s 1 "EXPLAIN (analyze, costs off, timing off, summary off)
SELECT total_amount FROM bookings
WHERE total_amount > 200000;"

c 'Проверять пришлось все версии, попавшие на измененную страницу.'

###############################################################################
P 25
h 'Многоколоночные индексы'

c 'На таблице перелетов ticket_flights создан индекс по столбцам ticket_no, flight_id. Запрос по обоим столбцам использует индекс:'

s 1 "EXPLAIN SELECT *
FROM ticket_flights 
WHERE ticket_no = '0005432000284' AND flight_id = 187662;"

c 'Запрос только по номеру билета — тоже:'

s 1 "EXPLAIN SELECT *
FROM ticket_flights 
WHERE ticket_no = '0005432000284';"

c 'Но для запроса по номеру рейса такой индекс не годится:'

s 1 "EXPLAIN SELECT *
FROM ticket_flights 
WHERE flight_id = 187662;"

###############################################################################
P 27
h 'Include-индексы'

c 'Индекс tickets_pkey не является покрывающим для приведенного запроса, поскольку требуется вернуть не только столбец ticket_no, который есть в индексе, но и book_ref, которого в индексе нет:'

s 1 "EXPLAIN (analyze, buffers, costs off, summary off) 
SELECT ticket_no, book_ref FROM tickets
WHERE ticket_no > '0005435990286';"

c 'Buffers показывает количество прочитанных страниц (hit+read).'
c 'Создадим include-индекс, добавив в него неключевой столбец book_ref, так как он требуется запросу:'

s 1 'CREATE UNIQUE INDEX ON tickets (ticket_no) INCLUDE (book_ref);'

c 'Повторим запрос:'

s 1 "EXPLAIN (analyze, buffers, costs off, summary off)
SELECT ticket_no, book_ref FROM tickets
WHERE ticket_no > '0005435990286';"

c 'Теперь оптимизатор выбирает метод Index Only Scan и использует только что созданный индекс. Количество прочитанных страниц сократилось. Поскольку карта видимости актуальна, обращаться к таблице не пришлось (Heap Fetches: 0).'

c 'В include-индекс можно включать столбцы с типами данных, которые не поддерживаются B-деревом (например, геометрические типы и xml).'

###############################################################################
stop_here
cleanup
demo_end
