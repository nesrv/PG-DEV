#!/bin/bash


. ../lib
init

pgctl_start B

start_here 6
###############################################################################
h 'Команда COPY'

c 'Создадим базу данных и таблицу.'

s 1 'CREATE DATABASE db1;'
s 1 '\c db1'
s 1 'CREATE TABLE t(
    id integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    s text
);'
s 1 "INSERT INTO t(s) VALUES ('Привет, мир!'), (''), (NULL);"

s 1 'SELECT * FROM t;'

c 'Выведем содержимое таблицы на терминал:'
s 1 'COPY t TO stdout;'

c 'Видно, как различаются в выводе пустые строки и неопределенные значения.'
c 'Формат вывода настраивается достаточно гибко. Можно изменить разделитель, представление неопределенных значений и т. п. Например:'
s 1 "COPY t TO stdout WITH (NULL '<NULL>', DELIMITER ',');"

c 'Обратите внимание, что символ-разделитель внутри строки был экранирован (символ для экранирования тоже настраивается).'
c 'Вместо таблицы можно указать произвольный запрос.'
s 1 'COPY (SELECT * FROM t WHERE s IS NOT NULL) TO stdout;'

c 'Таким образом можно сохранить результат запроса, данные представления и т. п.'
c 'Команда поддерживает вывод в формате CSV, который поддерживается множеством программ.'
s 1 "COPY t TO stdout WITH (FORMAT csv);"

c 'Аналогично работает и ввод данных из файла или с консоли.'
s 1 'TRUNCATE TABLE t;'

c 'Но при вводе с консоли требуется маркер конца файла — обратная косая черта с точкой; в обычном файле он не нужен.'
c 'Чтобы данные загрузились, при вводе надо указать те же параметры, что были указаны при выводе.'
c 'При загрузке также можно указать условие:'
s 1 'COPY t FROM stdin WHERE id != 2;
1	Привет, мир!
2	
3	\N
\.'

c 'Вот что загрузилось в таблицу (для наглядности настроим в psql вывод неопределенных значений):'
s 1 "\pset null '\\\\N'"
s 1 'SELECT * FROM t;'

c 'Загрузим все строки:'
s 1 'TRUNCATE TABLE t;'
s 1 'COPY t FROM stdin;
1	Привет, мир!
2	
3	\N
\.'

s 1 'SELECT * FROM t;'

P 8
###############################################################################
h 'Утилита pg_dump'

c 'При запуске без дополнительных параметров утилита pg_dump выдает команды SQL, создающие все объекты в базе данных:'
e "pg_dump -d db1" pgsql
c 'Видно, что pg_dump создал таблицу t и заполнил ее с помощью уже рассмотренной нами команды COPY. Ключ --column-inserts позволяет использовать команды INSERT, но загрузка будет работать существенно дольше.'

p

c 'Рассмотрим некоторые полезные ключи.'
c 'Могут пригодиться при восстановлении копии на системе с другим набором ролей:'
ul '-O, --no-owner    — не генерировать команды для установки владельца объектов;'
ul '-x, --no-acl      — не генерировать команды для установки привилегий;'
ul '--no-comments     — не генерировать комментарии.'

c 'Полезны для выгрузки и загрузки данных частями:'
ul '-s, --schema-only — выгрузить только определения объектов без данных;'
ul '-a, --data-only   — выгрузить только данные, без создания объектов.'

c 'Удобны, если восстанавливать копию на системе, в которой уже есть данные (и наоборот, на чистой системе):'
ul '-c, --clean       — генерировать команды DROP для создаваемых объектов;'
ul '-C, --create      — генерировать команды создания БД и подключения к ней.'

p

c 'Важный момент: в выгрузку попадают и изменения, сделанные в шаблонной БД template1. Поэтому восстанавливать резервную копию лучше на базе данных, созданной из template0. При использовании ключа --create это учитывается автоматически:'
e "pg_dump --create -d db1 | grep 'CREATE DATABASE'" pgsql

p

c 'Существуют ключи для выбора объектов, которые должны попасть в резервную копию:'
ul '-n, --schema — шаблон для имен схем;'
ul '-t, --table  — шаблон для имен таблиц.'

c 'И наоборот, включить в копию все, кроме указанного:'
ul '-N, --exclude-schema — шаблон для имен схем;'
ul '-T, --exclude-table  — шаблон для имен таблиц.'

c 'Например, восстановим таблицу t в другой базе данных на другом сервере.'
psql_open B 2 -p 5433
s 2 'CREATE DATABASE db2;'
e "pg_dump --table=t -d db1 | psql -p 5433 -d db2" pgsql
s 2 '\c db2'
s 2 'SELECT * FROM t;'

P 10
###############################################################################
h 'Утилита pg_dump — формат custom'

c 'Серьезное ограничение обычного формата (plain) состоит в том, что выбирать объекты нужно в момент выгрузки. Формат custom позволяет сначала сделать полную копию, а выбирать объекты уже при загрузке.'
e "pg_dump --format=custom -d db1 -f /home/student/tmp/db1.custom"

c 'Для восстановления объектов из такой копии предназначена утилита pg_restore. Повторим восстановление таблицы t:'
s 2 'DROP TABLE t;'
e "pg_restore --table=t -p 5433 -d db2 /home/student/tmp/db1.custom"

c 'Формат резервной копии указывать не обязательно — утилита распознает его сама.'

p

c 'Утилита pg_restore понимает те же ключи для фильтрации объектов, что и pg_dump, и даже больше:'
ul '-I, --index    — загрузить определенные индексы;'
ul '-P, --function — загрузить определенные функции;'
ul '-T, --trigger  — загрузить определенные триггеры.'

c 'Проверим, как восстановилась таблица:'
s 2 'SELECT * FROM t;'

c 'Еще один пример: восстановим целиком исходную базу данных db1 на другом сервере.'
e "pg_restore --create -p 5433 -d postgres /home/student/tmp/db1.custom"

c 'Здесь мы указали БД postgres, но могли указать любую — утилита сама создаст нужную БД и тут же переключится в нее.'
c 'Проверим:'
s 2 '\c db1'
s 2 'SELECT * FROM t;'

c 'Резервную копию в обычном (plain) формате при необходимости можно изменить в текстовом редакторе. Резервная копия формата custom хранится в двоичном виде, но и для нее доступны более широкие возможности фильтрации объектов, чем рассмотренные ключи. Утилита pg_restore может сформировать список объектов — оглавление резервной копии:'
e "pg_restore --list /home/student/tmp/db1.custom"
c 'Такой список можно записать в файл, отредактировать и использовать его для восстановления с помощью ключа --use-list.'

P 12
###############################################################################
h 'Утилита pg_dump — формат directory'

c 'Формат directory интересен тем, что позволяет выгружать данные в несколько параллельных потоков.'
e "pg_dump --format=directory --jobs=2 -d db1 -f /home/student/tmp/db1.directory"

c 'При этом гарантируется согласованность данных: все параллельные потоки будут использовать один и тот же снимок данных.'
c 'Заглянем внутрь каталога:'
e "ls -l /home/student/tmp/db1.directory"

c 'В нем находится файл оглавления и по одному файлу на каждый выгружаемый объект (у нас он всего один):'
export GZ=`ls /home/student/tmp/db1.directory/*.gz`
e "zcat $GZ"

c 'Для восстановления из резервной копии предварительно отключимся от базы данных db1:'
psql_close 2

c 'В команду восстановления добавляем ключ --clean, который генерирует команду удаления существующей БД:'
e "pg_restore --clean --create --jobs=2 -p 5433 -d postgres /home/student/tmp/db1.directory"

P 15
###############################################################################
h 'Утилита pg_dumpall'

c 'Утилита pg_dump годится для выгрузки одной базы данных, но никогда не выгружает общие объекты кластера БД, такие, как роли и табличные пространства. Чтобы сделать полную копию кластера, нужна утилита pg_dumpall.'

c 'Утилиты pg_dumpall, pg_dump и pg_restore не требуют каких-то отдельных привилегий, но у выполняющей их роли должны быть привилегии на чтение (создание) всех затронутых объектов. Утилитой pg_dump может, например, пользоваться владелец базы данных. Но поскольку для копирования кластера надо иметь доступ ко всем БД, мы выполняем pg_dumpall под суперпользовательской ролью.'

e "pg_dumpall --clean -U postgres -f /home/student/tmp/alpha.sql"

c 'В копию кластера попадают:'
ul 'команды, которые выгружает pg_dump для каждой базы;'
ul 'команды для общих объектов кластера (ролей и табличных пространств).'

c 'Команды для общих объектов можно получить отдельно:'

e "pg_dumpall --clean --globals-only -U postgres" pgsql

c 'Восстановление выполняется с помощью psql — никакой другой формат не поддерживается.'

e "psql -p 5433 -U postgres -f /home/student/tmp/alpha.sql" pgsql

c 'В процессе восстановления могут возникать ошибки из-за невозможности удалить некоторые объекты или создать уже существующие, в данном случае это нормально и не мешает процессу.'

psql_open B 2 -p 5433
s 2 'SELECT datname FROM pg_database;'

s 2 "\c db1"
s 2 "SELECT * FROM t;"

p

###############################################################################
h 'Влияние политик защиты строк'

c 'Если на таблицах определены политики защиты строк, то есть опасность выгрузить неполные данные и даже не узнать об этом. Чтобы этого не произошло, перед выполнением команды COPY можно установить параметр row_security в значение off — в этом случае применение политики приведет к явной ошибке.'
c 'Простой пример. Настроим политику так, чтобы не выводились пустые строки, и включим ее для владельца таблицы:'

s 1 'CREATE POLICY t_s_not_null ON t USING (s IS NOT NULL);'
s 1 'ALTER TABLE t ENABLE ROW LEVEL SECURITY;'
s 1 'ALTER TABLE t FORCE ROW LEVEL SECURITY;'

c 'Теперь запрос покажет только две строки:'

s 1 'COPY t TO stdout;'

c 'Но с параметром, установленным в off, будет зафиксирована ошибка:'

s 1 'SET row_security = off;'
s 1 'COPY t TO stdout;'

c 'Утилиты pg_dump и pg_dumpall автоматически устанавливают параметр row_security = off, так что дополнительные действия предпринимать не нужно:'

#e "pg_dump -d db1 -t t | sed -n '/^COPY/,\$p'"
e "pg_dump -d db1 -t t | grep -A3 '^COPY'"
c 'Получены сообщения об ошибках и в выводе COPY нет данных.'

c 'Если все-таки решено выгрузить часть данных, разрешенную политикой защиты строк, следует использовать --enable-row-security'
#e "pg_dump -d db1 -t t --enable-row-security | sed -n '/^COPY/,\$p'"
e "pg_dump -d db1 -t t --enable-row-security | grep -A3 '^COPY'"
c 'Сообщений об ошибках нет, но получены не все строки, а только те, которые удовлетворили политике защиты строк.'

c 'Чтобы обойти политики защиты строк и выгрузить все данные, пользователь должен иметь атрибут роли BYPASSRLS:'

s 1 '\c - postgres'
s 1 'ALTER USER student BYPASSRLS;'

c 'Теперь запросы от роли student будут игнорировать политики защиты строк:'
e "pg_dump -d db1 -t t --data-only" pgsql

###############################################################################
stop_here
cleanup
demo_end
