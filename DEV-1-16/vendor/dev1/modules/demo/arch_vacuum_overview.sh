#!/bin/bash


. ../lib

init

start_here 10

###############################################################################
h 'Очистка'

s 1 "CREATE DATABASE $TOPIC_DB;"
s 1 "\c $TOPIC_DB"

c 'Создадим таблицу, в целях эксперимента отключив для нее автоматическую очистку, чтобы контролировать время срабатывания:'

# При длинном типе (text) в выхлопе vacuum verbose будет toast, которые еще не проходили.
s 1 'CREATE TABLE bloat(
  id integer GENERATED ALWAYS AS IDENTITY,
  d timestamptz
) WITH (autovacuum_enabled = off);'

c 'Заполним таблицу данными и создадим индекс:'

s 1 'INSERT INTO bloat(d)
  SELECT current_timestamp FROM generate_series(1,100_000);'
s 1 'CREATE INDEX ON bloat(d);'

c 'Сейчас все строки таблицы имеют ровно одну, актуальную, версию.'
c 'Теперь обновим часть строк:'

s 1 "UPDATE bloat SET d = d + interval '1 day' WHERE id <= 10_000;"

c 'Запустим очистку вручную и попросим ее рассказать о том, что происходит:'

s 1 "VACUUM (verbose) bloat;"

c 'Из вывода команды можно заключить, что:'
ul 'из таблицы вычищены мертвые версии строк (tuples: 10000 removed...);'
ul 'из индекса удалены ссылки на них (index scan needed... 10000 dead item identifiers removed).'

P 12

###############################################################################
h 'Оценка разрастания таблиц и индексов'

c 'Понять, насколько критично разрослись объекты и пора ли предпринимать радикальные меры, можно разными способами:'
ul 'запросами к системному каталогу;'
ul 'используя расширение pgstattuple.'

s 1 'CREATE EXTENSION pgstattuple;'

c 'С помощью расширения можно проверить состояние таблицы:'

s 1 "SELECT * FROM pgstattuple('bloat') \gx"

ul 'tuple_percent — доля полезной информации (не 100% из-за накладных расходов).'

c 'И индекса:'

s 1 "SELECT * FROM pgstatindex('bloat_d_idx') \gx"

ul 'leaf_pages — количество листовых страниц индекса;'
ul 'avg_leaf_density — заполненность листовых страниц;'
ul 'leaf_fragmentation — характеристика физической упорядоченности листовых страниц (0 — порядок, 100 — беспорядок).'

p

c 'Теперь обновим сразу половину строк:'

s 1 "UPDATE bloat SET d = d + interval '1 day' WHERE id % 2 = 0;"

c 'Посмотрим на таблицу снова:'

s 1 "SELECT * FROM pgstattuple('bloat') \gx"

c 'Плотность уменьшилась.'

c 'Чтобы не читать всю таблицу целиком, можно попросить pgstattuple показать приблизительную информацию:'

s 1 "SELECT * FROM pgstattuple_approx('bloat') \gx"

c 'И посмотрим на индекс:'

s 1 "SELECT * FROM pgstatindex('bloat_d_idx') \gx"

c 'Заполненность листовых страниц осталась на прежнем уровне, но количество страниц заметно увеличилось.'

P 15

###############################################################################
h 'Перестроение объектов'

c 'Для перестроения индексов удобно использовать команду REINDEX с указанием CONCURRENTLY. Это позволяет не останавливать работу системы на время перестроения.'

s 1 "REINDEX TABLE CONCURRENTLY bloat;"

c 'Теперь посмотрим на индекс:'

s 1 "SELECT * FROM pgstatindex('bloat_d_idx') \gx"

c 'Количество страниц и плотность вернулись к начальным значениям.'

p

c 'Для перестроения таблицы вместе с ее индексами можно воспользоваться командой VACUUM FULL. Однако, в отличие от REINDEX CONCURRENTLY, она полностью блокирует работу с таблицей.'

s 1 "VACUUM FULL bloat;"
s 1 "SELECT * FROM pgstattuple('bloat') \gx"

c 'Плотность увеличилась, освобожденное место отдано операционной системе.'

###############################################################################
stop_here
cleanup
demo_end
