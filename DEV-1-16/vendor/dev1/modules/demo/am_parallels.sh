#!/bin/bash

. ../lib
init

start_here 7

###############################################################################
h 'Агрегация'

c 'Рассмотрим запрос с агрегатной функцией на небольшой таблице. Такой запрос выполняется последовательно:'

s 1 'EXPLAIN
SELECT count(*) FROM seats;'

c 'План состоит из двух узлов. Верхний узел Aggregate, в котором происходит вычисление count, получает данные от дочернего узла Seq Scan.'
c 'Обратите внимание на узел Aggregate: его начальная стоимость практически равна полной. Это означает, что узел не может выдать результат (состоящий из одной строки), пока не обработает все данные — что вполне логично.'

p

c 'Разница между оценкой для Aggregate и верхней оценкой для Seq Scan — стоимость работы собственно узла Aggregate. Она рассчитывается исходя из того, что надо будет посчитать каждую строку, выданную узлом Seq Scan; одна элементарная операция оценивается значением параметра cpu_operator_cost:'

s 1 "SELECT reltuples, current_setting('cpu_operator_cost'),
  reltuples * current_setting('cpu_operator_cost')::real AS total
FROM pg_class WHERE relname = 'seats';"

###############################################################################
h 'Параллельное последовательное сканирование'

c 'Теперь рассмотрим такой же пример, но с большой таблицей. Здесь в плане запроса увидим параллельное последовательное сканирование:'

s 1 'EXPLAIN
SELECT count(*) FROM bookings;'

c 'Все, что находится ниже узла Gather — параллельная часть плана. Она выполняется в каждом из рабочих процессов (которых запланировано два) и, возможно, в ведущем процессе.'
c 'Узел Gather и все узлы выше выполняются только в ведущем процессе. Это последовательная часть плана.'

p

c 'Начнем разбираться снизу вверх. Узел Parallel Seq Scan представляет сканирование таблицы в параллельном режиме.'
c 'В поле rows показана оценка числа строк, которые обработает один рабочий процесс. Всего их запланировано 2, и еще часть работы выполнит ведущий, поэтому общее число строк делится на 2.4 (доля ведущего процесса уменьшается с ростом числа рабочих процессов).'

s 1 "SELECT round(reltuples / 2.4) \"rows\"
FROM pg_class WHERE relname = 'bookings';"

c 'По умолчанию ведущий процесс участвует в выполнении параллельной части плана:'

s 1 "SHOW parallel_leader_participation;"

c 'Если ведущий процесс становится узким местом, его можно разгрузить:'

s 1 'SET parallel_leader_participation = off;'

s 1 'EXPLAIN
SELECT count(*) FROM bookings;'

c 'В этом случае общее число строк делится на число запланированных рабочих процессов (2):'

s 1 "SELECT round(reltuples / 2) \"rows\"
FROM pg_class WHERE relname = 'bookings';"

c 'Вернем значение по умолчанию для параметра parallel_leader_participation:'

s 1 'RESET parallel_leader_participation;'

p

c 'Для оценки узла Parallel Seq Scan компонента ввода-вывода берется полностью (таблицу все равно придется прочитать страница за страницей), а ресурсы процессора делятся между процессами (на 2.4 в данном случае).'

s 1 "SELECT round(
  (
    relpages * current_setting('seq_page_cost')::real +
    reltuples * current_setting('cpu_tuple_cost')::real / 2.4
  )::numeric,
  2
) AS \"cost\"
FROM pg_class WHERE relname = 'bookings';"

p

c 'Выведем план еще раз:'

s 1 'EXPLAIN
SELECT count(*) FROM bookings;'

c 'Следующий узел — Partial Aggregate — выполняет агрегацию данных, полученных рабочим процессом, то есть в данном случае подсчитывает количество строк. Оценка выполняется уже известным образом (и добавляется к оценке сканирования таблицы):'

s 1 "SELECT round(
  (
    reltuples * current_setting('cpu_operator_cost')::real / 2.4 
  )::numeric,
  2
) AS \"cost\"
FROM pg_class WHERE relname = 'bookings';"

p

c 'Следующий узел — Gather — выполняется ведущим процессом. Он отвечает за запуск рабочих процессов и получение от них данных.'
c 'Запуск процессов и пересылка каждой строки данных оцениваются следующими значениями:'

s 1 "SELECT current_setting('parallel_setup_cost') parallel_setup_cost,
current_setting('parallel_tuple_cost') parallel_tuple_cost;"

c 'В данном случае пересылается всего одна строка и основная стоимость приходится на запуск.'

p

c 'И снова посмотрим на план запроса:'

s 1 'EXPLAIN
SELECT count(*) FROM bookings;'

c 'Последний узел — Finalize Aggregate — агрегирует полученные частичные агрегаты. Поскольку для этого надо сложить всего три числа, оценка минимальна.'

P 9

###############################################################################

h 'Число рабочих процессов при последовательном сканировании'

c 'Планировщик не рассматривает параллельные планы для таблиц размером меньше, чем:'

s 1 "SHOW min_parallel_table_scan_size;"

c 'Если запросить информацию из таблицы немного большего размера (flights, 19 Мбайт), будет запланирован один дополнительный процесс:'

s 1 "EXPLAIN (analyze, costs off)
SELECT count(*) FROM flights;"

c 'При запросе данных из большой таблицы (bookings, 105 Мбайт) расчетное количество — три процесса.'

s 1 "EXPLAIN (analyze, costs off)
SELECT count(*) FROM bookings;"

c 'Однако запланировано два процесса, так как параметр max_parallel_workers_per_gather ограничивает число процессов параллельного участка плана и сейчас действует значение по умолчанию (2).'

s 1 "SHOW max_parallel_workers_per_gather;"

c 'Ослабив ограничение, получим план с тремя процессами:'

s 1 "SET max_parallel_workers_per_gather = 5;"

s 1 "EXPLAIN (analyze, costs off)
SELECT count(*) FROM bookings;"

p

c 'Для конкретной таблицы параметром хранения parallel_workers можно задать рекомендованное количество процессов:'

s 1 "ALTER TABLE bookings SET (parallel_workers = 4);"

s 1 "EXPLAIN (analyze, costs off)
SELECT count(*) FROM bookings;"

c 'Если установить параметр хранения в ноль, планировщик всегда будет выбирать последовательное сканирование данной таблицы.'
c 'Но в любом случае количество запланированных процессов не будет превышать max_parallel_workers_per_gather, независимо от параметра хранения.'

p

c 'Восстановим начальные значения параметров:'

s 1 "ALTER TABLE bookings RESET (parallel_workers);"
s 1 "RESET max_parallel_workers_per_gather;"

P 12

###############################################################################
h 'Только последовательные операции'

c 'Некоторые операции всегда выполняются последовательно, например, обращения к временным таблицам.'
c 'Для примера создадим временную таблицу tmp_bookings — копию таблицы bookings:'

s 1 "CREATE TEMP TABLE tmp_bookings AS
  SELECT * FROM bookings;"

c 'Используя операцию объединения множеств UNION ALL (без удаления дубликатов), объединим результаты двух запросов — к основной и временной таблицам:'

s 1 "EXPLAIN (costs off)
SELECT count(*) FROM bookings
UNION ALL
SELECT count(*) FROM tmp_bookings;"

c 'Данные из таблицы bookings читаются параллельно (по умолчанию используется два процесса), а из временной таблицы tmp_bookings — последовательно.'

p

c 'Если операция не выполняется параллельно, это не обязательно означает, что она в принципе не распараллеливается: возможно, планировщик счел, что в данном случае последовательное выполнение эффективнее. Параметр debug_parallel_query позволяет проверить, может ли операция выполняться в параллельном режиме.'

c 'Без агрегации обращение к таблице bookings выполняется последовательно:'

s 1 "EXPLAIN (costs off)
SELECT * FROM bookings;"

c 'Но со включенным параметром мы видим, что в принципе параллельный план возможен:'

s 1 "SET debug_parallel_query = on;"

s 1 "EXPLAIN (costs off)
SELECT * FROM bookings;"

c 'Параметр служит только для отладки. С ним параллельное выполнение планируется, даже если оно не выгодно, и всегда использует единственный процесс.'

s 1 "RESET debug_parallel_query;"

P 16

###############################################################################

h 'Параллельное сканирование индекса'

c 'В качестве примера параллельного сканирования индекс найдем общую стоимость всех бронирований с кодами, меньшими 400000 (они составляют примерно одну четверть от общего числа):'

s 1 "EXPLAIN
SELECT sum(total_amount)
FROM bookings WHERE book_ref < '400000';"

c 'Аналогичный план мы уже видели при параллельном последовательном сканировании, но в данном случае данные читаются с помощью индекса узлом Parallel Index Scan.'

p

c 'Полная стоимость складывается из стоимостей доступа к индексу и к таблице. Оценка стоимости индексного доступа не делится между процессами, так как индекс читается процессами последовательно, страница за страницей:'

s 1 "SELECT round(
  (relpages / 4.0) * current_setting('random_page_cost')::real +
  (reltuples / 4.0) * current_setting('cpu_index_tuple_cost')::real +
  (reltuples / 4.0) * current_setting('cpu_operator_cost')::real
) AS index_cost
FROM pg_class WHERE relname = 'bookings_pkey';"

c 'Значением параметра cpu_operator_cost оценивается операция сравнения значений («меньше»).'

c 'Стоимость доступа к 1/4 табличных страниц (поделенных между процессами) оценивается аналогично последовательному сканированию, поскольку строки физически упорядочены по book_ref:'

s 1 "SELECT round(
  (relpages / 4.0) * current_setting('seq_page_cost')::real +
  (reltuples / 4.0) / 2.4 * current_setting('cpu_tuple_cost')::real
) AS table_cost
FROM pg_class WHERE relname = 'bookings';"

P 18

###############################################################################

h 'Параллельное сканирование только индекса'

c 'Рассмотрим похожий пример, в котором сканирование только индекса выполняется параллельно:'

s 1 "EXPLAIN
SELECT count(book_ref)
FROM bookings WHERE book_ref <= '400000';"

c 'Стоимость доступа к таблице здесь учитывает только обработку строк, без ввода-вывода:'

s 1 "SELECT round(
  (reltuples / 4.0) / 2.4 * current_setting('cpu_tuple_cost')::real
) AS table_cost
FROM pg_class WHERE relname = 'bookings';"

c 'Вклад индексного доступа остается прежним.'

P 20

###############################################################################

h 'Параллельное сканирование по битовой карте'

c 'Для построения битовой карты нам понадобится новый индекс для таблицы bookings:'

s 1 "CREATE INDEX ON bookings(total_amount);"

c 'Сколько бронирований сделано за последний месяц на сумму до 20 тысяч ₽?'

month_ago_sql="SELECT bookings.now() - INTERVAL '1 months';"
month_ago=$(s_bare 1 "$month_ago_sql")

s 1 "$month_ago_sql"

s 1 "\bind '$month_ago'"
s 1 "EXPLAIN (costs off) 
  SELECT count(*) FROM bookings
  WHERE total_amount < 20000 AND book_date > \$1;"

c 'Ведущий процесс строит битовую карту в узле Bitmap Index Scan. Сканирование таблицы по построенной битовой карте выполняется параллельно в узле Parallel Bitmap Heap Scan.'

###############################################################################
stop_here
cleanup
demo_end
