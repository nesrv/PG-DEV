#!/bin/bash

. ../lib

init

psql_open A 2  # понадобится в последнем демо

start_here 4

###############################################################################
h 'Базы данных'

c 'Список баз данных можно получить в psql такой командой:'

s 1 '\l'

c 'База данных student была создана для удобства подключения одноименного пользователя. В выводе команды присутствует ряд столбцов, которые нас сейчас не интересуют.'

c 'Когда мы создаем новую базу данных, она (по умолчанию) копируется из шаблона template1.'

s 1 "CREATE DATABASE $TOPIC_DB;"
s 1 "\c $TOPIC_DB"
s 1 '\l'

P 7

###############################################################################
h 'Схемы'

c 'Для вывода списка схем в psql есть специальная команда (\dn = describe namespace):'

s 1 '\dn'

c 'Эта команда не показывает служебные схемы. Чтобы увидеть их, нужно добавить модификатор S (он работает аналогичным образом и для многих других команд):'

s 1 '\dnS'

c 'Про некоторые из этих схем (public, pg_catalog, information_schema) мы уже говорили; про остальные поговорим позже в других темах.'

c 'Еще один полезный модификатор — знак «плюс», который выводит дополнительную информацию:'

s 1 '\dn+'

p

c 'Создадим новую схему:'

s 1 'CREATE SCHEMA special;'
s 1 '\dn'

c 'Создадим таблицу:'

s 1 'CREATE TABLE t(n integer);'

c 'По умолчанию таблица будет создана в схеме public. Список таблиц в этой схеме можно получить командой \dt с указанием шаблона для имен схем и таблиц:'

s 1 '\dt public.*'

c 'Таблицу (как и другие объекты) можно перемещать между схемами. Поскольку речь идет о логической организации, перемещение происходит только в системном каталоге; сами данные физически остаются на месте.'

s 1 'ALTER TABLE t SET SCHEMA special;'

c 'Что останется в схеме public?'

s 1 '\dt public.*'

c 'Ничего. А в special?'

s 1 '\dt special.*'

c 'Таблица переместилась. Теперь к ней можно обращаться с явным указанием схемы:'

s 1 'SELECT * FROM special.t;'

c 'Но если опустить имя схемы, таблица не будет найдена:'

s 1 'SELECT * FROM t;'

P 9

###############################################################################
h 'Путь поиска'

c 'Путь поиска по умолчанию имеет такое значение:'

s 1 'SHOW search_path;'

c 'Конструкция «$user» обозначает схему с тем же именем, что и имя текущего пользователя (в нашем случае — student). Поскольку такой схемы нет, она игнорируется.'
c 'Чтобы не думать над тем, какие схемы есть, каких нет, а какие недоступны, можно воспользоваться функцией:'

s 1 'SELECT current_schemas(false);'

c 'Передаваемый в функцию логический параметр управляет отображением системных схем, неявно включаемых при поиске. Мы можем увидеть, что кроме исключения несуществующей схемы PostgreSQL неявно включил в начало списка схему системного каталога:'

s 1 'SELECT current_schemas(true);'

c 'Установим путь поиска, например, так:'

s 1 'SET search_path = public, special;'

c 'Теперь таблица будет найдена.'

s 1 'SELECT * FROM t;'

p

c 'Здесь мы установили конфигурационный параметр на уровне сеанса и при переподключении его значение пропадет. Устанавливать такое значение на уровне всего кластера тоже неправильно — возможно, этот путь нужен не всегда и не всем, к тому же в разных БД может быть разный набор схем.'
c 'Но параметр можно установить и на уровне отдельной базы данных:'

s 1 "ALTER DATABASE $TOPIC_DB SET search_path = public, special;"

c "Теперь он будет устанавливаться для всех новых подключений к БД $TOPIC_DB. Проверим:"

s 1 "\c $TOPIC_DB"
s 1 'SHOW search_path;'

P 11

###############################################################################
h 'Системный каталог'

c 'Для того, чтобы вывести информацию о любых объектах, psql (как и другие интерактивные пользовательские средства) обращается к таблицам системного каталога.'
c 'Например, команда \l для получения списка баз данных кластера, обращается к таблице:'

s 1 'SELECT datname FROM pg_database;'

c 'Мы всегда можем посмотреть, какие запросы выполняет команда:'

s 1 '\set ECHO_HIDDEN on'
s 1 '\l'

c 'Таким образом можно исследовать системный каталог.'
c 'Отключим вывод команд.'

s 1 '\set ECHO_HIDDEN off'

p

c 'Список схем находится в таблице:'

s 1 'SELECT nspname FROM pg_namespace;'

c 'А на такие объекты, как таблицы и индексы, можно посмотреть так:'

s 1 "SELECT relname, relkind, relnamespace FROM pg_class WHERE relname = 't';"

export NMSPC=`s_bare 1 "SELECT relnamespace FROM pg_class WHERE relname = 't';"`

c 'Все столбцы здесь начинаются на rel (relation, отношение).'
ul 'relkind — тип объекта (r — таблица, i — индекс и т. п.);'
ul 'relnamespace — схема.'

c 'Поле relnamespace имеет тип oid; вот соответствующая строка таблицы pg_namespace:'

s 1 "SELECT oid, nspname FROM pg_namespace WHERE oid = $NMSPC;"

c 'Для удобства преобразования между текстовым представлением и oid можно воспользоваться приведением к специальному типу-псевдониму regnamespace:'

s 1 "SELECT relname, relkind, relnamespace::regnamespace::text
FROM pg_class WHERE relname = 't';"

c 'А вот как можно получить список объектов в схеме, например, pg_catalog:'

s 1 "SELECT relname, relkind FROM pg_class
WHERE relnamespace = 'pg_catalog'::regnamespace LIMIT 5;"

c 'Аналогичные reg-типы определены и для некоторых других таблиц системного каталога. Они позволяют упростить запросы и обойтись без явного соединения таблиц.'

p

###############################################################################
h 'Удаление объектов'

c 'Можно ли удалить схему special?'

s 1 'DROP SCHEMA special;'

c 'Схему нельзя удалить, если в ней находятся какие-либо объекты. Сначала надо удалить или перенести их.'
c 'Но можно удалить схему сразу вместе со всеми ее объектами:'

s 1 'DROP SCHEMA special CASCADE;'

c 'А что с удалением базы данных целиком? Во-первых, нельзя удалить базу, к которой вы подключены в данный момент, поэтому отключимся от нее.'

s 1 '\conninfo'
s 1 '\c postgres'

c 'Во-вторых, базу данных также нельзя удалить, если к ней есть активные подключения. Создадим такое подключение в отдельном сеансе и попробуем удалить ее:'


s 2 "\c $TOPIC_DB"

s 1 "DROP DATABASE $TOPIC_DB;"

c 'Получили ошибку. Однако можно вызвать команду удаления с параметром FORCE, тогда она будет пытаться принудительно завершить все подключения к БД, а затем удалит ее:'

s 1 "DROP DATABASE $TOPIC_DB WITH (FORCE);"

###############################################################################

stop_here
cleanup
demo_end
