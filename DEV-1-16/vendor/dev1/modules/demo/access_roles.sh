#!/bin/bash

. ../lib

init

PSQL_PROMPT1=$(whoami)'=# '
#PSQL_PROMPT2='alice=> '
#PSQL_PROMPT3='bob=> '

start_here 5

###############################################################################
h 'Групповые роли'

c 'Роль Алисы в демонстрации будет использована в качестве администратора приложения, поэтому она будет зарегистрирована в качестве члена роли student, а последняя роль обладает атрибутом суперпользователя.'
s 1 'CREATE ROLE alice IN GROUP student LOGIN;'

c 'В предыдущий версиях PostgreSQL информация о членстве в группах отображалась командой \du'
s 1 '\du alice'

c 'Сейчас эту информацию выводит команда \drg'
s 1 '\drg alice'
c 'Вывод команды включает в себя поле опции, смысл которых будет объяснен далее.'

c 'Чтобы Алиса не злоупотребляла полномочиями, сделаем так, чтобы все ее команды попадали в журнал сообщений. Для этого мы используем еще один вариант установки конфигурационных параметров — значение присваивается параметру при подключении пользователя к серверу:'
s 1 'ALTER ROLE alice SET log_min_duration_statement=0;'

c 'Можно ограничить действие и конкретной базой данных:'
s 1 'ALTER ROLE alice RESET log_min_duration_statement;'
s 1 "ALTER ROLE alice IN DATABASE student SET log_min_duration_statement=0;" # БД student чтобы не засорять журнал.

c "Приложение, которое будет администрировать Алиса, требует наличие базы данных $TOPIC_DB. Алиса пробует воспользоваться привилегиями суперпользователя."
s 1 '\c - alice'
PSQL_PROMPT1='alice=> '
s 1 '\conninfo'
s 1 "CREATE DATABASE $TOPIC_DB;"
c 'Однако, привилегии не применились.'

p

c 'Алиса не получает возможности групповой роли автоматически. Она может ими воспользоваться, только если переключится на эту роль:'
s 1 'SET ROLE student;'

c 'Чтобы понять, кем является пользователь на самом деле, и на какую роль он переключился, есть функции:'
s 1 'SELECT session_user, current_user;'

c 'Это напоминает команду su в ОС Unix. И теперь Алиса может создать базу данных.'
s 1 "CREATE DATABASE $TOPIC_DB;"

c 'Проверим, кто является владельцем базы данных.'
s 1 "\x \l $TOPIC_DB \x"

c 'Обратите внимание: владелец - student. Алиса назначает владельцем базы данных себя.'
s 1 "ALTER DATABASE $TOPIC_DB OWNER TO session_user;"

p

c 'Алисе далее не потребуются полномочия суперпользователя, ей достаточно лишь возможности управлять пользователями.'
s 1 "ALTER ROLE session_user CREATEROLE;"
s 1 '\du alice'

c 'Покидаем роль student'
s 1 'REVOKE student FROM session_user;'
s 1 'RESET ROLE;'
s 1 '\drg'
s 1 "\c $TOPIC_DB"

P 8
###############################################################################
h 'Псевдороль public'

c 'Алиса создает в схеме public основную таблицу приложения.'
s 1 'CREATE TABLE t ( id integer, msg text );'
s 1 "INSERT INTO t VALUES ( 1, 'Bird is a word!' );"

c 'Алиса должна теперь создать первого обычного пользователя приложения - Боба.'
s 1 'CREATE ROLE bob LOGIN;'

c 'Боб входит в сеанс.'
psql_open A 2 -d $TOPIC_DB -U bob
PSQL_PROMPT2='bob=> '

p

c 'Боб проверяет наличие таблицы и пытается ее прочитать.'
s 2 'SELECT * FROM t;'

c 'У Боба нет привилегии на чтение таблицы.'
s 2 '\dp t'

c 'Алиса понимает, что приложением будут пользоваться множество ролей. Она знает, что в псевдороль public неявно входят все роли, включая ее и Боба. Поэтому она решает предоставить право на чтение таблицы псевдороли public.'
s 1 'GRANT SELECT ON t TO public;'
s 1 '\dp t'

c 'Теперь Бобу удается прочитать таблицу.'
s 2 'SELECT * FROM t;'

c 'Членство в public неявное.'
s 2 '\drg bob'

c 'Раньше любой пользователь мог создать объект в схеме public.'
s 2 'CREATE TABLE bobtable ( n int );'

c 'Не удалось... Боб исследует причину и проверяет права на схему public.'
s 2 '\dn+ public'
c 'Боб имеет право обратиться к объекту в схеме, а создавать объекты в схеме public - нет. Начиная с 15-й версии PostgreSQL права на создание объектов в схеме public у псевдороли public нет. Владелец схемы public - преднастроенная роль pg_database_owner. О таких ролях будет рассказано далее в этой теме.'
psql_close 2

P 13
###############################################################################
h 'Преднастроенные роли'
c 'Исследуя схему public мы уже видели, что владельцем ее является преднастроенная роль pg_database_owner. Поскольку Алиса является владельцем базы данных, она смогла создать в схеме public таблицу. Теперь Алиса решила создать отдельную схему для размещения в ней объектов приложения.'
s 1 'CREATE SCHEMA app;'
s 1 "ALTER DATABASE $TOPIC_DB SET search_path = app, public;"

c 'Также Алиса создает собственную схему для хранения в ней собственных объектов.'
s 1 'CREATE SCHEMA alice;'
s 1 'ALTER ROLE alice SET search_path = "$user", app, public;'
s 1 '\c'

c 'Алиса создает таблицу с приватной информацией.'
s 1 "CREATE TABLE alicetable AS SELECT 'Top secret. Burn before reading!' AS msg;"

c 'Никому прав на собственные схему и таблицу Алиса не предоставляла.'
s 1 '\x \dn+ alice \x'
s 1 '\dp alicetable'

p

c 'Главную таблицу приложения Алиса перемещает в схему app.'
s 1 'ALTER TABLE t SET SCHEMA app;'

c 'Алиса может работать с таблицей, так как является владельцем и самой таблицы и схемы, в которой она расположена.'
s 1 'SELECT * FROM t;'

c 'А Боб - нет.'
psql_open A 2 -d $TOPIC_DB -U bob
PSQL_PROMPT2='bob=> '
s 2 'SELECT * FROM t;'

c 'Боб сомневается, ведь search_path настроен правильно.'
s 2 'SHOW search_path;'
s 2 '\dt *.t'

c 'А если так:'
s 2 'SELECT * FROM app.t;'
c 'Становится понятно, что Алиса не предоставила Бобу прав на использование объектов в схеме app.'

p

c 'Боб обратился за решением этой проблемы, но Алисы не оказалось на рабочем месте и Боб обратился к Системному Администратору. Он занят работой, но решил помочь Бобу простым способом:'
s 1 '\c - student'
PSQL_PROMPT1=$(whoami)'=# '
s 1 'GRANT pg_read_all_data TO bob;'

c 'Участие в этой преднастроенной роли дает право читать любые таблицы в любых схемах.'
s 2 'SELECT * FROM app.t;'

c 'Боб теперь может прочитать любые таблицы, в том числе и в схеме Алисы.'
s 2 'SELECT * FROM alice.alicetable;'
c 'Здесь был явно нарушен принцип наименьших привилегий.'

c 'Получив от Алисы решительный протест, Системный Администратор отзывает участие в преднастроенной роли у Боба.'
s 1 'REVOKE pg_read_all_data FROM bob;'
s 1 '\c - alice'
PSQL_PROMPT1='alice=> '

c 'Алиса на данном этапе решает временно выдать на схему app права для псевдороли public, но на собственную схему никаких прав не предоставляет.'
s 1 'GRANT USAGE ON SCHEMA app TO public;'

c 'Боб, хоть теперь не может заглядывать в таблицу Алисы, но читать главную таблицу приложения может.'
s 2 'SELECT * FROM alice.alicetable;'
s 2 'SELECT * FROM t;'

P 17
###############################################################################
h 'Членство в роли'
c 'Пока доступ к объектам схемы осуществляется с помощью привилегий, предоставленных псевдороли public. Это небезопасно, поэтому все привилегии у public на схему app и таблицу в ней решено изъять.'
s 1 'REVOKE ALL ON app.t FROM public;'
s 1 'REVOKE ALL ON SCHEMA app FROM public;'

c 'Предлагается создать специальную групповую роль с доступом на чтение для схемы app и таблицы app.t'
s 1 'CREATE ROLE appgrp NOLOGIN NOINHERIT;'
s 1 '\du appgrp'
ul 'атрибут NOLOGIN запрещает вход в сеанс;'
ul 'атрибут NOINHERIT предотвращает автоматическое наследование прав групп, в которые может быть добавлена роль.'

c 'Проверим, как связана Алиса с ролями, которые она зарегистрировала, пользуясь атрибутом CREATE USER.'
s 1 '\drg alice'
c 'Как видно из списка, alice - член групп bob и appgrp. Причем appgrp сразу создавалась в качестве групповой роли без права входа в сеанс, а bob - это обычный пользователь. То есть, bob - это тоже групповая роль. Обратите внимание на параметр членства ADMIN. Его наличие говорит о том, что Алиса может управлять ролями, которые она создала - bob и appgrp.'

p

c 'Алиса владеет базой данных, схемой app и таблицей app.t. Поэтому она может предоставить роли appgrp необходимые привилегии, которым ранее обладала псевдогруппа public.'
s 1 'GRANT USAGE ON SCHEMA app TO appgrp;'
s 1 'GRANT SELECT ON app.t TO appgrp;'

c 'Сделаем Боба членом группы appgrp.'
s 1 'GRANT appgrp TO bob;'

c 'Боб может читать таблицу app.t'
s 2 'SELECT * FROM t;'

c 'Проверим, какие параметры членства в appgrp имеет bob.'
s 1 '\drg bob'
ul 'INHERIT - автоматическое наследование привилегий группы, в которые входит роль (то есть, appgrp);'
ul 'SET - возможность явного использования SET ROLE.'

c 'Заметно излишество: Бобу необходимо автоматически получать необходимые для работы привилегии от его членства в appgrp, но ему не требуется выполнять SET ROLE.'
s 1 'GRANT appgrp TO bob WITH SET FALSE;'
s 1 '\drg bob'

p

c 'Зарегистрируем еще одного пользователя.'
s 1 'CREATE USER charlie;'

c 'Предоставим ему доступ к привилегиям appgrp по требованию.'
s 1 'GRANT appgrp TO charlie WITH INHERIT FALSE;'
s 1 '\drg charlie'

c 'Чарли входит в сеанс и пытается обратиться к app.t'
psql_open A 3 -d $TOPIC_DB -U charlie
PSQL_PROMPT3='charlie=> '
s 3 'SELECT * FROM app.t;'
c 'Нет доступа.'

c 'Но если использовать SET ROLE...'
s 3 'SET ROLE appgrp;'
s 3 'SELECT * FROM app.t;'

p

c 'Теперь зарегистрируем еще одну роль для операций, изменяющих данные в таблице app.t, а также дадим право обращаться к объектам схемы app.'
s 1 'CREATE ROLE writegrp NOLOGIN;'
s 1 'GRANT USAGE ON SCHEMA app TO writegrp;'
s 1 'GRANT INSERT, UPDATE, DELETE ON app.t TO writegrp;'
s 1 '\dp app.t'

c 'И сделаем группу appgrp членом группы writegrp.'
s 1 'GRANT writegrp TO appgrp;'
s 1 '\drg *grp'

c 'Проверим, может ли Чарли прочитать и изменить данные в таблице app.t'
s 3 'SELECT session_user, current_user;'
s 3 'SELECT * FROM app.t;'
c 'Пока читать не может.'

c 'Чарли становится appgrp.'
s 3 'SET ROLE appgrp;'
s 3 'SELECT session_user, current_user;'
s 3 'SELECT * FROM app.t;'

c 'Теперь Чарли может читать, но не писать.'
s 3 "INSERT INTO app.t VALUES( 2, 'Peter sad: Bird is a word.' );"

c 'Теперь из appgrp Чарли превращается в writegrp.'
s 3 'SET ROLE writegrp;'
s 3 'SELECT session_user, current_user;'
s 3 "INSERT INTO app.t VALUES( 2, 'Peter said: Bird is a word.' );"

c 'Но теперь Чарли не может читать...'
s 3 'SELECT * FROM app.t;'

c 'Зато читать может Боб, ведь он наследует права appgrp автоматически.'
s 2 'SELECT * FROM app.t;'

c 'Но у Боба не все так хорошо. Так как у группы appgrp установлен атрибут NOINHERIT, то Боб не сможет выполнять операции, изменяющие данные в app.t, так как не имеет право сделать SET ROLE.'
s 2 'SET ROLE appgrp;'
s 2 'SET ROLE writegrp;'

###############################################################################

stop_here

psql_close 1

demo_end
