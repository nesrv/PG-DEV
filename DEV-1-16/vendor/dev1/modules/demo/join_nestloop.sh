#!/bin/bash

. ../lib
init

start_here 10

###############################################################################
h 'Соединение вложенным циклом'

c 'Так выглядит план для соединения вложенным циклом, которое оптимизатор обычно предпочитает для небольших выборок (смотрим перелеты, включенные в два билета):'

s 1 "EXPLAIN (costs off) SELECT *
FROM tickets t
  JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no 
WHERE t.ticket_no IN ('0005432312163','0005432312164');"

c 'Планировщик использует параметризованное соединение. Для каждой строки внешнего набора (узел Index Scan по таблице билетов) выбираются строки из внутреннего набора (узел Index Scan по таблице перелетов), отвечающие условию соединения. На каждой итерации внешнего цикла условие индексного доступа для внутреннего набора имеет вид ticket_no = константа.'

c 'Процесс повторяется до тех пор, пока внешний набор не исчерпает все строки.'

p

c 'Команда EXPLAIN ANALYZE позволяет узнать, сколько раз на самом деле выполнялся вложенный цикл (loops), сколько в среднем было выбрано строк (rows) и сколько потрачено времени (time) за один раз. Видно, что планировщик немного ошибся — в итоге получилось 8 строк вместо 6:'

s 1 "EXPLAIN (analyze, summary off)
SELECT *
FROM tickets t
  JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no 
WHERE t.ticket_no IN ('0005432312163','0005432312164');"

p

c 'Вот еще один пример соединения вложенным циклом. Здесь мы выводим самолеты, способные обслуживать перелеты заданной протяженности:'

s 1 "EXPLAIN (costs off) SELECT *
FROM ( VALUES (1000), (10000) ) d(range)
  JOIN aircrafts a ON a.range >= d.range;"

c 'Это непараметризованное соединение: для каждой строки внешнего набора придется читать весь внутренний набор (про узел Materialize мы будем говорить позже; в данном случае это просто значения из VALUES) и для полученных пар строк проверять условие Join Filter. По сути, это декартово произведение двух наборов строк с фильтрацией.'

c 'Обратите внимание, что соединение вложенным циклом позволяет соединять строки по любому условию, не обязательно по равенству значений.'


###############################################################################
h 'Модификации'

c 'Существует несколько модификаций алгоритма. Для левого соединения:'

s 1 "EXPLAIN (costs off) SELECT * 
FROM aircrafts a
  LEFT JOIN seats s ON (a.aircraft_code = s.aircraft_code) 
WHERE a.model LIKE 'Аэробус%';"

c 'Эта модификация возвращает строки, даже если для левого (a) набора строк не нашлось соответствия в правом (s) наборе.'

p

c 'Антисоединение возвращает те строки одного набора, для которых не нашлось соответствия в другом наборе. Такая модификация может использоваться для обработки предиката NOT EXISTS:'

s 1 "EXPLAIN (costs off) SELECT * 
FROM aircrafts a
WHERE a.model LIKE 'Аэробус%'
AND NOT EXISTS (
  SELECT * FROM seats s WHERE s.aircraft_code = a.aircraft_code
);"

p

c 'Та же операция антисоединения используется и для аналогичного запроса, записанного иначе:'

s 1 "EXPLAIN (costs off) SELECT * 
FROM aircrafts a
  LEFT JOIN seats s ON (a.aircraft_code = s.aircraft_code) 
WHERE a.model LIKE 'Аэробус%'
AND s.aircraft_code IS NULL;"

p

c 'Для предиката EXISTS может использоваться полусоединение, которое возвращает строки одного набора, для которых нашлось хотя бы одно соответствие в другом наборе:'

s 1 "EXPLAIN SELECT * 
FROM aircrafts a
WHERE a.model LIKE 'Аэробус%'
AND EXISTS (
  SELECT * FROM seats s WHERE s.aircraft_code = a.aircraft_code
);"

c 'Обратите внимание: хотя в плане для таблицы s указано rows=149, на самом деле достаточно получить всего одну строку, чтобы понять значение предиката EXISTS.'

p

c 'PostgreSQL так и делает (actual rows=1):'

s 1 "EXPLAIN (analyze, costs off, timing off, summary off)
SELECT *
FROM aircrafts a
WHERE a.model LIKE 'Аэробус%'
AND EXISTS (
  SELECT * FROM seats s WHERE s.aircraft_code = a.aircraft_code
);"

p

c 'Модификаций алгоритма вложенного цикла для правого (RIGHT) и полного (FULL) соединений не существует. Это связано с тем, что полный проход по второму набору строк может не выполняться.'

P 17

###############################################################################
h 'Мемоизация'

c 'Посмотрим план запроса, в котором соединяются таблицы перелетов и модели самолетов.'
c 'Пример подобран таким образом, что из внутреннего набора (таблица aircrafts_data) будет получена только одна строка по ключу f.aircraft_code (Cache Key), она и будет закеширована в узле Memoize:'

s 1 "EXPLAIN (analyze, costs off, timing off, summary off)
SELECT * FROM flights f
  JOIN aircrafts_data a ON f.aircraft_code = a.aircraft_code
WHERE f.flight_no = 'PG0003';"

c 'Обратите внимание:'
ul 'в первый раз за нужной строкой приходится сходить в таблицу (Misses: 1);'
ul 'все повторные обращения обслуживаются кешем (Hits: 112), для этого хватило одного килобайта памяти;'
ul 'вытеснений из кеша не было (Evictions: 0);'
ul 'строки, выбранные из внутреннего набора, всегда умещались в выделенную память (Overflows: 0).'

P 19

###############################################################################
h 'Стоимость соединения вложенным циклом'

c 'Посмотрим на стоимость следующего плана выполнения:'

s 1 "EXPLAIN SELECT *
FROM tickets t
  JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no 
WHERE t.ticket_no IN ('0005432312163','0005432312164');"

c 'Первый результат выдается сразу, без предварительных действий, поэтому начальная стоимость узла Nested Loop равна сумме начальных стоимостей дочерних узлов Index Scan.'

c 'Полная стоимость узла Nested Loop складывается из:'
ul 'стоимости получения данных от внешнего набора (полная стоимость узла Index Scan по билетам);'
ul 'стоимости получения данных от внутреннего набора (полная стоимость узла Index Scan по перелетам), умноженной на расчетное число строк внешнего набора (2);'
ul 'стоимости процессорной обработки строк.'

c 'В общем случае формула более сложная, но основной вывод: стоимость пропорциональна N × M, где N — число строк во внешнем наборе данных, а M — среднее число строк, внутреннего набора, читаемое за одну итерацию. В худшем случае стоимость получается квадратичной.'

P 22

###############################################################################
h 'Вложенный цикл в параллельных планах'

c 'Найдем всех пассажиров, купивших билеты на определенный рейс:'

s 1 "EXPLAIN (costs off)
SELECT t.passenger_name
FROM tickets t
  JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no
  JOIN flights f ON f.flight_id = tf.flight_id
WHERE f.flight_id = 12345;"

c 'На верхнем уровне используется соединение вложенным циклом. Внешний набор данных состоит из одной строки, полученной из таблицы рейсов (flights) по уникальному индексу.'
c 'Для получения внутреннего набора используется параллельный план. Каждый из процессов читает свою часть таблицы перелетов (ticket_flights) и соединяет ее с билетами (tickets) с помощью другого вложенного цикла.'

###############################################################################
stop_here
cleanup
demo_end
