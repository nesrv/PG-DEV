#!/bin/bash

. ../lib
init

start_here 4

###############################################################################
h 'Применение группировки'

c 'Выполним запрос, явно группирующий строки таблицы seats по классам обслуживания:'

s 1 "EXPLAIN (costs off)
SELECT fare_conditions
FROM seats
GROUP BY fare_conditions;"

c 'Теперь получим все различные классы обслуживания:'

s 1 "EXPLAIN (costs off)
SELECT DISTINCT fare_conditions
FROM seats;"

c 'В третьем (исключительно учебном) примере дважды получим все строки таблицы seats и объединим их с помощью команды UNION:'

s 1 "EXPLAIN (costs off)
SELECT fare_conditions
FROM seats
UNION
SELECT fare_conditions
FROM seats;"

c 'Результаты всех трех запросов одинаковы, и во всех планах есть узел HashAggregate.'

P 9

###############################################################################

h 'Группировка хешированием'

c 'Узел, который отвечает за агрегацию методом хеширования, обозначается в плане выполнения как HashAggregate:'

s 1 "EXPLAIN
SELECT aircraft_code, count(*)
FROM seats
GROUP BY aircraft_code;"

c 'Обратите внимание на начальную стоимость: результаты начинают выдаваться только после построения хеш-таблицы по всем строкам.'

c 'Выполнив запрос, можно увидеть объем памяти, выделенной под хеш-таблицу:'
# это в качестве перехода к следующему разделу, где как раз объясним
# про память и про batches

s 1 "EXPLAIN (analyze, timing off, costs off)
SELECT aircraft_code, count(*)
FROM seats
GROUP BY aircraft_code;"

P 12

###############################################################################

h 'Хеш-группировка и пакеты'

c 'Рассмотрим план другого запроса, с группировкой по большой таблице:'

s 1 "EXPLAIN
SELECT book_ref, count(*)
FROM tickets
GROUP BY book_ref;"

c 'В плане появилось предложение Planned Partitions — оптимизатор предполагает, что хеш-таблица не поместится в выделенную память и придется разбивать ее на пакеты.'

c 'Выполним запрос:'

s 1 "EXPLAIN (analyze, timing off, costs off)
SELECT book_ref, count(*)
FROM tickets
GROUP BY book_ref;"

c 'При выполнении размер одного из пакетов оказался слишком велик, поэтому он был дополнительно разбит на два более мелких пакета. Общее количество пакетов (Batches) увеличилось по сравнению с расчетным.'

P 14

###############################################################################

h 'Группировка сортировкой'

c 'Пример плана с узлом GroupAggregate, в котором происходит группировка отсортированного набора:'

s 1 "EXPLAIN (costs off)
SELECT ticket_no, count(ticket_no)
FROM ticket_flights
GROUP BY ticket_no;"

c 'В этом запросе сортировку набора данных обеспечивает индексный доступ.'

c 'Запрос с DISTINCT использует для устранения дубликатов узел Unique:'

s 1 "EXPLAIN (costs off)
SELECT DISTINCT ticket_no
FROM ticket_flights
ORDER BY ticket_no;"

c 'Поскольку узел возвращает результаты, упорядоченные так же, как требует предложение ORDER BY, дополнительная сортировка не требуется.'

p

###############################################################################

h 'Комбинированная группировка'

c 'При группировке по нескольким наборам полей (которая возникает при использовании конструкций GROUPING SETS, CUBE или ROLLUP в предложении GROUP BY) может оказаться выгодным совместно использовать группировку хешированием и группировку сортировкой. В плане запроса такая комбинированная группировка отображается в виде узла MixedAggregate.'

c 'В качестве примера рассмотрим запрос к таблице перелетов, в котором подсчитывается и объединяется количество строк для трех различных вариантов группировки:'

s 1 "EXPLAIN (costs off)
SELECT fare_conditions, ticket_no, amount, count(*)
FROM ticket_flights
GROUP BY
  GROUPING SETS (fare_conditions, ticket_no, amount);"
  
c 'Узел MixedAggregate получает набор данных, отсортированный по столбцу fare_conditions.'

c 'На первом этапе в процессе чтения набора выполняется группировка по столбцу fare_conditions (Group Key). По мере чтения строки переупорядочиваются по столбцу ticket_no и одновременно с этим записываются в хеш-таблицу с ключом amount.'

c 'На втором этапе сканируется набор строк, отсортированный на предыдущем этапе по столбцу ticket_no, и значения группируются по этому же столбцу (Sort Key и вложенный Group Key).'

c 'Наконец, сканируется хеш-таблица, подготовленная на первом этапе, и значения группируются по столбцу amount (Hash Key).'

P 16

###############################################################################
h 'В параллельных планах'

c 'Сгруппируем строки таблицы перелетов по рейсам (их, очевидно, много):'

s 1 "EXPLAIN (analyze, timing off, costs off)
SELECT flight_id, count(*)
FROM ticket_flights
GROUP BY flight_id;"

c 'Здесь каждый процесс в узле Partial HashAggregate вычисляет агрегатную функцию по своим данным с помощью собственной хеш-таблицы. Ведущий процесс после сбора данных в узле Gather получает итоговое значение агрегата, объединяя группы в узле Finalize HashAggregate тоже с помощью хеширования.'

p

c 'Теперь сгруппируем строки таблицы перелетов по стоимости. Количество групп будет небольшим:'

s 1 "SELECT count(DISTINCT amount) FROM ticket_flights;"

c "Как будет выполняться такой запрос?"

s 1 "EXPLAIN (analyze, timing off, costs off)
SELECT amount, count(*)
FROM ticket_flights
GROUP BY amount;"

c 'Поскольку групп немного, оказывается выгодным отсортировать результаты в каждом процессе (Sort), собрать их в ведущем процессе в один отсортированный набор (Gather Merge), а затем, объединяя группы, вычислить агрегатную функцию (Finalize GroupAggregate).'

###############################################################################
stop_here
cleanup
demo_end
