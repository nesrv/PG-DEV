#!/bin/bash

. ../lib

init

start_here 6

###############################################################################

h 'Установка расширения'

c 'Файлы с исходным кодом учебного расширения UOM (единицы измерения) расположены в каталоге uom домашнего каталога пользователя student:'

e "ls -l $UOMDIR"

c 'Если расширение требует компиляции и используется пакетная сборка PostgreSQL, дополнительно должен быть установлен пакет для разработчиков; его имя обычно содержит слово dev, например postgresql-server-dev-16. Пакет включает все необходимое для сборки, в том числе заголовочные файлы PostgreSQL.'

c 'Наше расширение содержит только функции на SQL и не требует компиляции и сборки. Makefile использует инфраструктуру PGXS для установки расширений:'

e "cat $UOMDIR/Makefile" sh

c 'Установка расширения обычно выполняется суперпользователем, в окружении которого путь до исполняемых файлов PostgreSQL может быть не указан. Поэтому в команде установки можно явно задать расположение утилиты pg_config:'

e "sudo make install -C $UOMDIR PG_CONFIG=$(pg_config --bindir)/pg_config"

c 'Теперь файлы расширения uom должны появиться в каталоге SHAREDIR/extension. Расположение SHAREDIR можно посмотреть утилитой pg_config или одноименной функцией SQL:'

s 1 "SELECT setting || '/extension' AS extension_dir 
FROM pg_config()
WHERE name = 'SHAREDIR';"

c 'Кроме uom здесь расположены файлы других установленных расширений.' 

P 9
###############################################################################

c "Список расширений, доступных для загрузки в БД, можно получить запросом:"

s 1 "SELECT name, default_version, installed_version
FROM pg_available_extensions
ORDER BY name;"

c 'По умолчанию установлено только расширение plpgsql.'

c 'Посмотрим на расширение uom. Список версий расширения:'

s 1 "SELECT name, version, installed
FROM pg_available_extension_versions 
WHERE name = 'uom'
ORDER BY version;"

c "Версии расширений в PostgreSQL понимаются как имена, а не как номера. Другими словами, 1.1 и 1.2 — это просто две разные версии, их порядок не определен."

c "Содержимое управляющего файла:"

e "cat $(pg_config --sharedir)/extension/uom.control" conf

c 'Версия по умолчанию 1.2.'

P 11
###############################################################################

c 'Установим версию 1.0 расширения uom в отдельной базе данных:'

s 1 "CREATE DATABASE $TOPIC_DB;"
s 1 "\c $TOPIC_DB"
s 1 "CREATE EXTENSION uom VERSION '1.0';"

c 'Теперь uom появляется в списке расширений текущей базы:'

s 1 '\dx'

c 'Расширение умеет переводить значения из одной единицы длины в другую:'

s 1 "SELECT uom2uom(1, 'верста', 'сажень') AS \"Саженей в версте\";"

c 'Список поддерживаемых единиц измерения записан в таблице:'

s 1 'SELECT * FROM uom_ref;'

c 'Справочная таблица и функция входят в состав расширения. В этом легко убедиться:'

s 1 '\dx+ uom'

c 'В файле SQL для версии 1.0 находятся команды создания таблицы и функции:'

e "cat $(pg_config --sharedir)/extension/uom--1.0.sql" sql

c "Обратите внимание на первую строку: она предотвращает выполнение файла напрямую из psql."

p

c 'Принадлежность к расширению не дает напрямую удалять объекты:'

s 1 'DROP FUNCTION uom2uom(numeric,text,text);'

c 'При этом механизм расширений не отслеживает изменения самих объектов. Вносить изменения в объекты расширения не следует, но добавление столбца в таблицу или изменение функции не вызовет ошибки.'

P 13
###############################################################################
h 'Схема расширения'

c 'Расширение и его объекты можно переносить в другую схему (relocatable=true):'

s 1 "CREATE SCHEMA util;"
s 1 "ALTER EXTENSION uom SET SCHEMA util;"
s 1 "\dx uom"
s 1 "\df util.uom*"

c "Вернем расширение в public:"

s 1 "ALTER EXTENSION uom SET SCHEMA public;"

P 17
###############################################################################
h 'Обновление расширений'

c 'В следующей версии uom 1.1 добавлен тип данных для единиц длины, операторы сравнения для значений этого типа и класс операторов, позволяющий индексировать столбцы таблиц такого типа.'
c 'Файл с изменениями:'

e "cat $(pg_config --sharedir)/extension/uom--1.0--1.1.sql" sql

p

c 'При создании новой версии расширения возможны два сценария:'
ul 'Установлена предыдущая версия, нужно обновить расширение.'
ul 'Предыдущей версии нет, нужно сразу создать более позднюю версию расширения.'

c 'Убедимся, что мы можем перейти с версии 1.0 на версию 1.1. Список доступных вариантов обновления:'

s 1 "SELECT *
FROM pg_extension_update_paths('uom') 
WHERE path IS NOT NULL 
ORDER BY source, target;"

c 'Выполним обновление:'

s 1 "ALTER EXTENSION uom UPDATE TO '1.1';"
s 1 "\dx uom"

c 'Теперь будем создавать версию 1.1, предварительно удалив расширение. При удалении расширения удаляются и его объекты:'

s 1 "DROP EXTENSION uom;"
s 1 "\df uom*"

c 'Сразу создаем расширение версии 1.1 в отдельной схеме, обеспечив видимость объектов в ней:'

s 1 "CREATE EXTENSION uom VERSION '1.1' SCHEMA util;"
s 1 "SET search_path = public, util;"
s 1 "\dx uom"

c 'Для создания версии 1.1 механизм расширений сначала будет искать файл uom--1.1.sql, которого нет. Но к версии 1.1 можно прийти по цепочке: сначала создать версию 1.0, затем обновить до 1.1. Это самый короткий путь до версии 1.1, а в нашем примере и единственный.'

p

c 'Посмотрим на тип данных uom. Для него определены операторы сравнения единиц длины:'

s 1 "SELECT ( 5, 'аршин' )::uom <  ( 10, 'вершок')::uom,
          ( 1, 'верста')::uom <= (500, 'сажень')::uom,
          ( 1, 'сажень')::uom =  (  3, 'аршин' )::uom,
          ( 1, 'верста')::uom >= (500, 'сажень')::uom,
          (10, 'аршин' )::uom >  (  8, 'м'     )::uom;"

c 'Новый тип можно использовать в качестве типа данных для столбца таблицы:'

s 1 'CREATE TABLE t (len uom);'
s 1 "INSERT INTO t VALUES 
    ((3,'сажень')::uom), ((5,'м')::uom), ((17,'вершок')::uom), ((10,'аршин')::uom);"

c 'Данные в таблице можно сортировать:'

s 1 "SELECT * FROM t ORDER BY len;"

c 'И использовать индекс-B-дерево:'

s 1 "CREATE INDEX ON t USING btree (len);"

c 'Проверим использование нового индекса в запросе, предварительно запретив планировщику использование последовательного доступа:'

s 1 "SET enable_seqscan TO off;"
s 1 "EXPLAIN (costs off)
SELECT * FROM t ORDER BY len;"

P 20
###############################################################################
h "Выгрузка pg_dump"

c 'В следующей версии расширения — 1.2 — добавлен вызов функции pg_extension_config_dump.'
c 'Теперь pg_dump будет выгружать содержимое таблицы uom_ref. Добавленный в таблицу столбец predefined нужен для определения строк, которые были вставлены в таблицу не скриптом расширения, а уже после создания.'

c 'Файл обновления:'

e "cat $(pg_config --sharedir)/extension/uom--1.1--1.2.sql" sql

p

c 'Для перехода на версию 1.2 мы не можем просто удалить расширение и пересоздать его. Помешает столбец len таблицы t:'

s 1 'DROP EXTENSION uom;'

c 'Если мы не готовы удалять таблицу (или столбец len), то следует выполнить обновление:'

s 1 "ALTER EXTENSION uom UPDATE;"

c 'Без указания версии обновление выполняется до версии по умолчанию из управляющего файла:'

s 1 "\dx uom"

p

c 'Если выгружать базу данных целиком, то в неё попадают все установленные расширения с учетом соответствующих схем и такое поведение обычно нас устраивает.'
c 'Но если мы захотим выгрузить только схему util, то расширение, установленное в ней, в выгрузку не попадет:'

e "pg_dump -d $TOPIC_DB --schema util | grep 'CREATE'" pgsql

c 'Восстановить впоследствии нашу таблицу с использованием такой копии не получится.'

c 'Ситуацию поможет разрешить параметр --extension. Его применение гарантирует, что в резервную копию попадет команда создания расширения в соответствующей схеме. '
c 'Однако использование этого параметра не приводит к тому, что будут выгружены прочие объекты из других схем, от которых расширение может зависеть. В случае выгрузки только схемы util зависимая таблица t в резервной копии не появится:'

e "pg_dump -d $TOPIC_DB --schema util --extension uom | grep 'CREATE'" pgsql

###############################################################################

stop_here
cleanup
demo_end
