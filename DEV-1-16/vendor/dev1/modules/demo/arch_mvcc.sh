#!/bin/bash

. ../lib

init

start_here 6

###############################################################################
h 'Подготовка'

s 1 "CREATE DATABASE $TOPIC_DB;"
s 1 "\c $TOPIC_DB"

c 'Создадим таблицу и индекс по одному из полей.'

s 1 'CREATE TABLE t(
  id integer,
  s text
);'
s 1 'CREATE INDEX t_s on t(s);'
s 1 "INSERT INTO t(id, s) VALUES (42, 'FOO');"

p

###############################################################################
h 'Структура страницы'

c 'Чтобы изучить структуру страницы и версий строк, воспользуемся расширением pageinspect.'

s 1 'CREATE EXTENSION pageinspect;'

c 'Посмотрим на поля заголовка страницы, определяющие границы ее областей.'

s 1 "SELECT lower, upper, special, pagesize
FROM page_header(get_raw_page('t',0));"

c 'Области занимают следующие диапазоны адресов:'
ul '0 — начало заголовка страницы и указатели на версии строк,'
ul 'lower — начало свободного места,'
ul 'upper — начало данных (версий строк),'
ul 'special — начало спец. данных (только для индексов),'
ul 'pagesize — конец страницы.'

P 14

###############################################################################
h 'Версии строк'

c 'Начнем с чистого листа.'

s 1 "TRUNCATE TABLE t;"

c 'Вставим одну строку, предварительно начав транзакцию.'

s 1 "BEGIN;"
s 1 "INSERT INTO t(id, s) VALUES (42, 'FOO');"

c 'Номер нашей текущей транзакции:'

s 1 "SELECT pg_current_xact_id();"

c 'Посмотрим на таблицу, добавив системные столбцы:'

s 1 "SELECT ctid, xmin, xmax, * FROM t;"

c 'Xmin совпадает с номером нашей транзакции, а xmax равен фиктивному значению 0.'

c 'Чтобы заглянуть в индекс, воспользуемся расширением pageinspect. Нулевая страница индекса содержит метаинформацию, поэтому смотрим в первую.'

s 1 "SELECT itemoffset, ctid, data FROM bt_page_items('t_s',1);"

c 'Видим один указатель на единственную строку таблицы. (В поле data можно угадать ASCII-коды букв FOO.)'

c 'Pageinspect позволяет увидеть и полную информацию о том, что находится в табличной странице, но в этой теме мы не будем углубляться в эти детали.'

c 'Зафиксируем изменение.'

s 1 "COMMIT;"

c 'Теперь проверим, как работает обновление.'

c 'Начнем второй сеанс.'

psql_open A 2 $TOPIC_DB

c 'В нем прочитаем таблицу на уровне Repeatable Read:'

s 2 "BEGIN ISOLATION LEVEL REPEATABLE READ;"
s 2 "SELECT ctid, xmin, xmax, * FROM t;"

c 'Теперь обновляем строку.'

s 1 "BEGIN;"
s 1 "SELECT pg_current_xact_id();"
s 1 "UPDATE t SET s = 'BAR';"

c 'Запрос в первом сеансе выдает одну строку (новую версию):'

s 1 "SELECT ctid, xmin, xmax, * FROM t;"

c 'Но в странице присутствуют обе версии. Предыдущую продолжает видеть второй сеанс:'

s 2 "SELECT ctid, xmin, xmax, * FROM t;"

c 'Номер транзакции, удалившей первую версию строки, записался в xmax.'

c 'При этом в индексной странице обнаруживаем указатели на обе версии:'

s 1 "SELECT itemoffset, ctid, data FROM bt_page_items('t_s',1);"

c 'Индексные записи внутри страницы упорядочены. Поэтому первой идет запись с ключом BAR (ссылается на версию (0,2)), а второй — запись с ключом FOO (ссылается на версию (0,1)).'

c 'Завершим транзакции.'
s 1 "COMMIT;"
s 2 "COMMIT;"

P 16

###############################################################################
h 'HOT-обновление'

c 'Снова опустошим таблицу.'

s 1 "TRUNCATE TABLE t;"

c 'Но пусть теперь индекс будет построен по столбцу id:'

s 1 "DROP INDEX t_s;"
s 1 'CREATE INDEX t_id on t(id);'

s 1 "INSERT INTO t(id, s) VALUES (42, 'FOO');"

c 'Начнем транзакцию с уровнем изоляции Repeatable Read.'

s 2 "BEGIN ISOLATION LEVEL REPEATABLE READ;"
s 2 "SELECT ctid, xmin, xmax, * FROM t;"

c 'До этого мы обновляли проиндексированный столбец, а теперь столбец s не входит ни в один индекс.'

s 1 "BEGIN;"
s 1 "UPDATE t SET s = 'BAR';"

c 'Появляется вторая версия строки.'

s 1 "SELECT ctid, xmin, xmax, * FROM t;"

c 'Но другой сеанс продолжает видеть самую первую версию:'

s 2 "SELECT ctid, xmin, xmax, * FROM t;"

c 'Что же обнаружится в индексе?'

s 1 "SELECT itemoffset, ctid, data FROM bt_page_items('t_id',1);"

c 'Мы видим, что в индексе не добавилась новая запись. Индекс продолжает ссылаться на первую версию, а уже внутри табличной страницы первая версия связана со второй в цепочку.'

c 'Еще один способ убедиться в том, что выполнилось HOT-обновление — заглянуть в статистику текущей транзакции:'

s 1 "SELECT n_tup_upd, n_tup_hot_upd
FROM pg_stat_xact_all_tables
WHERE relid = 't'::regclass;"

c 'Здесь мы видим, что всего транзакция обновила одну строку (n_tup_upd), причем с помощью HOT (n_tup_hot_upd).'

s 1 "ROLLBACK;"
s 2 "ROLLBACK;"

P 24

###############################################################################
h 'Снимки данных'

c 'И еще раз начнем транзакцию в отдельном сеансе.'

s 2 "BEGIN ISOLATION LEVEL REPEATABLE READ;"
s 2 "SELECT ctid, xmin, xmax, * FROM t;"

c 'Одновременно с этим выполним несколько других транзакций.'

s 1 "UPDATE t SET s = 'BAR';"
s 1 "INSERT INTO t(id, s)  VALUES (43, 'BAZ');"

c 'Горизонт транзакций можно увидеть следующим образом:'

s 1 "SELECT query,backend_xmin
FROM pg_stat_activity
WHERE backend_xmin IS NOT NULL
AND datname='$TOPIC_DB';"

c 'Видно, что открытая транзакция удерживает горизонт, поскольку ей нужны старые версии строк.'
c 'Завершим ее.'

s 2 "COMMIT;"

c 'После этого горизонт базы данных продвигается вперед, позволяя очищать неактуальные версии:'

s 1 "SELECT query,backend_xmin
FROM pg_stat_activity
WHERE backend_xmin IS NOT NULL
AND datname='$TOPIC_DB';"

###############################################################################

stop_here
cleanup
demo_end
