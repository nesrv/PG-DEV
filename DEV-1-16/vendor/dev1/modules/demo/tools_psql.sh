#!/bin/bash


. ../lib

init

start_here 6

###############################################################################
h 'Выполнение команд SQL и форматирование результатов'

c 'Запускаем psql:'
psql_open A 1

c 'Проверим текущее подключение:'
s 1 '\conninfo'

c 'С параметрами по умолчанию мы подключились к базе данных student под пользователем student. Подробнее о базах данных и пользователях будет рассказано в следующих темах курса.'

c 'Команда \c[onnect] выполняет новое подключение, не покидая psql.'
p

c 'Команды SQL, в отличие от команд psql, могут располагаться на нескольких строках. Для отправки команды SQL на выполнение завершаем ее точкой с запятой:'
s 1 'SELECT schemaname, tablename, tableowner 
FROM pg_tables 
LIMIT 5;'

c 'Утилита psql умеет выводить результат запросов в разных форматах. Вот только некоторые из них:'
ul 'формат с выравниванием значений;'
ul 'формат без выравнивания;'
ul 'расширенный формат.'

c 'Формат с выравниванием используется по умолчанию. Ширина столбцов выровнена по значениям. Также выводится строка заголовков и итоговая строка.'
p

c 'Команды psql для переключения режима выравнивания:'
ul '\a — переключает режим с выравниванием и без выравнивания;'
ul '\t — переключает отображения строки заголовка и итоговой строки.'

c 'Отключим выравнивание, вывод заголовка и итоговой строки, а в качестве разделителя столбцов установим пробел:'
s 1 '\t \a'
s 1 "\pset fieldsep ' '"
s 1 'SELECT schemaname, tablename, tableowner FROM pg_tables LIMIT 5;'
s 1 '\t \a'

c 'Расширенный формат удобен, когда нужно вывести много столбцов для одной или нескольких записей:'

s 1 '\x'
s 1 "SELECT * FROM pg_tables WHERE tablename = 'pg_class';"
s 1 '\x'

c 'Расширенный формат можно установить только для одного запроса, если в конце вместо точки с запятой указать \gx:'
s 1 "SELECT * FROM pg_tables WHERE tablename = 'pg_proc' \gx"

c 'Все возможности форматирования результатов запросов доступны через команду \pset. А без параметров она покажет текущие настройки форматирования:'

s 1 "\pset"

p

###############################################################################
h 'Взаимодействие с ОС'

c 'В psql можно выполнять команды shell:'

s 1 '\! pwd'

c 'Можно установить переменную окружения операционной системы:'

s 1 '\setenv HELLO Hello'
s 1 '\! echo $HELLO'

c 'Можно записать вывод команды в файл с помощью \o[ut]:'

s 1 '\o tmp/dba1_log'
s 1 'SELECT schemaname, tablename, tableowner FROM pg_tables LIMIT 5;'

c 'На экран ничего не попало. Посмотрим в файле:'

s 1 '\! cat tmp/dba1_log'

c 'Вернем вывод на экран:'

s 1 '\o'

p

###############################################################################
h 'Выполнение скриптов'

c 'Еще один вариант отправить запрос на выполнение — команда \g. В скобках можно указать параметры форматирования только для этого запроса.'

c 'Вывод запроса можно направить команде ОС, если указать ее после вертикальной черты. Например, можно вывести результат запроса на экран, пронумеровав строки:'

s 1 "SELECT format('SELECT count(*) FROM %I;', tablename)
FROM pg_tables
LIMIT 3
\g (tuples_only=on format=unaligned) | cat -n"

c 'В команде \g можно указать имя файла, в который будет направлен вывод:'

s 1 "SELECT format('SELECT count(*) FROM %I;', tablename)
FROM pg_tables
LIMIT 3
\g (tuples_only=on format=unaligned) tmp/dba1_log"

c 'Вот что получилось в файле:'
s 1 '\! cat tmp/dba1_log'

p

c 'Выполняем теперь этот файл как скрипт с помощью \i[nclude]:'

s 1 '\i tmp/dba1_log'

c 'Другие способы выполнить команды из файла:'
ul 'psql < filename'
ul 'psql -f filename'

p

c 'В предыдущем примере можно обойтись и без создания файла, если завершить запрос командой \gexec:'

s 1 "SELECT format('SELECT count(*) FROM %I;', tablename)
FROM pg_tables
LIMIT 3
\gexec"

c 'Команда gexec считает, что в каждом столбце каждой строки выборки содержится SQL-оператор, и выполняет эти операторы один за другим.'

p

###############################################################################
h 'Переменные psql и управляющие конструкции'

c 'По аналогии с shell, psql имеет собственные переменные, среди которых есть ряд встроенных (имеющих особый смысл для psql).'

c 'Запомним в переменной psql User значение переменной окружения USER:'
s 1 '\getenv User USER'

c 'И установим переменную Test:'
s 1 '\set Test Hi'

c 'Чтобы подставить ее значение, надо предварить имя переменной двоеточием:'
s 1 '\echo :Test :User!'

c 'Сбросить переменную можно так:'
s 1 '\unset Test'
s 1 '\echo :Test'

p

c 'Результат запроса можно записать в переменную. Для этого запрос нужно завершить командой \gset:'

s 1 'SELECT now() AS curr_time \gset'
s 1 '\echo :curr_time'

c 'Запрос должен возвращать только одну запись.'
p

c 'Без параметров \set выдает значения всех установленных переменных:'

s 1 '\set'

p

c 'В скриптах можно использовать условные операторы.'

c 'Предположим, что мы хотим проверить, установлено ли значение переменной working_dir, и если нет, то присвоить ей имя текущего каталога. Для проверки существования переменной можно использовать следующую конструкцию, возвращающую логическое значение:'

s 1 '\echo :{?working_dir}'

c 'Следующий условный оператор psql проверяет существование переменной и при необходимости устанавливает значение по умолчанию:'

s 1 '\if :{?working_dir}
   -- переменная определена
\else
   -- в качестве значения можно установить результат выполнения команды ОС
   \set working_dir `pwd`
\endif'

c 'Теперь мы можем быть уверены, что переменная working_dir определена:'
s 1 '\echo :working_dir'

p

###############################################################################
h 'Команды для работы с системным каталогом'

c 'С помощью серии команд, в основном начинающихся на \d, можно быстро и удобно получать информацию об объектах БД.'
c 'Например:'

s 1 '\d pg_tables'

c 'Подробнее такие команды будут рассмотрены позже.'

p

###############################################################################
h 'Настройка psql'

c 'При запуске psql выполняются два скрипта (при их наличии):'

ul 'сначала общий системный скрипт psqlrc;'
ul 'затем пользовательский файл .psqlrc.'

c 'Пользовательский файл должен располагаться в домашнем каталоге, а расположение системного скрипта можно узнать командой:'
e 'pg_config --sysconfdir'

c 'По умолчанию оба файла отсутствуют.'

p

c 'В эти файлы можно поместить команды для настройки сеанса, например:'
ul 'приглашение psql;'
ul 'программу постраничного просмотра результатов запросов;'
ul 'переменные для хранения текста часто используемых команд.'

c 'Для примера запишем в переменную top5 текст запроса на получение пяти самых больших по размеру таблиц:'
s 1 "\set top5 'SELECT tablename, pg_total_relation_size(schemaname||''.''||tablename) AS bytes FROM pg_tables ORDER BY bytes DESC LIMIT 5;'"

c 'Для выполнения запроса достаточно набрать:'
s 1 ":top5"

c 'Если записать эту команду \set в файл ~/.psqlrc, переменная top5 будет доступна сразу после запуска psql.'
p

c 'Благодаря поддержке readline, в psql работает автодополнение ключевых слов и имен объектов, а также сохраняется история команд. Имя и размер файла истории настраиваются переменными HISTFILE, HISTSIZE.'

###############################################################################
stop_here
cleanup
demo_end
