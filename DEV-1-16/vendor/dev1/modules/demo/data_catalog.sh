#!/bin/bash



. ../lib

init

start_here 6

###############################################################################
h 'Некоторые объекты системного каталога'

c 'Создадим базу данных и тестовые объекты:'

s 1 "CREATE DATABASE $TOPIC_DB;"
s 1 "\c $TOPIC_DB"
s 1 'CREATE TABLE employees(
  id integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  name text,
  manager integer
);'
s 1 'CREATE VIEW top_managers AS
  SELECT * FROM employees WHERE manager IS NULL;'

s 1 'CREATE TEMP TABLE emp_salaries(
  employee integer,
  salary numeric
);'

c 'Некоторые таблицы системного каталога нам уже знакомы из предыдущей темы. Это базы данных:'

s 1 "SELECT * FROM pg_database WHERE datname = '$TOPIC_DB' \gx"

p

c 'И схемы:'

s 1 "SELECT * FROM pg_namespace WHERE nspname = 'public' \gx"

p

c 'Важная таблица pg_class хранит описание целого ряда объектов: таблиц, представлений, индексов, последовательностей. Все эти объекты называются в PostgreSQL общим словом «отношение» (relation), отсюда и префикс «rel» в названии столбцов:'

s 1 "SELECT relname, relkind, relnamespace, relfilenode, relowner, relpersistence 
FROM pg_class WHERE relname ~ '^(emp|top)';"

c 'Тип объекта определяется столбцом relkind, по значению в relpersistence можно отличить временные объекты от постоянных.'

c 'При активном использовании временных объектов в таблицах системного каталога будет возникать большое количество неактуальных версий строк, что может привести к снижению производительности на всех этапах выполнения запроса. В таком случае следует позаботиться о своевременной очистке таблиц системного каталога.'

p

c 'Конечно, для каждого типа объектов в pg_class имеет смысл только часть столбцов; кроме того, удобнее смотреть не на идентификаторы (relnamespace, relowner, и т. д.), а на названия соответствующих объектов. Для этого существуют различные системные представления, например:'

s 1 "SELECT schemaname, tablename, tableowner
FROM pg_tables WHERE schemaname ~ '(public|pg_temp.+)';"

p

s 1 "SELECT * 
FROM pg_views WHERE schemaname = 'public';"

p

###############################################################################
h 'Использование команд psql'

c 'В psql встроен набор команд для получения информации из системного каталога. Это короткие команды, пользоваться которыми проще, чем писать запросы к системным таблицам или представлениям.'

c 'Получить список таблиц можно командой:'

s 1 '\dt'

p

c 'Список всех представлений в схеме public:'

s 1 '\dv public.*'

p

c 'Список таблиц, представлений, индексов и последовательностей:'

s 1 '\dtvis'

p

c 'Эти команды можно снабдить модификатором «+», чтобы получить больше информации:'

s 1 '\dt+'

p

c 'Чтобы получить детальную информацию об отдельном объекте, надо воспользоваться командой \d (без дополнительной буквы):'

s 1 '\d top_managers'

p

c 'Модификатор «+» остается в силе:'

s 1 '\d+ top_managers'

c 'Помимо отношений, аналогичным образом можно смотреть и на другие объекты, такие как схемы (\dn) или функции (\df).'

c 'Еще один модификатор «S» позволяет вывести не только пользовательские, но и системные объекты. С помощью шаблона можно ограничить выборку:'

s 1 '\dfS pg*size'

p

c 'Как правило, эти команды psql имеют мнемонические имена. Например, \df — describe function, \sf — show function:'

s 1 '\sf pg_catalog.pg_database_size(oid)' pgsql

c 'Полный список всегда можно посмотреть в документации или командой psql \?.'

p

###############################################################################
h 'Изучение структуры системного каталога'

c 'Все команды psql, описывающие объекты, обращаются к таблицам системного каталога. Чтобы увидеть эти запросы, следует установить переменную psql ECHO_HIDDEN. Получим, например, информацию о таблице employees:'

s 1 '\set ECHO_HIDDEN on'
s 1 '\dt employees'
s 1 '\unset ECHO_HIDDEN'

c 'Для большинства таблиц системного каталога имеются первичные ключи (обычно это столбец oid) и ограничения уникальности. Например, таблица pg_attribute с информацией об атрибутах отношений имеет ограничения:'
s 1 '\d pg_attribute'

c 'Ссылочная целостность обеспечивается с помощью ограничений, похожих на внешние ключи, но немного более сложных: ссылающийся столбец может быть массивом ссылающихся элементов, а неопределенность может обозначаться в нем нулем. Получить список таких псевдо-внешних ключей можно функцией pg_get_catalog_foreign_keys(). Например, pg_attribute "ссылается" на:'

s 1 "SELECT *
FROM   pg_get_catalog_foreign_keys()
WHERE  fktable = 'pg_attribute'::regclass;"
ul 'fktable, fkcols — ссылающаяся таблица и ее столбцы;'
ul 'pktable, pkcols — ключ, на который ссылаются;'
ul 'is_array — является ли ссылающийся столбец массивом;'
ul 'is_opt — может ли ссылающийся столбец содержать 0.'

P 8
###############################################################################
h 'Тип oid и reg-типы'

c 'Как мы видели, описания таблиц и представлений хранятся в таблице pg_class, а описание столбцов располагаются в отдельной таблице pg_attribute. Чтобы получить список столбцов конкретной таблицы, надо соединить pg_class и pg_attribute:'

s 1 "SELECT a.attname, a.atttypid
FROM pg_attribute a
WHERE a.attrelid = (
  SELECT oid FROM pg_class WHERE relname = 'employees'
)
AND a.attnum > 0;"

p

c 'Используя reg-типы, запрос можно написать проще, без явного обращения к pg_class:'

s 1 "SELECT a.attname, a.atttypid
FROM pg_attribute a
WHERE a.attrelid = 'employees'::regclass
AND a.attnum > 0;"

p

c "Здесь мы преобразовали строку 'employees' к типу oid. Аналогично мы можем вывести oid как текстовое значение:"

s 1 "SELECT a.attname, a.atttypid::regtype
FROM pg_attribute a
WHERE a.attrelid = 'employees'::regclass
AND a.attnum > 0;"

p

c 'Полный список reg-типов:'
s 1 "\dT reg*"

###############################################################################
stop_here
cleanup
demo_end
