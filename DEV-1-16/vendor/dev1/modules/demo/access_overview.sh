#!/bin/bash

. ../lib

init

PSQL_PROMPT1=$(whoami)'=# '
PSQL_PROMPT2='alice=> '
PSQL_PROMPT3='bob=> '

start_here 4

###############################################################################
h 'Роли и атрибуты'

c 'Создадим роль для пользователя Алисы. В команде указаны два атрибута.'
c 'В этой теме нам важно, от имени какой роли выполняются команды, поэтому имя текущей роли вынесено в приглашение.'

s 1 "CREATE ROLE alice LOGIN PASSWORD 'alice';"

c 'Список ролей можно узнать командой:'

s 1 '\du'

c 'Обратите внимание, что роль student является суперпользователем. Поэтому до сих пор мы не задумывались о разграничении доступа.'

c 'Создадим и базу данных:'

s 1 "CREATE DATABASE $TOPIC_DB;"
s 1 "\c $TOPIC_DB"

P 8

###############################################################################
h 'Подключение'

c 'Чтобы роль смогла подключиться к базе данных, она должна иметь не только атрибут LOGIN, но и разрешение в файле pg_hba.conf. Располагается он обычно рядом с основным конфигурационным файлом:'

s 1 "SHOW hba_file;"

c 'А прочитать его содержимое можно прямо из SQL:'

s 1 "SELECT type, database, user_name, address, auth_method
FROM pg_hba_file_rules();"

c '(В зависимости от сборки сервера содержимое файла может отличаться.)'
c 'Мы будем использовать подключение к localhost по TCP/IP (host). Такому подключению соответствует вторая строка выборки. Она предполагает аутентификацию по паролю.'

p

c 'Роль alice была создана с паролем, но вообще его можно изменить в любой момент:'

s 1 "ALTER ROLE alice PASSWORD 'alicepass';"

c 'Попробуем установить соединение, указав в строке подключения всю необходимую информацию:'

psql_open A 2 "'host=localhost user=alice dbname=$TOPIC_DB password=alicepass'"
s 2 '\conninfo'

c 'Получилось!'

P 13

###############################################################################
h 'Привилегии'

c 'Алиса смогла подключиться к базе данных. Теперь она хочет создать для себя схему и несколько объектов в ней.'

s 2 "CREATE SCHEMA alice;"

c 'В чем проблема?'

p

c 'У Алисы нет привилегии для создания схем в БД. Выдадим ее:'

s 1 "GRANT CREATE ON DATABASE $TOPIC_DB TO alice;"

c 'Пробуем еще раз:'

s 2 "CREATE SCHEMA alice;"

c 'Теперь, поскольку Алиса является владельцем своей схемы, она имеет все привилегии на нее и может создавать в ней любые объекты. По умолчанию будет использоваться именно эта схема:'

s 2 "SELECT current_schemas(false);"

c 'Алиса создает две таблицы.'

s 2 'CREATE TABLE t1(n numeric);'
s 2 'INSERT INTO t1 VALUES (1);'

s 2 'CREATE TABLE t2(n numeric, who text DEFAULT current_user);'
s 2 'INSERT INTO t2(n) VALUES (1);'

c 'А суперпользователь создает другую роль для пользователя Боба, который будет обращаться к объектам, принадлежащим Алисе.'

s 1 "CREATE ROLE bob LOGIN PASSWORD 'bobpass';"

psql_open A 3 "'host=localhost user=bob dbname=$TOPIC_DB password=bobpass'"

c 'Боб попробует обратиться к таблице t1.'

s 3 'SELECT * FROM alice.t1;'

c 'В чем причина ошибки?'

p

c 'Нет доступа к схеме, так как Боб не суперпользователь и не владелец этой схемы.'
c 'Проверить права на доступ к схеме можно так (столбец Access privileges):'

s 2 '\x \dn+ \x'

c 'Привилегии отображаются в формате: роль=привилегии/кем_предоставлены.'
c 'Каждая привилегия кодируется одним символом, в частности для схем:'
ul 'U = usage;'
ul 'C = create.'

c 'Если имя роли опущено (как в последней строке), то имеется в виду псевдороль public. Обратите внимание, что на схему public у псевдороли public есть лишь привилегия usage. Здесь pg_database_owner соответствует владельцу базы данных.'
c 'Если же опущено все поле (как в первой строке), то имеются в виду привилегии по умолчанию: alice имеет обе доступные привилегии на собственную схему, а остальные роли не имеют никаких.'

p

c 'Предоставим доступ к схеме для Боба. Это может сделать Алиса как владелец.'

s 2 'GRANT CREATE, USAGE ON SCHEMA alice TO bob;'

c 'Боб снова пробует обратиться к таблице:'

s 3 'SELECT * FROM alice.t1;'

c 'Снова ошибка. В чем причина?'

p

c 'На этот раз у Боба есть доступ к схеме, но нет доступа к самой таблице. Вот как проверить доступ:'

s 2 '\dp alice.t1'

c 'И снова видим пустое поле: доступ есть только у владельца, то есть у Алисы.'
c 'Алиса предоставляет Бобу доступ на чтение и изменение:'

s 2 'GRANT SELECT, UPDATE ON alice.t1 TO bob;'

c 'А для второй таблицы — доступ на вставку и чтение одного столбца:'

s 2 'GRANT SELECT(n), INSERT ON alice.t2 TO bob;'

c 'Посмотрим, как изменились привилегии:'

s 2 '\dp alice.*'

c 'Теперь пустое поле «проявилось», и мы видим, что в нем находится полный перечень привилегий. Ниже — обозначения, не все они вполне очевидные:'
ul 'a = insert'
ul 'r = select'
ul 'w = update'
ul 'd = delete'
ul 'D = truncate'
ul 'x = reference'
ul 't = trigger'

c 'Привилегии для столбцов отображаются отдельно (столбец Column privileges).'

p

c 'На этот раз попытки Боба увенчаются успехом. Чтобы не указывать каждый раз имя схемы, Боб добавляет его к своему пути поиска.'

s 3 'ALTER ROLE bob SET search_path = public, alice;'

c 'Теперь путь поиска будет устанавливаться в каждом сеансе Боба.'
s 3 '\c'
s 3 'SHOW search_path;'

s 3 'UPDATE t1 SET n = n + 1;'
s 3 'SELECT * FROM t1;'

c 'Но другие операции по-прежнему запрещены:'

s 3 'DELETE FROM t1;'

c 'И вторая таблица:'

s 3 'INSERT INTO t2(n) VALUES (100);'
s 3 'SELECT n FROM t2;'

c 'А чтение другого столбца запрещено:'

s 3 'SELECT * FROM t2;'

P 16

###############################################################################
h 'Групповые роли'

c 'Вспомним, что Боб не смог прочитать второй столбец таблицы:'

s 3 'SELECT * FROM t2;'

c 'Суперпользователь включает Боба в предопределенную роль pg_read_all_data:'

s 1 'GRANT pg_read_all_data TO bob;'

c 'Теперь Боб сможет получить доступ на чтение ко всем таблицам так, как будто ему были выданы привилегии SELECT на все таблицы и USAGE на все схемы:'

s 3 'SELECT * FROM t2;'

c 'Получить информацию о членстве в ролях можно с помощью команды \drg утилиты psql:'

s 1 '\drg'

c 'Столбец Options содержит информацию об атрибутах, описывающих включение. Здесь для роли bob, включенной в pg_read_all_data, SET означает возможность переключения на групповую роль, а INHERIT — использование привилегий группы без явного переключения на нее.'

c 'Исключим пользователя bob из группы:'

s 1 'REVOKE pg_read_all_data FROM bob;'


P 19

###############################################################################
h 'Подпрограммы и привилегии по умолчанию'

c 'Алиса создает функцию:'

s 2 "CREATE FUNCTION foo() RETURNS SETOF t2
AS \$\$
SELECT * FROM t2;
\$\$ LANGUAGE sql STABLE;"

c 'Сможет ли Боб вызвать ее, если Алиса не выдала ему привилегию EXECUTE?'

s 3 'SELECT foo();'

c 'Вызвать — да, но Боб не сможет получить доступ к объектам, на которые у него нет соответствующих привилегий.'

c 'Если Боб создаст свою таблицу t2 в схеме public, функция будет работать для обоих пользователей — но с разными таблицами, поскольку у Алисы и Боба разные пути поиска.'
c 'Чтобы Боб мог создать таблицу в схеме public, потребуется явно выдать ему привилегию CREATE на схему (начиная с версии PostgreSQL 15):'

s 1 "GRANT CREATE ON SCHEMA public TO bob;"

s 3 "CREATE TABLE t2(n numeric, who text DEFAULT current_user);"
s 3 "INSERT INTO t2(n) VALUES (42);"
s 3 'SELECT foo();'

s 2 'SELECT foo();'

c 'Другой доступный вариант — объявить функцию как работающую с правами ее владельца:'

s 2 "ALTER FUNCTION foo() SECURITY DEFINER;"

c 'В этом случае функция всегда будет выполняться с правами Алисы, независимо от того, кто ее вызывает.'
c 'Боб удаляет свою таблицу...'

s 3 "DROP TABLE t2;"

c '...и получает доступ к содержимому таблицы Алисы:'

s 3 'SELECT foo();'

c 'В этом случае Алисе надо внимательно следить за выданными привилегиями. Скорее всего, потребуется отозвать EXECUTE у роли public и выдавать ее явно только нужным ролям.'

s 2 "REVOKE EXECUTE ON ALL ROUTINES IN SCHEMA alice FROM public;"
s 3 'SELECT foo();'

c 'Но дело осложняется тем, что по умолчанию привилегия на выполнение автоматически выдается роли public на каждую вновь создаваемую функцию.'

p

c 'Для того чтобы конкретные пользователи получали или, наоборот, лишались тех или иных привилегий на вновь создаваемые объекты, можно настроить привилегии по умолчанию:'

s 2 "ALTER DEFAULT PRIVILEGES
FOR ROLE alice
REVOKE EXECUTE ON ROUTINES FROM public;"

s 2 "ALTER DEFAULT PRIVILEGES
FOR ROLE alice
GRANT EXECUTE ON ROUTINES TO bob;"

s 2 '\ddp'

c 'Теперь Боб сразу получает привилегию на выполнение подпрограмм, создаваемых Алисой, а остальные пользователи не смогут их выполнять.'

s 2 "CREATE FUNCTION bar() RETURNS integer
LANGUAGE sql IMMUTABLE SECURITY DEFINER
RETURN 1;"

s 3 "SELECT bar();"

###############################################################################
stop_here
cleanup
demo_end
