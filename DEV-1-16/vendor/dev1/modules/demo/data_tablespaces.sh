#!/bin/bash


. ../lib

init

psql_open A 1

start_here 5

###############################################################################
h 'Системные табличные пространства'

c 'При создании кластера создаются два табличных пространства:'

s 1 'SELECT * FROM pg_tablespace;'

ul 'pg_global  — общие объекты кластера;'
ul 'pg_default — табличное пространство по умолчанию.'

p

###############################################################################
h 'Пользовательские табличные пространства'

c 'Для нового табличного пространства нужен пустой каталог, владельцем которого является пользователь postgres.'

e "sudo -u postgres mkdir ${H}/ts_dir"

c 'Теперь можно создать табличное пространство:'

s 1 "CREATE TABLESPACE ts LOCATION '${H}/ts_dir';"

c 'Список табличных пространств можно получить и командой psql:'

s 1 '\db'

p

c 'У каждой базы данных есть табличное пространство «по умолчанию». Создадим базу и назначим ей ts в качестве такого пространства:'

s 1 'CREATE DATABASE appdb TABLESPACE ts;'

c 'Теперь все создаваемые таблицы и индексы будут попадать в ts, если явно не указать другое.'
c 'Подключимся к базе:'

s 1 '\c appdb'

c 'Создадим таблицу:'

s 1 'CREATE TABLE t1(
  id integer GENERATED ALWAYS AS IDENTITY,
  name text
);'

c 'При создании объекта можно указать табличное пространство явно:'

s 1 'CREATE TABLE t2(
  n numeric
) TABLESPACE pg_default;'
s 1 "SELECT tablename, tablespace FROM pg_tables WHERE schemaname = 'public';"

c 'Пустое поле tablespace указывает на табличное пространство по умолчанию, а у второй таблицы поле заполнено.'

c 'Для индекса также можно указать табличное пространство:'
s 1 'CREATE INDEX ON t1(id) TABLESPACE pg_default;'
s 1 "SELECT indexname,tablespace FROM pg_indexes WHERE tablename='t1';"

c 'Еще один способ задать табличное пространство без явного указания при создании объекта — предварительно установить значение параметра default_tablespace.'

p

c 'Одно табличное пространство может использоваться для объектов нескольких баз данных.'

s 1 'CREATE DATABASE configdb;'

c 'У этой БД табличным пространством по умолчанию будет pg_default.'

s 1 '\c configdb'
s 1 'CREATE TABLE t(
  n integer
) TABLESPACE ts;'

s 1 "\d t"

c 'Для временных таблиц и их индексов можно указать отдельное табличное пространство по умолчанию:'

s 1 "SET temp_tablespaces = 'ts';"

s 1 'CREATE TEMP TABLE temp(s text);'

s 1 "\d temp"

c 'В параметре temp_tablespaces можно указать несколько табличных пространств, в этом случае сервер выберет одно из них случайным образом.'

p

###############################################################################
h 'Управление объектами в табличных пространствах'

c 'Таблицы (и другие объекты, например, индексы), можно перемещать между табличными пространствами.'

s 1 '\c appdb'
s 1 'ALTER TABLE t1 SET TABLESPACE pg_default;'
s 1 "SELECT tablename, tablespace FROM pg_tables WHERE schemaname = 'public';"

c 'Перенести индексы можно и при перестроении:'
s 1 'REINDEX (TABLESPACE ts) TABLE t1;'

p

c 'Можно переместить и все объекты из одного табличного пространства в другое:'

s 1 'ALTER TABLE ALL IN TABLESPACE pg_default SET TABLESPACE ts;'
s 1 "SELECT tablename, tablespace FROM pg_tables WHERE schemaname = 'public';"

c 'Важно понимать, что перенос в другое табличное пространство (в отличие от переноса в другую схему) — физическая операция, связанная с копированием файлов данных из каталога в каталог. На время ее выполнения доступ к перемещаемому объекту полностью блокируется.'

p

###############################################################################
h 'Размер табличного пространства'

c 'Мы уже рассматривали, как узнать объем, занимаемый базой данных. Можно узнать и объем объектов в табличном пространстве:'

s 1 "SELECT pg_size_pretty( pg_tablespace_size('ts') );"

c 'Почему размер так велик, хотя в табличном пространстве всего несколько пустых таблиц?'

p

c 'Поскольку ts является табличным пространством по умолчанию для базы appdb, в нем хранятся объекты системного каталога. Они и занимают место.'

c 'В psql получить размер табличных пространств можно командой:'
s 1 '\db+'

p

###############################################################################
h 'Удаление табличного пространства'

c 'Табличное пространство можно удалить, но только в том случае, если оно пусто:'

s 1 'DROP TABLESPACE ts;'

c 'В отличие от удаления схемы, в команде DROP TABLESPACE нельзя использовать предложение CASCADE: объекты табличного пространства могут принадлежать разным базам данных, а подключены мы только к одной.'

c 'Но можно выяснить, в каких базах есть зависимые объекты. В этом нам поможет системный каталог.'
c 'Сначала узнаем и запомним идентификатор табличного пространства:'

s 1 "SELECT oid FROM pg_tablespace WHERE spcname = 'ts';"
export TSOID=$(s_bare 1 "SELECT OID AS tsoid FROM pg_tablespace WHERE spcname = 'ts';")

c 'Затем получим список баз данных, в которых есть объекты из удаляемого пространства:'

s 1 "SELECT datname
FROM pg_database
WHERE oid IN (SELECT pg_tablespace_databases($TSOID));"

p

c 'Дальше подключаемся к каждой базе данных и получаем список объектов из pg_class:'

s 1 '\c configdb'
s 1 "SELECT relnamespace::regnamespace, relname, relkind
FROM pg_class
WHERE reltablespace = $TSOID;"

p

c 'Таблица больше не нужна, удалим ее.'

s 1 'DROP TABLE t;'

c 'И вторая база данных. Поскольку ts является табличным пространством по умолчанию, у объектов в pg_class идентификатор табличного пространства равен нулю. Это, как нам уже известно, объекты системного каталога:'

s 1 '\c appdb'
s 1 'SELECT count(*) FROM pg_class WHERE reltablespace = 0;'

c 'Табличное пространство по умолчанию можно сменить; при этом все таблицы из старого пространства физически переносятся в новое. Предварительно надо отключиться от базы.'

s 1 '\c postgres'
s 1 'ALTER DATABASE appdb SET TABLESPACE pg_default;'

c 'Вот теперь табличное пространство может быть удалено.'

s 1 'DROP TABLESPACE ts;'

c 'От имени пользователя postgres удалим каталог, созданный для табличного пространства.'
e "sudo -u postgres rm -rf ${H}/ts_dir"

###############################################################################
stop_here
cleanup
demo_end
