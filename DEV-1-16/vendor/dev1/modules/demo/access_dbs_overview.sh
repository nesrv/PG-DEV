#!/bin/bash

. ../lib

init

start_here 7

###############################################################################
h 'Начальный пользователь'
c 'По умолчанию владельцем процессов экземпляра является пользователь, инициализировавший кластер командой initdb - bootstrap user.'
e 'ps -fC postgres'
c 'Столбец UID показывает владельца процесса.'

c 'Установленные из пакетов программного обеспечения для Linux систем сборки PostgreSQL используют systemd. Проверим это с помощью представления pg_config.'
s 1 "SELECT * FROM (
        SELECT string_to_table(setting, ''' ''') AS setting 
                FROM pg_config WHERE name = 'CONFIGURE'
        ) 
        WHERE setting ~ 'systemd';"

c 'В документации PostgreSQL имеются рекомендации по безопасности для владельца процессов экземпляра, связанные с межпроцессным взаимодействем System V IPC. Рекомендуется регистрировать владельца процесса в качестве системного пользователя. Проверим, является ли пользователь postgres системным.'
e 'id postgres'
e 'grep ^UID_MIN /etc/login.defs'
c 'Пользователи ОС с UID меньшими, чем UID_MIN, заданный в файле /etc/login.defs, являются системными.'

c 'Пользователи со стандартными именами, например, postgres, являются обычными целями для атак. Простой вход в сеанс от имени таких пользователей должен быть исключен. Однако, на случай аварийной необходимости обычно предусматривают вход в сеанс PostgreSQL от имени postgres. Поэтому, хотя у пользователя ОС postgres и установлена интерактивная оболочка Bash, но пароль в ОС у этого пользователя должен быть заблокирован. А действия от имени postgres обычно выполняются с помощью команды sudo.'
e 'sudo passwd -S postgres'
c 'Символ L в статусе пароля означает, что пароль заблокирован.'

p

c 'Процессы экземпляра ограничиваются средствами операционной системы. Если бы экземпляр PostgreSQL запускался бы непосредственно из пользовательского сеанса оболочки Bash, то для управления ограничениями было бы достаточно команды ulimit. Для сервисов, управляемых systemd, ограничения определяются в "юнитах" - специальных скриптах, которые можно просматривать и изменять. Проверим, например, ограничение по максимально разрешенному количеству открытых файлов для экземпляра.'
e 'sudo systemctl show postgresql.service | grep -i ^limitnof'
c 'Имеется два вида ограничений: "жесткое" - его невозможно превзойти, а также "мягкое" - для предварительного предупреждения.'

c 'Проверим, применились ли ограничения по количеству открываемых файлов. Для любого работающего процесса ограничения можно узнать в файле limits в подкаталоге /proc с PID этого процесса. Используем для определения PID postmaster дополнительный файл, заданный параметром external_pid_file.'
s 1 "\dconfig *pid*"

e "sudo -u postgres grep -i 'open.*file' /proc/$(cat /var/run/postgresql/16-main.pid)/limits"

p

c 'При создании кластера баз данных утилитой initdb по умолчанию на каталог PGDATA устанавливаются полные права только для владельца (в восмеричной нотации 0700 - drwx------). Ни у группы, ни у всех остальных, прав нет. Проверим:'
s 1 "\dconfig+ data_dir*"
s 1 "\! ls -ld /var/lib/postgresql/16/main"

c 'Процессы экземпляра при таких правах на PGDATA работают с umask 0077, автоматически установливая на файлы, создаваемые PostgreSQL, прав 0700 (используется побитовое "вычитание" umask из 0777). Проверим umask процесса postmaster.'
e "sudo -u postgres grep -i 'umask' /proc/$(cat /var/run/postgresql/16-main.pid)/status"

c 'Для проверки создадим таблицу, запишем в нее строку и проверим права на соответствующие файлы.'
s 1 "CREATE TABLE t ( n int );"
s 1 "INSERT INTO t VALUES(1);"
fPATH=$(s_bare 1 "SELECT pg_relation_filepath('t');")
s 1 "SELECT pg_relation_filepath('t');"
s 1 "\! ls -l ${fPATH}*"
s 1 "DROP t;"

c 'Если при создании кластера команде initdb был задан параметр -g или --allow-group-access, то к содержимому PGDATA будет добавлен доступ для группы postgres. И все пользователи операционной системы, входящую в эту группу, смогут читать содержимое файлов. Это небезопасно, но требуется для некоторых программ резервного копирования. Кроме того, если до запуска экземпляра на каталог PGDATA рекурсивно добавить права на чтение, то процессы экземпляра автоматически запустятся с umask 0027, и создаваемые файлы также будут получать права на чтение.'

c 'Остановим экземпляр и добавим на PGDATA и его содержимое права на чтение.'
pgctl_stop A
e 'sudo -u postgres chmod -R g+rX /var/lib/postgresql/16/main'

c 'Запустим сервер и проверим umask процесса postmaster.'
pgctl_start A
e "sudo -u postgres grep -i 'umask' /proc/$(cat /var/run/postgresql/16-main.pid)/status"

c 'Снова создадим таблицу, запишем в нее строку и проверим права на соответствующие файлы.'
s 1 "CREATE TABLE t ( n int );"
s 1 "INSERT INTO t VALUES(1);"
fPATH=$(s_bare 1 "SELECT pg_relation_filepath('t');")
s 1 "SELECT pg_relation_filepath('t');"
s 1 "\! ls -l ${fPATH}*"
s 1 "DROP t;"

c 'Каталог, в котором размещаются UDS сокеты для локальных подключений, группа и права, устанавливаемые на сокеты UDS, задаются параметрами:'
s 1 "\dconfig+ *unix*"

c 'Прослушиваемые интерфейсы и порт TCP устанавливаются следующими параметрами:'
s 1 "\dconfig+ (list*|port)"

c 'Шифрование?'

###############################################################################

stop_here
cleanup
demo_end
