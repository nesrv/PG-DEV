#!/bin/bash

. ../lib

init

s 1 "CREATE DATABASE $TOPIC_DB;"
s 1 "\c $TOPIC_DB"

start_here 4

###############################################################################
h 'Явное объявление составного типа'

c 'Первый способ ввести составной тип — явным образом объявить его:'

s 1 'CREATE TYPE currency AS (
    amount numeric,
    code   text
);'

s 1 '\dT'

c 'Такой тип можно использовать точно так же, как любой другой тип SQL. Например, мы можем создать таблицу со столбцами такого типа:'

s 1 'CREATE TABLE transactions(
    account_id   integer,
    debit        currency,
    credit       currency,
    date_entered date DEFAULT current_date
);'

c 'Нужно ли так делать — вопрос сложный, универсальных рецептов тут не существует. В каких-то случаях это может быть полезно; в каких-то удобнее действовать в реляционных рамках: выделить сущность, представляемую типом, в отдельную таблицу и ссылаться на нее. Это позволить избежать избыточности данных (нормализация) и упростить индексирование (в случае составного типа скорее всего потребуется индекс по выражению).'

c 'В целом PostgreSQL обладает достаточно большим количеством встроенных типов данных, так что, вероятно, необходимость в создании собственного типа будет возникать не часто, если не сказать редко.'

p

###############################################################################
h 'Конструирование значений составных типов'

c 'Значения составного типа можно формировать в виде строки, внутри которой в скобках перечислены значения. Обратите внимание, что строковые значения заключается в двойные кавычки:'

s 1 $'INSERT INTO transactions VALUES (1, NULL, \'(100.00,"RUB")\');'

c 'Другой способ — конструктор ROW:'

s 1 "INSERT INTO transactions VALUES (2, ROW(80.00,'RUB'), NULL);"

c 'Если составной тип содержит более одного поля, то слово ROW можно опустить:'

s 1 "INSERT INTO transactions VALUES (3, (20.00,'RUB'), NULL);"

s 1 'SELECT * FROM transactions;'

p

###############################################################################
h 'Атрибуты составного типа как отдельные значения'

c 'Обращение к отдельному атрибуту составного типа — по сути то же, что и обращению к столбцу таблицы, ведь строка таблицы — это и есть составной тип:'

s 1 "SELECT t.account_id FROM transactions t;"


c 'Как правило, требуется брать составное значение в скобки, например, чтобы отличать атрибут записи от столбца таблицы:'

s 1 'SELECT (t.debit).amount, (t.credit).amount FROM transactions t;'

c 'Или в случае, когда используется выражение:'

s 1 "SELECT ((10.00,'RUB')::currency).amount;"

c 'Составное значение не обязательно связано с каким-то конкретным типом, оно может быть неопределенной записью псевдотипа record:'

s 1 "SELECT (10.00,'RUB')::record;"

c 'Но получится ли обратиться к атрибуту такой записи?'

s 1 "SELECT ((10.00,'RUB')::record).amount;"

c 'Нет, поскольку атрибуты такого типа безымянные.'

p

###############################################################################
h 'Неявный составной тип для таблиц'

c 'Более частое на практике применение составных типов — упрощение работы функций с таблицами.'

c 'При создании таблицы неявно создается и одноименный составной тип. Например, места в кинотеатре:'

s 1 'CREATE TABLE seats(
    line text,
    number integer
);'

s 1 "INSERT INTO seats VALUES
    ('A', 42), ('B',  1), ('C', 27);"

c 'Команда \dT «прячет» такие неявные типы, но при желании их можно увидеть непосредственно в таблице pg_type:'

s 1 "SELECT typtype FROM pg_type WHERE typname = 'seats';"

ul 'c — composite, то есть составной тип.'

p

###############################################################################
h 'Операции над значениями составных типов'

c 'Значения составных типов можно сравнивать между собой. Это происходит поэлементно (примерно так же, как строки сравниваются посимвольно):'

s 1 "SELECT * FROM seats s WHERE s < ('B',52)::seats;"

c 'Осторожно: существует много тонкостей, связанных с неопределенными значениями внутри записей.'

c 'Также работает проверка на неопределенность IS [NOT] NULL и сравнение IS [NOT] DISTINCT FROM.'

c 'Составные типы можно использовать с подзапросами, что бывает очень удобно.'

c 'Добавим таблицу с билетами:'

s 1 'CREATE TABLE tickets(
    line text,
    number integer,
    movie_start date
);'

s 1 "INSERT INTO tickets VALUES
    ('A', 42, current_date),
    ('B',  1, current_date+1);"

c 'Теперь, например, можно написать такой запрос для поиска мест в билетах на сегодняшний сеанс:'

s 1 'SELECT * FROM seats WHERE (line, number) IN (
    SELECT line, number FROM tickets WHERE movie_start = current_date
);'

c 'Без возможности использовать подзапрос пришлось бы явно соединять таблицы.'

P 6

###############################################################################
h 'Параметры составного типа'

c 'Определим функцию, принимающую значение составного типа и возвращающую текстовый номер места.'

s 1 "CREATE FUNCTION seat_no(seat seats) RETURNS text
IMMUTABLE LANGUAGE sql
RETURN seat.line || seat.number;"

c 'Обратите внимание, что в общем случае конкатенация имеет категорию изменчивости stable, а не immutable, поскольку для некоторых типов данных приведение к строке может давать разные результаты в зависимости от настроек.'

s 1 "SELECT seat_no(ROW('A',42));"

c 'Что удобно, такой функции можно передавать непосредственно строку таблицы:'

s 1 'SELECT s.line, s.number, seat_no(s.*) FROM seats s;'

c 'Можно обойтись и без «звездочки»:'

s 1 'SELECT s.line, s.number, seat_no(s) FROM seats s;'

c 'Синтаксисом допускается обращение к функции как к столбцу таблицы (и наоборот, к столбцу как к функции):'

s 1 'SELECT s.line, number(s), s.seat_no FROM seats s;'

c 'Таким образом можно использовать функции как вычисляемые «на лету» столбцы таблиц.'
c 'Что, если и в таблице окажется столбец с тем же именем? Раньше в любом случае предпочтение отдавалось столбцу, а начиная с версии 11 выбор зависит от синтаксической формы.'

p

c 'Разумеется, такого же эффекта можно добиться, определив представление.'

s 1 "CREATE VIEW seats_v AS
    SELECT s.line, s.number, seat_no(s) FROM seats s;"
s 1 "SELECT line, number, seat_no FROM seats_v;"

c 'А начиная с версии 12, PostgreSQL позволяет при создании таблиц объявить «настоящие» вычисляемые столбцы. Правда, в отличие от стандарта SQL, такие столбцы не вычисляются на лету, а сохраняются в таблице:'

s 1 "CREATE TABLE seats2(
    line text,
    number integer,
    seat_no text GENERATED ALWAYS AS (seat_no(ROW(line,number))) STORED
);"

s 1 '\d seats2'

s 1 "INSERT INTO seats2 (line, number)
    SELECT line, number FROM seats;"
s 1 "SELECT * FROM seats2;"

c 'Если мы впоследствии решили, что следует явно задавать значение поля, то нам достаточно удалить выражение:'

s 1 "ALTER TABLE seats2 ALTER COLUMN seat_no DROP EXPRESSION;"

c 'Существующие данные в столбце остались, но столбец теперь не вычисляемый, а "обычный":'

s 1 "SELECT * FROM seats2;"

s 1 '\d seats2'

P 8

###############################################################################
h 'Функции, возвращающие одно значение'

c 'Напишем функцию, конструирующую и возвращающую табличную строку по отдельным компонентам.'
c 'Такую функцию можно объявить как RETURNS seats:'

s 1 "CREATE FUNCTION seat(line text, number integer) RETURNS seats
IMMUTABLE LANGUAGE sql
RETURN ROW(line, number)::seats;"

s 1 "SELECT seat('A', 42);"

c 'Мы получаем результат составного типа. Его можно «развернуть» в однострочную таблицу:'

s 1 "SELECT (seat('A', 42)).*;"

c 'Имена столбцов и их типы получены здесь из описания составного типа seats.'

c 'Но функцию можно вызывать не только в списке выборки запроса или в условиях, как часть выражения. К функции можно обратиться и в предложении FROM, как к таблице:'

s 1 "SELECT * FROM seat('A', 42);"

c 'При этом мы тоже получаем однострочную таблицу.'

c 'Кстати, можно ли подобным образом вызвать функцию, возвращающую отдельное (скалярное) значение?'

s 1 "SELECT * FROM abs(-1.5);"

c 'Да, так тоже можно: мы получили одну строку, состоящую из одного столбца.'

p

c 'Другой вариант, который мы уже видели в теме «SQL. Функции» — объявить выходные параметры.'
c 'Заодно отметим, что в запросе не обязательно собирать составной тип из отдельных полей — это будет проделано автоматически:'

s 1 'DROP FUNCTION seat(text, integer);'

s 1 "CREATE FUNCTION seat(line INOUT text, number INOUT integer)
IMMUTABLE LANGUAGE sql
RETURN (line, number);"

s 1 "SELECT seat('A', 42);"

s 1 "SELECT * FROM seat('A', 42);"

c 'Получаем тот же результат — но имена и типы полей в данном случае получены из выходных параметров функции, а сам составной тип остается анонимным.'

p

c 'И еще один вариант — объявить функцию как возвращающую псевдотип record, который обозначает составной тип «вообще», без уточнения его структуры.'

s 1 'DROP FUNCTION seat(text, integer);'

s 1 "CREATE FUNCTION seat(line text, number integer) RETURNS record
IMMUTABLE LANGUAGE sql
RETURN (line, number);"

s 1 "SELECT seat('A',42);"

c 'Но вызвать такую функцию в предложении FROM уже не получится, поскольку возвращаемый составной тип не просто анонимный, но и количество и типы его полей заранее (на этапе разбора запроса) неизвестны:'

s 1 "SELECT * FROM seat('A',42);"

c 'В этом случае при вызове функции структуру составного типа придется уточнить — мы явно указываем названия и типы столбцов:'

s 1 "SELECT * FROM seat('A',42) AS (line text, number integer);"

c 'При написании функций допустим любой из этих трех вариантов, но лучше сразу подумать об использовании: будет ли удобен анонимный тип и уточнение структуры типа при вызове.'

P 10

###############################################################################
h 'Функции, возвращающие множество строк (табличные функции)'

c 'Напишем функцию, которая вернет все места в прямоугольном зале заданного размера.'

s 1 "CREATE FUNCTION rect_hall(max_line integer, max_number integer)
RETURNS SETOF seats
IMMUTABLE LANGUAGE sql
BEGIN ATOMIC
    SELECT chr(line+64), number
    FROM generate_series(1,max_line) AS line,
         generate_series(1,max_number) AS number;
END;"


c 'Ключевое отличие — слово SETOF. В таком случае функция возвращает не первую строку последнего запроса, как обычно, а все строки последнего запроса.'

s 1 "SELECT * FROM rect_hall(max_line => 2, max_number => 3);"

c 'Вместо SETOF seats можно использовать и SETOF record:'

s 1 'DROP FUNCTION rect_hall(integer, integer);'

s 1 "CREATE FUNCTION rect_hall(max_line integer, max_number integer)
RETURNS SETOF record
IMMUTABLE LANGUAGE sql
BEGIN ATOMIC
    SELECT chr(line+64), number
    FROM generate_series(1,max_line) AS line,
         generate_series(1,max_number) AS number;
END;"

c 'Но в этом случае, как мы видели, при вызове функции придется уточнять структуру составного типа:'

s 1 "SELECT * FROM rect_hall(max_line => 2, max_number => 3)
    AS (a_line text, a_number integer);"

c 'А можно объявить функцию с выходными параметрами. Но SETOF record все равно придется написать, чтобы показать, что функция возвращает не одну строку, а множество:'

s 1 'DROP FUNCTION rect_hall(integer, integer);'

s 1 "CREATE FUNCTION rect_hall(
    max_line integer, max_number integer,
    OUT p_line text, OUT p_number integer
)
RETURNS SETOF record
IMMUTABLE LANGUAGE sql
BEGIN ATOMIC
    SELECT chr(line+64), number
    FROM generate_series(1,max_line) AS line,
         generate_series(1,max_number) AS number;
END;"

s 1 "SELECT * FROM rect_hall(max_line => 2, max_number => 3);"

c 'Еще один равнозначный (и к тому же описанный в стандарте SQL) способ объявить табличную функцию — указать слово TABLE:'

s 1 'DROP FUNCTION rect_hall(integer, integer);'

s 1 "CREATE FUNCTION rect_hall(max_line integer, max_number integer)
RETURNS TABLE(t_line text, t_number integer)
LANGUAGE sql
BEGIN ATOMIC
    SELECT chr(line+64), number
    FROM generate_series(1,max_line) AS line,
         generate_series(1,max_number) AS number;
END;"

# VOLATILE (по умолчанию) тут не спроста, это понадобится чуть ниже. Если кто-то глазастый попадается — хорошо.

s 1 "SELECT * FROM rect_hall(max_line => 2, max_number => 3);"

p

c 'Иногда в запросах бывает полезно пронумеровать строки в том порядке, в котором они получены от функции. Для этого есть специальная конструкция:'

s 1 "SELECT *
FROM rect_hall(max_line => 2, max_number => 3) WITH ORDINALITY;"

c 'При использовании функции в предложении FROM, перед ней неявно подразумевается ключевое слово LATERAL, что позволяет функции обращаться к столбцам таблиц, стоящих в запросе слева от нее. Иногда это позволяет упростить формулировку запросов.'
c 'Например, напишем функцию, конструирующую зал наподобие амфитеатра, в котором дальние ряды имеют больше мест, чем ближние:'

s 1 "CREATE FUNCTION amphitheatre(max_line integer)
RETURNS TABLE(t_line text, t_number integer)
IMMUTABLE LANGUAGE sql
BEGIN ATOMIC
    SELECT chr(line + 64), number
    FROM generate_series(1,max_line) AS line, -- <--+
         generate_series(1, --                      |
                         line ----------------------+
                        ) AS number;
END;"

s 1 "SELECT * FROM amphitheatre(3);"

p

c 'Интересно, что к функции, возвращающей множество строк, можно обратиться и в списке выборки запроса:'

s 1 "SELECT rect_hall(3,4);"

c 'В некоторых случаях это смотрится логично, но иногда результат может удивить. Например, сколько строк вернет такой запрос?'

s 1 "SELECT rect_hall(2,3), rect_hall(2,2);"

c 'Получается 6 строк, а в версиях до 10 получалось наименьшее общее кратное числа строк, возвращенных каждой функцией (12 в данном случае).'

c 'Еще хуже, что запрос может вернуть меньше строк, чем ожидалось, если функция не вернет ни одной строки при каком-то значении параметров.'

c 'Поэтому такой способ вызова не стоит использовать.'

p

###############################################################################
h 'Функции как представления с параметрами'

c 'Как мы видели, функцию можно использовать во фразе FROM как таблицу или представление. Но при этом мы дополнительно получаем возможность использовать параметры, что в ряде случаев бывает удобно.'

c 'Единственная сложность с таким подходом состоит в том, что при обращении к функции (Function Scan) запросы из нее сначала выполняются полностью, и только затем к результату применяются дополнительные условия из запроса.'

s 1 "EXPLAIN (costs off)
SELECT * FROM rect_hall(3,4) WHERE t_line = 'A';"

c 'Если бы функция содержала сложный, долгий запрос, это могло бы стать проблемой.'

c 'В некоторых случаях тело функции может подставляться в вызывающий запрос. Для табличных функций ограничения более мягкие:'
ul 'функция написана на языке SQL;'
ul 'функция сама не должна быть изменчивой (VOLATILE) и не должна содержать вызовов таких функций;'
ul 'функция не должна быть строгой (STRICT);'
ul 'тело должно содержать единственный оператор SELECT (но он может быть сложным);'
ul 'и ряд других ограничений.'

c 'В нашем случае дело в том, что последний раз мы объявили функцию как изменчивую, не указав категорию изменчивости явно.'
# вот и пригодился VOLATILE

s 1 'ALTER FUNCTION rect_hall(integer, integer) IMMUTABLE;'

s 1 "EXPLAIN (costs off)
SELECT * FROM rect_hall(3,4) WHERE t_line = 'A';"

c 'Теперь нет вызова функции как такового, а условие подставлено внутрь запроса, что более эффективно.'

###############################################################################

stop_here
cleanup
demo_end
