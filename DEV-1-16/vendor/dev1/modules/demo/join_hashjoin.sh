#!/bin/bash

. ../lib
init

start_here 12

###############################################################################

h 'Однопроходное соединение хешированием'

c 'При низкой селективности оптимизатор предпочитает соединение хешированием:'

s 1 "EXPLAIN (costs off)
SELECT *
FROM aircrafts a
  JOIN seats s ON a.aircraft_code = s.aircraft_code;"

c 'Узел Hash Join начинает работу с того, что обращается к дочернему узлу Hash. Тот получает от своего дочернего узла (здесь — Seq Scan) весь набор строк и строит хеш-таблицу.'
c 'Затем Hash Join обращается ко второму дочернему узлу и соединяет строки, постепенно возвращая полученные результаты.'

p

c 'Проверим, как выполняется этот запрос:'

s 1 "EXPLAIN (analyze, costs off, timing off, summary off)
SELECT *
FROM aircrafts a
  JOIN seats s ON a.aircraft_code = s.aircraft_code;"

c 'Хеш-таблица поместилась в память (Batches: 1). Параметр Buckets показывает число корзин в хеш-таблице, а Memory Usage — объем использованной оперативной памяти.'
c 'Обратите внимание, что хеш-таблица строилась по меньшему набору строк.'

p

c 'Модификации Hash Join включают уже рассмотренные ранее Left, Semi и Anti, а также Right для правого и Full для полного соединений:'

s 1 "EXPLAIN (costs off)
SELECT * 
FROM aircrafts a
  FULL JOIN seats s ON a.aircraft_code = s.aircraft_code;"

s 1 "EXPLAIN (costs off)
SELECT * 
FROM seats s
  RIGHT JOIN aircrafts a ON a.aircraft_code = s.aircraft_code;"

c 'Обратите внимание, что независимо от того, в каком порядке перечислены таблицы в соединении, хеш-таблица строится по меньшему набору.'

P 19

###############################################################################

h 'Двухпроходное соединение хешированием'

c 'Возьмем теперь большие таблицы и выведем статистику использования буферного кеша:'

s 1 "EXPLAIN (analyze, buffers, costs off, timing off, summary off)
SELECT *
FROM bookings b
  JOIN tickets t ON b.book_ref = t.book_ref;"

c 'Теперь хеш-таблица не поместилась в память и используется двухпроходное соединение. Потребовалось 32 пакета (Batches).'
c 'Видно, что узел Hash записывает пакеты во временные файлы (temp written), а узел Hash Join и записывает, и читает (temp read и written).'

c 'Сравним с таким же запросом, который выводит только одно поле:'

s 1 "EXPLAIN (analyze, costs off, timing off, summary off)
SELECT b.book_ref
FROM bookings b
  JOIN tickets t ON b.book_ref = t.book_ref;"

c 'Расход памяти уменьшился, так как в хеш-таблице теперь только одно поле (вместо трех), и количество пакетов уменьшилось вдвое.'

P 21

###############################################################################

h 'Стоимость хеш-соединения'

s 1 "EXPLAIN SELECT *
FROM tickets t
  JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no;"

c 'Начальная стоимость узла Hash Join складывается из стоимостей:'
ul 'получения всего первого набора данных (здесь — билеты);'
ul 'построения хеш-таблицы — пока таблица не готова, соединение не может начаться.'

c 'Можно обратить внимание на то, что в узле Hash стоимость построения хеш-таблицы не отражена.'

p

c 'Полная стоимость добавляет к начальной следующие стоимости:'
ul 'получения всего второго набора данных (здесь — перелеты);'
ul 'проверки по хеш-таблице;'
ul 'обращения к диску в случае, когда предполагается использование более одного пакета.'

c 'Главный вывод: стоимость хеш-соединения пропорциональна N + M, где N и M — число строк в соединяемых наборах данных. При больших N и M это значительно выгоднее, чем произведение в случае соединения вложенным циклом.'

P 26

###############################################################################

h 'Однопроходное параллельное хеш-соединение'

c 'Увеличим объем памяти, выделяемый процессу для построения хеш-таблицы:'

s 1 "SET work_mem = '32MB';"

c 'Выполним запрос с агрегацией:'

s 1 "EXPLAIN (analyze, costs off, timing off, summary off)
SELECT count(*)
FROM bookings b
  JOIN tickets t ON b.book_ref = t.book_ref;"

c 'Обратите внимание на использование памяти (Memory Usage): объем превышает ограничение, установленное для одного рабочего процесса (64MB = work_mem × hash_mem_multiplier), но в общую память трех процессов хеш-таблица помещается. Поэтому выполняется однопроходное соединение (Batches: 1).'

P 31

###############################################################################

h 'Двухпроходное параллельное хеш-соединение'

c 'Теперь уменьшим объем памяти:'

s 1 "SET work_mem = '16MB';"

c 'Выполним тот же запрос с агрегацией:'

s 1 "EXPLAIN (analyze, costs off, timing off, summary off)
SELECT count(*)
FROM bookings b
  JOIN tickets t ON b.book_ref = t.book_ref;"

c 'Соединение стало двухпроходным с четырьмя пакетами.'

###############################################################################
stop_here
cleanup
demo_end
