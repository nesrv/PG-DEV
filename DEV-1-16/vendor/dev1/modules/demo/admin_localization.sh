#!/bin/bash

. ../lib

init

start_here 6

###############################################################################

h 'Локали и категории'

c 'В операционной системе сервера должны быть установлены локали с поддержкой русского языка:'

e "locale -a | grep ru"
 
c 'Параметры локализации сеанса ОС определяются переменными окружения:'

e locale

c 'Помимо переменных, соответствующих категориям локали, здесь также присутствуют переменные, имеющие особое значение:'
ul 'LC_ALL — если установлена, то используется для всех категорий локали, даже если они заданы;'
ul 'LANG — используется для тех категорий локали, для которых значение не задано;'
ul 'LANGUAGE — если установлена, то используется вместо LC_MESSAGES (об этом далее).'

p

c 'При установке PostgreSQL из пакета в виртуальной машине курса для инициализации кластера main были использованы параметры сеанса ОС. Если нужно задать другие значения, можно использовать ключ --locale (эквивалентен LANG), а также ключи для каждой категории, например так:'

e_fake_p "sudo pg_createcluster 16 new_cluster -- --locale-provider=icu --locale=ru_RU.UTF-8 --lc-messages=en_US.UTF-8"

c 'Четыре параметра PostgreSQL соответствуют одноименным категориям локали. Видно, что их меньше чем в ОС:'

s 1 "SELECT name, setting, context, sourcefile
FROM pg_settings
WHERE name LIKE 'lc%';"

c 'Значения этих параметров записываются в конфигурационный файл. При этом параметры lc_monetary, lc_numeric и lc_time может изменить любой пользователь (context=user), а lc_messages — только суперпользователь. Для категорий локали LC_COLLATE и LC_CTYPE соответствующих серверных параметров нет.'

p

c 'Каждый обслуживающий процесс при запуске сбрасывает значение LC_ALL и устанавливает переменные окружения ОС для категорий локали в соответствии с конфигурационными параметрами "lc%".'

c 'При изменении параметра по ходу сеанса обслуживающий процесс устанавливает это же значение для соответствующей переменной окружения.'

c 'Стандартные базы postgres, template0 и template1 используют значения LC_COLLATE, LC_CTYPE a также провайдера локали, установленные при инициализации кластера. Новые базы данных по умолчанию копируют параметры используемого шаблона:'

s 1 "CREATE DATABASE ${TOPIC_DB}_utf8;"
s 1 "\x \list ${TOPIC_DB}_utf8|template1 \x"

###############################################################################
p
h 'Даты и LC_TIME'

c 'Параметр конфигурации, отвечающий за соответствующую категорию локали:'

s 1 "SET lc_time = 'ru_RU.UTF8';"

c 'Для использования названий месяцев и дней недели на русском языке в форматной маске функции to_char используется префикс TM:'

s 1 "SELECT to_char(current_date, 'TMDay, DD TMmonth YYYY');"

c 'То же самое для американского английского:'

s 1 "SET lc_time = 'en_US.UTF8';"
s 1 "SELECT to_char(current_date, 'TMDay, DD TMMonth YYYY');"

c 'Функции to_date/to_char позволяют в явном виде указать формат даты и времени при вводе/выводе значений. На неявное преобразование даты в текст и наоборот влияет параметр datestyle. Вот несколько примеров:'

s 1 "SET datestyle = 'Postgres'; SELECT current_setting('datestyle') AS datestyle, now();"
s 1 "SET datestyle = 'SQL, DMY'; SELECT current_setting('datestyle') AS datestyle, now();"
s 1 "SET datestyle = 'SQL, MDY'; SELECT current_setting('datestyle') AS datestyle, now();"
s 1 "RESET datestyle; SELECT current_setting('datestyle') AS datestyle, now();"

p

###############################################################################
h 'Числа и LC_NUMERIC'

c 'Параметр конфигурации, отвечающий за соответствующую категорию локали:'

s 1 "SET lc_numeric = 'ru_RU.UTF8';"

c 'Разделители групп разрядов (G), а также целой и дробной части (D), принятые в России:'

s 1 "SELECT to_char('12345'::numeric, '999G999D00');"

c 'То же для США:'

s 1 "SET lc_numeric = 'en_US.UTF8';"
s 1 "SELECT to_char('12345'::numeric, '999G999D00');"

p

###############################################################################
h 'Денежные единицы и LC_MONETARY'

c 'Параметр конфигурации, отвечающий за соответствующую категорию локали:'

s 1 "SET lc_monetary = 'ru_RU.UTF8';"

c 'Денежный тип данных money добавляет к сумме код валюты:'

s 1 "SELECT '12345'::money;"

c "Но нужно учитывать, что в таблице с таким типом можно хранить только одну валюту, и та будет меняться вместе с LC_MONETARY:"

s 1 "SET lc_monetary = 'en_US.UTF8';"
s 1 "SELECT '12345'::money;"

P 9
###############################################################################
h 'Работа клиента и сервера в разных кодировках'

c 'Создадим базу данных с кодировкой KOI8R, а клиент по-прежнему будет использовать UTF8. В качестве провайдера локалей укажем ICU. Чтобы база данных успешно создалась, нужно учесть следующее:'
ul 'в ОС должна быть установлена локаль с нужной кодировкой символов;'
ul 'нужно использовать шаблон template0: это пустая БД, индексы в которой гарантированно не пострадают в результате изменения кодировки.'

c 'Значения LC_COLLATE и LC_CTYPE, как правило, должны быть согласованы, поэтому обычно их устанавливают вместе одним параметром LOCALE:'

s 1 "CREATE DATABASE ${TOPIC_DB}_koi8r
  LOCALE_PROVIDER = 'icu'
  ENCODING = 'koi8r'
  ICU_LOCALE = 'ru-RU' LC_CTYPE='ru_RU.koi8r' LC_COLLATE='ru_RU.koi8r'
  TEMPLATE = template0;"

s 1 "\x \l ${TOPIC_DB}_koi8r \x"

c "Подключимся к ${TOPIC_DB}_koi8r и убедимся, что работает перекодировка символов."

s 1 "\c ${TOPIC_DB}_koi8r"

c 'Кодировки клиента и сервера:'

s 1 "SELECT name, setting, context
FROM pg_settings
WHERE name LIKE '%encoding';"

#####
c 'Значение параметра client_encoding устанавливает клиент, в данном случае psql. В интерактивном режиме значение устанавливается по кодировке клиента (переменной LC_CTYPE в ОС). Но при запуске из скрипта, как сейчас в демонстрации, параметр устанавливается в значение кодировки базы данных.'

c 'Явно зададим такое же значение, как и у клиентской локали:'

s 1 '\! locale | grep LC_CTYPE'
s 1 "SET client_encoding = 'UTF-8';"
#####

c 'Теперь символы будут правильно конвертироваться из UTF8 в KOI8R и обратно:'

s 1 "CREATE TABLE tab AS SELECT 'Привет, мир!'::text AS col;"
s 1 "SELECT * FROM tab;"

c 'Список доступных перекодировок для koi8:'

s 1 "\dcS *koi8*"
s 1 "\c ${TOPIC_DB}_utf8"

###############################################################################
P 12
h 'Сообщения сервера и клиента'

c 'Сообщения сервера можно выводить на разных языках. Предварительно нужно убедиться, что PostgreSQL собран с поддержкой национальных языков:'

s 1 "SELECT unnest(regexp_match(setting,'--enable-nls')) config
FROM pg_config()
WHERE name = 'CONFIGURE';"

c 'Список доступных языков и файлы сообщений здесь:'

s 1 "SELECT setting
FROM pg_config()
WHERE name = 'LOCALEDIR';"

export LOCALEDIR=$(s_bare 1 "SELECT setting FROM pg_config() WHERE name = 'LOCALEDIR';")
e "ls -C $LOCALEDIR"

c 'Для записи в журнал будем использовать ошибочную команду:'

s 1 "select1;"
e "tail -n 2 $LOG_A"

c 'В журнал сервера записывается такое же сообщение об ошибке и сама ошибочная команда.'

p

c 'Для вывода сообщений на русском языке надо изменить параметр lc_messages.'

s 1 "SET lc_messages TO 'ru_RU.UTF8';"
s 1 "select1;"
e "tail -n 2 $LOG_A"

c 'Теперь сообщение выводится клиенту и в журнал на русском языке.'

p

c 'Посмотрим на сообщения, которые выводит клиент psql. Они остались на английском языке:'

s 1 "\dt"

c 'Язык сообщений клиента, собранного с поддержкой национальных языков, определяется переменными ОС LC_MESSAGES и LANGUAGE, причем LANGUAGE имеет приоритет:'

s 1 '\! echo $LC_MESSAGES'
s 1 '\! echo $LANGUAGE'

c 'Для полной русификации установим русский язык и для сообщений psql.'

psql_close 1

# Нужно установить значение переменной для использования в последующих командах,
# но команда eu выполняется в своем собственном окружении.
# Решение некрасивое, но как сделать лучше непонятно...
# Первая команда устанавливает переменную для последующего использования,
# а вторая нужна лишь для вывода в html.
export LANGUAGE=ru_RU
e_fake "export LANGUAGE=ru_RU"

psql_open A 1 -d ${TOPIC_DB}_utf8

s 1 "\dt"

s 1 "SET lc_messages TO 'ru_RU.UTF8';"

c 'Теперь все сообщения выводятся на русском языке.'

###############################################################################
P 16
h 'Правила сортировки'

c 'При инициализации кластера в системном каталоге каждой базы данных создаются специальные объекты — правила сортировки. Они создаются на основе информации об установленных в ОС локалях.'
c 'Начальное наполнение базы правилами сортировки:'

s 1 "SELECT CASE collprovider
    WHEN 'd' THEN 'default'
    WHEN 'c' THEN 'libc'
    WHEN 'i' then 'icu'
  END,
  count(*)
FROM pg_collation
GROUP BY collprovider;"

c 'Правила сортировки для русского языка, полученные из ОС:'

s 1 "\dOS+ ru*"

c 'Обратите внимание, что отображаются только правила сортировки, применимые к кодировке текущей базы данных, поэтому для разных баз одного экземпляра PostgreSQL результат команды может отличаться.'

c 'Правила сортировки для провайдера ICU создаются только в том случае, если сервер собран с параметром --with-icu.'\
' Для таких правил сортировки формируются имена, включающие метку языка и указание суффикса «-x-icu» для отличия от локалей libc.'

s 1 "SELECT unnest(regexp_match(setting,'--with-icu')) config
FROM pg_config()
WHERE name = 'CONFIGURE';"

###############################################################################
p
h 'Правила сортировки ICU'

c 'Сортировка для правила ru-x-icu отличается от используемой по умолчанию сортировки для правила ru_RU. Кириллица идет раньше латиницы:'

s 1 "WITH t(c) AS (
  VALUES('а'),('б'),('в'),('a'),('b'),('c'),('1'),('2'),('3')
) 
SELECT string_agg(t.c,',' ORDER BY t.c) AS \"default\",
       string_agg(t.c,',' ORDER BY t.c COLLATE \"ru-x-icu\") AS \"ru-x-icu\"
FROM t \gx"

c 'Ключевое слово COLLATE после выражения (в ORDER BY) явно задает правило сортировки. По умолчанию используется правило с именем default, соответствующее параметрам локали базы данных.'

p

c 'Возможности библиотеки ICU позволяют по-разному настраивать сортировку отдельных групп символов путём определения новых правил с параметрами, заданными в виде части языковой метки'

c 'Создадим новое правило сортировки, где латинские символы идут раньше символов кириллицы:'

s 1 "CREATE COLLATION latn_cyrl 
    (provider = icu, locale = 'ru-RU-u-kr-latn-cyrl');"

c 'Еще одно, где в дополнение к предыдущему буквы идут раньше цифр:'

s 1 "CREATE COLLATION latn_cyrl_digit 
    (provider = icu, locale = 'ru-RU-u-kr-latn-cyrl-digit');"

c 'Проверяем сортировку:'

s 1 "WITH t(c) AS (
  VALUES('а'),('б'),('в'),('a'),('b'),('c'),('1'),('2'),('3')
) 
SELECT string_agg(t.c,',' ORDER BY t.c) AS \"default\",
       string_agg(t.c,',' ORDER BY t.c COLLATE \"ru-x-icu\") AS \"ru-x-icu\",
       string_agg(t.c,',' ORDER BY t.c COLLATE \"latn_cyrl\") AS \"latn_cyrl\",
       string_agg(t.c,',' ORDER BY t.c COLLATE \"latn_cyrl_digit\") AS \"latn_cyrl_digit\"
FROM t \gx"

c 'Если вышеуказанных параметров правил сортировки недостаточно, порядок элементов можно изменить с помощью особых правил сортировки:'

s 1 "CREATE COLLATION colors (
     provider = icu, locale = 'ru', rules = '& К < О < Ж < З < Г < С < Ф'
   );"

s 1 "WITH colors(name) AS (
     VALUES ('Каждый'), ('Фазан'), ('Знать'), ('Желает'), ('Где'), ('Охотник'), ('Сидит') 
   )
   SELECT * FROM colors ORDER BY name COLLATE colors;"

c 'И еще один пример. Обратите внимание на синтаксис правила:'

s 1 "CREATE COLLATION verdicts (
     provider = icu, locale = 'ru', rules = \$\$ & 'к' < 'н' < ',' < 'п' \$\$
   );"

s 1 "SELECT string_agg(w, ' ' ORDER BY w COLLATE verdicts) FROM 
     (VALUES ('казнить'), (','), ('нельзя'), ('помиловать')) AS v(w);"


###############################################################################
P 18
h 'Недетерминированные правила сортировки'

c 'Определим недетерминированное правило для регистронезависимой сортировки:'

s 1 "CREATE COLLATION ignore_case
  (provider = icu, locale = 'und-u-ks-level2', deterministic = false);"

c 'Теперь строки в разных регистрах могут быть равными:'

s 1 "SELECT
	'postgres' = 'POSTGRES' AS \"default\",
	'postgres' = 'POSTGRES' COLLATE \"ignore_case\" AS \"ignore_case\"
;"

c 'Но поиск по шаблону для недетерминированного правила невозможен:'

s 1 "SELECT 'PostgreSQL' LIKE 'post%' COLLATE \"ignore_case\";"

###############################################################################
P 20
h 'Изменения в библиотеках-провайдерах'

c 'При создании правила сортировки в системном каталоге сохраняется версия библиотеки, переданная операционной системой. Если в ОС изменится версия библиотеки, каждый раз при использовании правила будет выдаваться предупреждение о том, что версии не совпадают.'

c 'Проверить соответствие версий можно запросом:'

s 1 "SELECT c.collname,
  c.collversion AS version,
  pg_collation_actual_version(c.oid) AS actual_version,
  c.collprovider
FROM pg_collation c
WHERE c.collname LIKE 'ru%';"

c 'Изменение правила сортировки может привести к некорректной работе индексов. Если подобное произошло, рекомендуется пересоздать индексы с новой версией правила сортировки. После этого можно обновить версию в системном каталоге командой ALTER COLLATION ... REFRESH VERSION и предупреждения перестанут выдаваться.'

c 'Запрос для получения списка объектов, которые зависят от требующих обновления правил сортировки:'

s 1 "SELECT pg_describe_object(refclassid, refobjid, refobjsubid) AS \"Collation\",
  pg_describe_object(classid, objid, objsubid) AS \"Object\"
FROM pg_depend d
  JOIN pg_collation c ON refclassid = 'pg_collation'::regclass AND refobjid = c.oid
WHERE c.collversion <> pg_collation_actual_version(c.oid)
ORDER BY 1, 2;"

c 'Такая же проверка выполняется и для правил сортировки на уровне баз данных. Функция pg_database_collation_actual_version показывает актуальную версию правила сортировки в операционной системе:'

s 1 "SELECT d.datname,
  d.datcollversion AS version,
  pg_database_collation_actual_version(d.oid) AS actual_version,
  datlocprovider
FROM pg_database d;"

c 'А команда ALTER DATABASE ... REFRESH COLLATION VERSION обновляет хранимую в pg_database версию в соответствии с версией в операционной системе.'

###############################################################################

stop_here
cleanup
demo_end
