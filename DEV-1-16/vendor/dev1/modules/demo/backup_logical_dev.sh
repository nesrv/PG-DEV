#!/bin/bash

. ../lib

init

# HOME for OSUSER
export H=`cat /etc/passwd | awk -F ':' '/^'$OSUSER':/ {print $6}'`

rm -rf $H/${TOPIC_DB}_1.directory

start_here 7

###############################################################################
h 'Команда COPY'

c 'Создадим базу данных и таблицу.'

s 1 "CREATE DATABASE ${TOPIC_DB}_1;"
s 1 "\c ${TOPIC_DB}_1"
s 1 'CREATE TABLE t(
    id integer PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    s text
);'
s 1 "INSERT INTO t(s) VALUES ('Привет, мир!'), (''), (NULL);"

c 'Вот что показывает команда COPY (выдаем на консоль, а не в файл):'

s 1 'COPY t TO stdout;'

c 'Видно, как различаются в выводе пустые строки и неопределенные значения.'

p

c 'Формат вывода настраивается достаточно гибко. Можно изменить разделитель, представление неопределенных значений, добавить строку с названиями столбцов и т.п. Например:'

s 1 "COPY t TO stdout WITH (NULL '<NULL>', DELIMITER ',', HEADER);"

c 'Обратите внимание, что символ-разделитель внутри строки был экранирован (символ для экранирования тоже настраивается).'

c 'Вместо таблицы можно указать произвольный запрос.'

s 1 'COPY (SELECT * FROM t WHERE s IS NOT NULL) TO stdout;'

c 'Таким образом можно сохранить результат запроса, данные представления и т. п.'

c 'Команда может работать и с форматом CSV, который поддерживается множеством программ.'

s 1 "COPY t TO stdout WITH (FORMAT csv);"

p

c 'Аналогично работает и ввод данных из файла или с консоли.'
c 'При вводе с консоли требуется маркер конца файла — обратная косая черта с точкой. В обычном файле он не нужен.'
c 'Все параметры при вводе должны совпадать с теми, что были указаны при выводе.'

s 1 'TRUNCATE TABLE t;'
s 1 'COPY t FROM stdin;
1	Привет, мир!
2	
3	\N
\.'


c 'Если вводимые данные предваряются строкой-заголовком с именами столбцов, то возможно выполнение проверки на их соответствие столбцам принимающей таблицы.'

s 1 'COPY t FROM stdin (HEADER MATCH);
id	s
4	Строка четыре
\.'

c 'При несовпадении получим ошибку:'

s 1 'COPY t FROM stdin (HEADER MATCH);
Col_1	Col_2
5	Строка пять
\.'

c 'Еще одна попытка добавить строку в таблицу:'

s 1 "INSERT INTO t (s) VALUES ('Строка пять');"

c 'Эта ошибка возникла из-за того, что успешно выполненная выше команда COPY не передвинула значение последовательности, обслуживающей столбец id. Исправим ситуацию:'

s 1 "SELECT pg_catalog.setval('t_id_seq', 4, true);"

s 1 "INSERT INTO t (s) VALUES ('Строка пять');"

c 'Вот что загрузилось в таблицу (для наглядности настроим в psql вывод неопределенных значений):'

s 1 "\pset null '\\\\N'"
s 1 'SELECT * FROM t;'

P 12

###############################################################################
h 'Утилита pg_dump'

c 'При запуске без дополнительных параметров утилита pg_dump выдает команды SQL, создающие все объекты в базе данных:'

e "pg_dump -d ${TOPIC_DB}_1" pgsql

c 'Видно, что pg_dump создал таблицу t, добавил автоматическую генерацию идентификатора, заполнил таблицу с помощью уже рассмотренной нами команды COPY, и наконец добавил ограничение целостности для первичного ключа. Ключ --column-inserts позволяет использовать команды INSERT, но загрузка будет работать существенно дольше.'

p

c 'Рассмотрим некоторые полезные ключи.'

c 'Могут пригодиться при восстановлении копии на системе с другим набором ролей:'
ul '-O, --no-owner    — не генерировать команды для установки владельца объектов;'
ul '-x, --no-acl      — не генерировать команды для установки привилегий.'

c 'Полезны для выгрузки и загрузки данных частями:'
ul '-s, --schema-only — выгрузить только определения объектов без данных;'
ul '-a, --data-only   — выгрузить только данные, без создания объектов.'

c 'Удобны, если восстанавливать копию на системе, в которой уже есть данные (и наоборот, на чистой системе):'
ul '-c, --clean       — генерировать команды DROP для создаваемых объектов;'
ul '-C, --create      — генерировать команды создания БД и подключения к ней.'

p

c 'Важный момент: в выгрузку попадают и изменения, сделанные в шаблонной БД template1. Поэтому восстанавливать резервную копию лучше на базе данных, созданной из template0. При использовании ключа --create это учитывается автоматически:'

e "pg_dump --create -d ${TOPIC_DB}_1 | grep 'CREATE DATABASE'" pgsql

c 'Команда для создания схемы public не формируется, но если права на схему или ее владелец были изменены, то соответствующие команды появятся в выводе pg_dump:'

s 1 'ALTER SCHEMA public OWNER TO student;'

e "pg_dump --create -d ${TOPIC_DB}_1 | grep 'SCHEMA'" pgsql

p

c 'Существуют ключи для выбора объектов, которые должны попасть в резервную копию:'

ul '-n, --schema — шаблон для имен схем;'
ul '-t, --table  — шаблон для имен таблиц.'

c 'И наоборот, включить в копию все, кроме указанного:'
ul '-N, --exclude-schema — шаблон для имен схем;'
ul '-T, --exclude-table  — шаблон для имен таблиц.'

c 'Например, восстановим таблицу t в другой базе данных.'

s 1 "CREATE DATABASE ${TOPIC_DB}_2;"

e "pg_dump --table=t -d ${TOPIC_DB}_1 | psql -d ${TOPIC_DB}_2"

c "Подключимся к базе данных ${TOPIC_DB}_2 и проверим:"

s 1 "\c ${TOPIC_DB}_2"
s 1 'SELECT * FROM t;'

p

###############################################################################
h 'Утилита pg_dump — формат custom'

c 'Серьезное ограничение обычного формата (plain) состоит в том, что выбирать объекты нужно в момент выгрузки. Формат custom позволяет сначала сделать полную копию, а выбирать объекты уже при загрузке.'

e "pg_dump --format=custom -d ${TOPIC_DB}_1 -f $H/${TOPIC_DB}_1.custom"

c 'Для восстановления объектов из такой копии предназначена утилита pg_restore. Повторим восстановление таблицы t.'

s 1 'DROP TABLE t;'

c 'Формат резервной копии указывать не обязательно — утилита распознает его сама.'
c 'Утилита pg_restore понимает те же ключи для фильтрации объектов, что и pg_dump, и даже больше:'
ul '-I, --index    — загрузить определенные индексы;'
ul '-P, --function — загрузить определенные функции;'
ul '-T, --trigger  — загрузить определенные триггеры.'

e "pg_restore --table=t -d ${TOPIC_DB}_2 $H/${TOPIC_DB}_1.custom"

s 1 'SELECT * FROM t;'

c "Еще один пример: восстановим целиком исходную базу данных ${TOPIC_DB}_1."

s 1 "DROP DATABASE ${TOPIC_DB}_1;"

c 'В ключе -d мы указываем любую существующую базу данных; с ключом --create утилита сама создаст базу, указанную в архиве, и тут же переключится в нее.'

e "pg_restore --create -d student $H/${TOPIC_DB}_1.custom"

c 'Проверим:'

s 1 "\c ${TOPIC_DB}_1"
s 1 'SELECT * FROM t;'

p

c 'Резервную копию в обычном (plain) формате при необходимости можно изменить в текстовом редакторе. Резервная копия формата custom хранится в двоичном виде, но и для нее доступны более широкие возможности фильтрации объектов, чем рассмотренные ключи. Утилита pg_restore может сформировать список объектов — оглавление резервной копии:'

e "pg_restore --list $H/${TOPIC_DB}_1.custom"

c 'Такой список можно записать в файл, отредактировать и использовать его для восстановления с помощью ключа --use-list.'

p

###############################################################################
h 'Утилита pg_dump — формат directory'

c 'Формат directory интересен тем, что позволяет выгружать данные в несколько параллельных потоков. При этом гарантируется согласованность данных: все потоки будут использовать один и тот же снимок данных.'

e "pg_dump --format=directory --jobs=2 -d ${TOPIC_DB}_1 -f $H/${TOPIC_DB}_1.directory"

c 'Заглянем внутрь каталога:'

e "ls -l $H/${TOPIC_DB}_1.directory"

c 'В нем находится файл оглавления и по одному файлу на каждый выгружаемый объект (у нас он всего один):'

export GZ=`ls $H/${TOPIC_DB}_1.directory/*.gz`
e "zcat $GZ"

c "Восстановим базу ${TOPIC_DB}_1 из резервной копии, используя два потока."
c "Здесь мы добавляем ключ --clean, который генерирует команду удаления БД, поскольку ${TOPIC_DB}_1 существует. И предварительно надо отключиться от ${TOPIC_DB}_1:"

s 1 "\c ${TOPIC_DB}_2"
e "pg_restore --clean --create --jobs=2 -d student $H/${TOPIC_DB}_1.directory"

P 14

###############################################################################
h 'Утилита pg_dumpall'

c 'Утилита pg_dump годится для выгрузки одной базы данных, но никогда не выгружает общие объекты кластера БД, такие, как роли и табличные пространства. Чтобы сделать полную копию кластера, нужна утилита pg_dumpall.'

c 'Все рассматриваемые в этой теме утилиты не требуют каких-то отдельных привилегий, но у выполняющей их роли должны быть привилегии на чтение (создание) всех затронутых объектов. Утилитой pg_dump может, например, пользоваться владелец базы данных. Но поскольку для копирования кластера утилите pg_dumpall надо иметь доступ ко всем базам данных, будем использовать роль с атрибутом суперпользователя.'

e "pg_dumpall --clean -f $H/main.sql"

c 'В копию кластера дополнительно попадают такие команды, как:'

e "grep 'ROLE' $H/main.sql" pgsql

c 'Восстановление выполняется с помощью psql — никакой другой формат не поддерживается. Команда для восстановления (мы не будем ее выполнять):'

e_fake "psql -f main.sql"

c 'В процессе восстановления могут возникать ошибки из-за существующих объектов — обычно это нормально и не мешает процессу, хотя все сообщения стоит проанализировать.'

###############################################################################

stop_here

rm -rf $H/${TOPIC_DB}_1.directory

cleanup
demo_end
