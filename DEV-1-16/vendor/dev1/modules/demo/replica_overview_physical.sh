#!/bin/bash

. ../lib

init

start_here 7

###############################################################################
h 'Настройка физической репликации'

c 'Посмотрим, как организовать потоковую репликацию между двумя серверами. Мы ограничимся самым простым вариантом; детально репликация рассматривается в курсе для администраторов DBA3.'

c 'Минимальный набор параметров, которые нужно проверить:'

s 1 "SELECT name, setting FROM pg_settings
WHERE name in ('wal_level','max_wal_senders');"

c 'Начиная с версии PostgreSQL 10, параметры по умолчанию уже имеют подходящие значения.'

c 'Разрешение на подключение по протоколу репликации в pg_hba.conf:'

s 1 "SELECT type, user_name, address, auth_method FROM pg_hba_file_rules
WHERE 'replication' = ANY(database);"

c 'Разрешение тоже имеется.'
p

c "Развернем реплику из физической резервной копии, для этого используем утилиту pg_basebackup."

backup_dir=~student/tmp/backup  # очистка каталога - в init

c 'Целевой каталог копии должен быть пустым или отсутствовать:'
e_fake "rm -rf $backup_dir"

c 'Ключ --checkpoint=fast просит утилиту выполнить контрольную точку как можно быстрее (без пауз), а ключ -R — добавить настройки для реплики:'

e "pg_basebackup --pgdata=$backup_dir -R --checkpoint=fast"

c 'Утилита создала заготовку конфигурационного файла...'

e "cat $backup_dir/postgresql.auto.conf" conf

c '... и сигнальный файл, который даст реплике указание перейти в режим постоянного восстановления:'

e "ls -l $backup_dir/*.signal"

c 'Кластер, в котором мы собираемся развернуть реплику, уже предварительно инициализирован. Если сервер работает, его необходимо остановить:'

pgctl_stop R

c "Копия была размещена в домашнем каталоге пользователя $OSUSER, а теперь переносим ее в каталог данных кластера и делаем владельцем файлов пользователя postgres:"

e "sudo rm -rf $PGDATA_R"
e "sudo mv $backup_dir $PGDATA_R"
e "sudo chown -R postgres: $PGDATA_R"

c 'Можно запускать сервер:'

pgctl_start R

c 'Посмотрим на процессы реплики.'
e "sudo head -n 1 '${PGDATA_R}/postmaster.pid'"
PM_PID=$(sudo head -n 1 "${PGDATA_R}/postmaster.pid")
e "ps -o pid,command --ppid ${PM_PID}"

c 'Процесс walreceiver принимает поток журнальных записей, а процесс startup применяет изменения.'

c 'Сравним с процессами мастера.'
e "sudo head -n 1 '${PGDATA_A}/postmaster.pid'"
PM_PID=$(sudo head -n 1 "${PGDATA_A}/postmaster.pid")
e "ps -o pid,command --ppid ${PM_PID}"

c 'Процесс walsender отправляет реплике журнальные записи.'

c 'Состояние репликации можно смотреть в специальном представлении на мастере:'

s 1 'SELECT * FROM pg_stat_replication \gx'

ul 'значения *_lsn — показывают, какие журнальные записи отправлены на реплику, получены ею, записаны на диск и применены;'
ul 'sync_state — синхронная или асинхронная репликация (об этом подробнее позже).'

###############################################################################
P 9
h 'Использование реплики'

c 'Выполним несколько команд на основном сервере:'

s 1 "CREATE DATABASE $TOPIC_DB;"
s 1 "\c $TOPIC_DB"
s 1 'CREATE TABLE test(id integer PRIMARY KEY, descr text);'
sleep 1

c 'Проверим реплику:'

psql_open R 2 -d $TOPIC_DB

s 2 'SELECT * FROM test;'

c 'Вставим строку в таблицу на основном сервере:'
s 1 "INSERT INTO test VALUES (1, 'Раз');"
sleep 1

s 2 'SELECT * FROM test;'

c 'Итак, репликация работает и запросы на реплике выполняются. При этом изменения на реплике не допускаются:'

s 2 "INSERT INTO test VALUES (2, 'Два');"

###############################################################################
P 16
h 'Переключение на реплику'

c 'Чтобы перевести реплику из режима восстановления в обычный режим, нужно дать ей соответствующую команду'

s 2 "SELECT pg_is_in_recovery();  -- является репликой?"

pgctl_promote R

c 'Начиная с версии 12 это же можно сделать, используя SQL-функцию pg_promote.'

s 2 "SELECT pg_is_in_recovery();  -- снова проверим: это реплика?"

c 'Таким образом мы получили два самостоятельных, никак не связанных друг с другом сервера.'

s 2 "INSERT INTO test VALUES (2, 'Два');"

c 'Очень важно иметь гарантии того, что приложение работает только с одним из серверов, иначе возникает ситуация, называемая split brain: часть данных оказывается на одном сервере, часть — на другом, и собрать их воедино практически невозможно.'

###############################################################################

stop_here
cleanup
demo_end
