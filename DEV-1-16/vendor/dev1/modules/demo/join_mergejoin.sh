#!/bin/bash

. ../lib
init

start_here 13

###############################################################################

h 'Соединение слиянием'

c 'Если результат необходим в отсортированном виде, оптимизатор может предпочесть соединение слиянием. Особенно, если данные от дочерних узлов можно получить уже отсортированными — как в этом примере:'

s 1 "EXPLAIN (costs off) SELECT *
FROM tickets t
  JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no
ORDER BY t.ticket_no;"

p

c 'Вот еще один пример с двумя соединениями слиянием, в котором один узел Merge Join получает отсортированный набор от другого узла Merge Join:'

s 1 "EXPLAIN (costs off) SELECT t.ticket_no, bp.flight_id, bp.seat_no
FROM tickets t
  JOIN ticket_flights tf ON t.ticket_no = tf.ticket_no 
  JOIN boarding_passes bp ON bp.ticket_no = tf.ticket_no 
   AND bp.flight_id = tf.flight_id 
ORDER BY t.ticket_no;"

c 'Здесь соединяются перелеты (ticket_flights) и посадочные талоны (boarding_passes), и с этим, уже отсортированным по номерам билетов, набором строк соединяются билеты (tickets).'

p

c 'Для Merge Join также существуют модификации Left, Right, Semi, Anti и Full.'

c 'В настоящее время соединение слиянием поддерживает только эквисоединения, соединения по операциям «больше» или «меньше» не реализованы.'

c 'Таким образом, модификация Full существует только для соединений хешированием и слиянием, и оба варианта работают только с условием равенства. Если пренебречь производительностью, полное соединение можно получить, объединив результаты левого соединения и антисоединения — таким вариантом придется воспользоваться, если потребуется полное соединение по иному условию.'

P 15

###############################################################################

h 'Вычислительная сложность'

c 'Посмотрим на стоимость соединения слиянием:'

s 1 "EXPLAIN SELECT *
FROM tickets t
  JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no
ORDER BY t.ticket_no;"

c 'Начальная стоимость включает:'
ul 'сумму начальных стоимостей дочерних узлов (включает стоимость сортировки, если она необходима);'
ul 'стоимость получения первой пары строк, соответствующих друг другу.'

p

c 'Полная стоимость добавляет к начальной:'
ul 'сумму стоимостей получения обоих наборов данных;'
ul 'стоимость сравнения строк.'

c 'Общий вывод: стоимость соединения слиянием пропорциональна N + M (где N и M — число соединяемых строк), если не требуется отдельная сортировка. Сортировка набора из K строк добавляет к оценке как минимум K × log(K).'

p

c 'В отличие от соединения хешированием, слияние без сортировки хорошо подходит для случая, когда надо быстро получить первые строки.'

s 1 "EXPLAIN SELECT * 
FROM tickets t
  JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no
ORDER BY t.ticket_no
LIMIT 1000;"

c 'Обратите внимание и на то, как уменьшилась общая стоимость.'

P 20

###############################################################################

h 'В параллельных планах'

c 'Нам потребуется индекс:'

s 1 "CREATE INDEX ON tickets(book_ref);"

c 'Вот пример параллельного плана, в котором используется соединение слиянием:'

s 1 "EXPLAIN (costs off)
SELECT count(*)
FROM bookings b
  JOIN (
    SELECT book_ref FROM tickets GROUP BY book_ref
) t ON b.book_ref = t.book_ref;"

c 'Здесь индекс на таблице бронирований bookings_pkey сканируется параллельно, а результат группировки из подзапроса t — каждым процессом полностью.'

###############################################################################
stop_here
cleanup
demo_end
