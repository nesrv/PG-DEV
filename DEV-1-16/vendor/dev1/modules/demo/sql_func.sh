#!/bin/bash

. ../lib

init

s 1 "CREATE DATABASE $TOPIC_DB;"
s 1 "\c $TOPIC_DB"
psql_open A 2
s 2 "\c $TOPIC_DB"

start_here 5

###############################################################################
h 'Функции без параметров'

c 'Вот простой пример функции без параметров, содержащей один оператор:'

s 1 "CREATE FUNCTION hello_world() -- имя и пустой список параметров
RETURNS text                     -- тип возвращаемого значения
AS \$\$ SELECT 'Hello, world!'; \$\$ -- тело
LANGUAGE sql;                    -- указание языка"

c 'Тело удобно записывать в строке, заключенной в кавычки-доллары, как в приведенном примере. Иначе придется заботиться об экранировании кавычек, которые наверняка встретятся в теле функции. Сравните:'

s 1 "SELECT ' SELECT ''Hello, world!''; ';"
s 1 "SELECT \$\$ SELECT 'Hello, world!'; \$\$;"

c 'При необходимости кавычки-доллары могут быть вложенными. Для этого в каждой паре кавычек надо использовать разный текст между долларами:'

s 1 "SELECT \$func\$ SELECT \$\$Hello, world!\$\$; \$func\$;"

c 'Функция вызывается в контексте выражения, например:'

s 1 "SELECT hello_world(); -- пустые скобки обязательны"

c 'Давайте взглянем на то, как тело функции хранится в системном каталоге.'

s 1 '\pset xheader_width 60'
s 1 "SELECT proname, prosrc, prosqlbody FROM pg_proc
WHERE proname = 'hello_world' \gx"

c 'Мы видим сохраненную в исходном виде тело-строку.'
c 'А теперь реализуем современную возможность пересоздать нашу функцию в другом виде — в стиле стандарта SQL. В нашем случае телом функции может быть один оператор вида RETURN <выражение>:'

s 1 "CREATE OR REPLACE FUNCTION hello_world() RETURNS text
LANGUAGE sql
RETURN 'Hello, world!';"

c 'Снова заглянем в системный каталог — тело функции сохранено по-другому:'

s 1 "SELECT proname, prosrc, left(prosqlbody, 100) AS body FROM pg_proc WHERE proname = 'hello_world' \gx"

c 'Исходный код в этом случае не хранится, получить его можно командой \sf:'

s 1 "\sf hello_world"

p

c 'В случае, если тело функции состоит из нескольких операторов SQL, в качестве результата возвращается значение из первой строки, которую вернул последний оператор. Если код такой функции написан в стиле стандарта SQL, потребуется использовать конструкцию BEGIN ATOMIC ... END, которая охватывает выполняемый блок операторов:'

s 1 "CREATE OR REPLACE FUNCTION hello_world() RETURNS text
LANGUAGE sql
BEGIN ATOMIC
  SELECT 'First Line';
  SELECT 'Second Line';
END;"

c 'Пробуем вызов:'

s 1 "SELECT hello_world();"

c 'Обратите внимание на особенности синтаксиса стиля стандарта SQL — в отличие от традиционного «строчного»:'
ul 'нет конструкции AS, содержащей код функции в виде строки;'
ul 'может использоваться новое ключевое слово RETURN для возврата значения;'
ul 'указание LANGUAGE sql не является обязательным;'
ul 'при создании функции ее код разбирается, а результат разбора сохраняется в pg_proc.prosqlbody (в традиционной нотации текст функции сохраняется в pg_proc.prosrc).'

c 'Это лучше соответствует стандарту и в большей мере совместимо с другими реализациями SQL. Теперь при вызове функции ее команды заново не интерпретируются, а используется заранее разобранный вариант.'

p

c 'Не все операторы SQL можно использовать в функции. Запрещены:'
ul 'команды управления транзакциями (BEGIN, COMMIT, ROLLBACK и т. п.);'
ul 'служебные команды (такие, как VACUUM или CREATE INDEX).'

c 'Вот пример неправильной функции. Здесь мы использовали псевдотип void, который говорит о том, что функция не возвращает ничего.'

s 1 'CREATE FUNCTION do_commit() RETURNS void
LANGUAGE sql
BEGIN ATOMIC COMMIT; END;'


c 'Управлять транзакциями можно в процедурах, о чем мы будет говорить в следующей теме.'

p

###############################################################################
h 'Функции с входными параметрами'

c 'Пример функции с одним параметром:'

s 1 "CREATE FUNCTION hello(name text) -- формальный параметр
RETURNS text
LANGUAGE sql
RETURN 'Hello, ' || name || '!';"

c 'При вызове функции мы указываем фактический параметр, соответствующий формальному:'

s 1 "SELECT hello('Alice');"

c 'При указании типа параметра можно указать и модификатор (например, varchar(10)), но он игнорируется.'

c 'Можно определить параметр функции без имени; тогда внутри тела функции на параметры придется ссылаться по номеру. Удалим функцию и создадим новую:'

s 1 "DROP FUNCTION hello(text); -- достаточно указать тип параметра"
s 1 "CREATE FUNCTION hello(text)
RETURNS text
LANGUAGE sql
RETURN 'Hello, ' || \$1 || '!'; -- номер вместо имени"

s 1 "SELECT hello('Alice');"

c 'Но так лучше не делать, это неудобно.'

c 'Удалим функцию и создадим заново, добавив еще два параметра — приветствие и обращение.'

s 1 "DROP FUNCTION hello(text);"

c 'Здесь мы используем необязательное ключевое слово IN, обозначающее входной параметр. Предложение DEFAULT позволяет определить значение по умолчанию для параметра:'

s 1 "CREATE FUNCTION hello(IN name text, IN greet text DEFAULT 'Dear', IN title text DEFAULT 'Mr')
RETURNS text
LANGUAGE sql
RETURN 'Hello, ' || greet || ' ' || title || ' ' || name || '!';"

s 1 "SELECT hello('Alice', 'Charming', 'Mrs'); -- указаны второй и третий параметры"

c 'Обратите внимание, что параметры со значениями по умолчанию должны идти в конце всего списка. При вызове функции значения фактических параметров, определенных как default, можно опускать, тогда остальные default-параметры, идущие в списке после, также получат значения по умолчанию'

s 1 "SELECT hello('Bob', 'Excellent'); -- указан только первый default-параметр"

s 1 "SELECT hello('Bob'); -- опущены оба параметра, имеющие значение по умолчанию"

c 'До сих пор мы вызывали функцию, указывая фактические параметры позиционным способом — в том порядке, в котором они определены при создании функции. Во многих стандартных функциях имена параметров не заданы, так что этот способ оказывается единственным.'

c 'Но если формальным параметрам даны имена, можно использовать их при указании фактических параметров. В этом случае параметры могут указываться в произвольном порядке:'

s 1 "SELECT hello(title => 'Mrs', name => 'Alice');"

c 'Такой способ удобен, когда порядок параметров неочевиден, особенно если их много; также можно явно указать значение одного из параметров по умолчанию.'

c 'Можно совмещать оба способа: часть параметров (начиная с первого) указать позиционно, а оставшиеся — по имени:'

s 1 "SELECT hello('Alice', title => 'Mrs');"

c 'Если функция должна возвращать неопределенное значение, когда хотя бы один из входных параметров не определен, ее можно объявить как строгую (STRICT). Тело функции при этом вообще не будет выполняться.'

s 1 "DROP FUNCTION hello(text, text, text);"
s 1 "CREATE FUNCTION hello(IN name text, IN title text DEFAULT 'Mr')
RETURNS text
LANGUAGE sql STRICT
RETURN 'Hello, ' || title || ' ' || name || '!';"

s 1 "SELECT hello('Alice', NULL);"

P 7

###############################################################################
h 'Функции с выходными параметрами'

c 'Альтернативный способ вернуть значение — использовать выходной параметр.'

s 1 "DROP FUNCTION hello(text, text);"
s 1 "CREATE FUNCTION hello(
    IN name text,
    OUT text -- имя можно не указывать, если оно не нужно
)
LANGUAGE sql
RETURN 'Hello, ' || name || '!';
"

s 1 "SELECT hello('Alice');"

c 'Результат тот же самый.'

c 'Можно использовать и RETURNS, и OUT-параметр вместе — результат снова будет тем же:'

s 1 "DROP FUNCTION hello(text); -- OUT-параметры не указываем"
s 1 "CREATE FUNCTION hello(IN name text, OUT text)
RETURNS text
LANGUAGE sql
RETURN 'Hello, ' || name || '!';"

s 1 "SELECT hello('Alice');"

c 'Или даже так, использовав INOUT-параметр:'

s 1 "DROP FUNCTION hello(text);"
s 1 "CREATE FUNCTION hello(INOUT name text)
LANGUAGE sql
RETURN 'Hello, ' || name || '!';
"

s 1 "SELECT hello('Alice');"

c 'Обратите внимание, что, в отличие от многих языков программирования, фактическое значение, переданное SQL-функции в INOUT-параметре, никак не изменяется: мы передаем входное значение, а выходное возвращается функцией в качестве результата. Поэтому мы можем указать константу, хотя другие языки требовали бы переменную.'

c 'В то время как в RETURNS можно указать только одно значение, выходных параметров может быть несколько. Например:'

s 1 "DROP FUNCTION hello(text);"
s 1 "CREATE FUNCTION hello(
    IN name text,
    OUT greeting text,
    OUT clock timetz)
LANGUAGE sql
RETURN ('Hello, ' || name || '!', current_time);"

c 'Здесь возвращаемое RETURN выражение пришлось взять в скобки.'

s 1 "SELECT hello('Alice');"

c 'Действительно, наша функция вернула не одно значение, а сразу несколько.'
c 'Подробнее о такой возможности и составных типах мы будем говорить в теме «SQL. Составные типы».'

P 9

###############################################################################
h 'Категории изменчивости и изоляция'

c 'В целом использование функций внутри запросов не нарушает установленный уровень изоляции транзакции, но есть два момента, о которых полезно знать.'

c 'Во-первых, функции с изменчивостью volatile на уровне изоляции Read Committed приводят к рассогласованию данных внутри одного запроса.'

c 'Сделаем функцию, возвращающую число строк в таблице:'

s 1 'CREATE TABLE t(n integer);'
s 1 'CREATE FUNCTION cnt() RETURNS bigint
LANGUAGE sql VOLATILE 
RETURN (SELECT count(*) FROM t);'


c 'Теперь вызовем ее несколько раз с задержкой, а в параллельном сеансе вставим в таблицу строку.'

s 1 'BEGIN ISOLATION LEVEL READ COMMITTED;'
ss 1 'SELECT (SELECT count(*) FROM t), cnt(), pg_sleep(1)
FROM generate_series(1,4);'
sleep 1
si 2 'INSERT INTO t VALUES (1);'
r 1
s 1 'END;'

c 'При изменчивости stable или immutable, либо при использовании более строгих уровней изоляции такого не происходит потому, что в этих случаях всегда используется снимок основного запроса. В предыдущем же примере (volatile, Read Committed) основной запрос и запросы в функции используют разные снимки данных.'

s 1 'ALTER FUNCTION cnt() STABLE;'
s 1 'TRUNCATE t;'
s 1 'BEGIN ISOLATION LEVEL READ COMMITTED;'
ss 1 'SELECT (SELECT count(*) FROM t), cnt(), pg_sleep(1)
FROM generate_series(1,4);'
sleep 1
si 2 'INSERT INTO t VALUES (1);'
r 1
s 1 'END;'

p

c 'Второй момент связан с видимостью изменений, сделанных собственной транзакцией.'

c 'Функции с изменчивостью volatile видят все изменения, в том числе сделанные текущим, еще не завершенным оператором SQL.'

s 1 'ALTER FUNCTION cnt() VOLATILE;'
s 1 'TRUNCATE t;'
s 1 'INSERT INTO t SELECT cnt() FROM generate_series(1,5);'
s 1 'SELECT * FROM t;'

c 'Это верно для любых уровней изоляции.'

c 'Функции с изменчивостью stable или immutable видят изменения только уже завершенных операторов.'

s 1 'ALTER FUNCTION cnt() STABLE;'
s 1 'TRUNCATE t;'
s 1 'INSERT INTO t SELECT cnt() FROM generate_series(1,5);'
s 1 'SELECT * FROM t;'

p

###############################################################################
h 'Категории изменчивости и оптимизация'

c 'Благодаря дополнительной информации о поведении функции, которую дает указание категории изменчивости, оптимизатор может сэкономить на вызовах функции.'

c 'Для экспериментов создадим функцию, возвращающую случайное число:'

s 1 'CREATE FUNCTION rnd() RETURNS float
LANGUAGE sql VOLATILE 
RETURN random();'

c 'Проверим план выполнения следующего запроса:'

s 1 'EXPLAIN (costs off)
SELECT * FROM generate_series(1,10) WHERE rnd() > 0.5;'

c 'В плане мы видим «честное» обращение к функции generate_series; каждая строка результата сравнивается со случайным числом и при необходимости отбрасывается фильтром.'

c 'В этом можно убедиться и воочию:'

s 1 'SELECT * FROM generate_series(1,10) WHERE rnd() > 0.5;'
s 1 '\g'
s 1 '\g'
s 1 '\g'
s 1 '\g'
c 'Здесь с разной вероятностью получаем от 0 до 10 строк.'
p

c 'Функция с изменчивостью stable будет вызвана всего один раз — поскольку мы фактически указали, что ее значение не может измениться в пределах оператора:'

s 1 'ALTER FUNCTION rnd() STABLE;'
s 1 'EXPLAIN (costs off)
SELECT * FROM generate_series(1,10) WHERE rnd() > 0.5;'
c 'Результатом запроса будет либо 0, либо 10 строк.'
s 1 'SELECT * FROM generate_series(1,10) WHERE rnd() > 0.5;'
FIRST_RESULT=$RESULT
while [ "$RESULT" = "$FIRST_RESULT" ]; do
	s 1 '\g' # повторяем, пока не получим другой результат
done
s 1 '\g' # и ещё раз
p

c 'Наконец, изменчивость immutable позволяет вычислить значение функции еще на этапе планирования, поэтому во время выполнения вычисление фильтра уже не требуется:'

s 1 'ALTER FUNCTION rnd() IMMUTABLE;'
s 1 'EXPLAIN (costs off)
SELECT * FROM generate_series(1,10) WHERE rnd() > 0.5;'
FIRST_RESULT=$RESULT
while [ "$RESULT" = "$FIRST_RESULT" ]; do
	s 1 '\g' # повторяем, пока не получим другой результат
done
s 1 '\g' # и ещё раз
c 'Для immutable получаем случайный план!'
c 'Ответственность «за дачу заведомо ложных показаний» лежит на разработчике.'

p

###############################################################################
h 'Подстановка тела функции в SQL-запрос'

c 'В некоторых (очень простых) случаях тело функции на языке SQL может быть подставлено прямо в основной SQL-оператор на этапе разбора запроса. В этом случае время на вызов функции не тратится.'

c 'Упрощенно — требуется выполнение следующих условий:'
ul 'Тело функции состоит из одного оператора SELECT;'
ul 'Нет обращений к таблицам, отсутствуют подзапросы, группировки и т. п.;'
ul 'Возвращаемое значение должно быть одно;'
ul 'Вызываемые функции не должны противоречить указанной категории изменчивости.'

c 'Пример мы уже видели: наша функция rnd(), объявленная volatile.'
c 'Посмотрим еще раз.'

s 1 'ALTER FUNCTION rnd() VOLATILE;'
s 1 'EXPLAIN (costs off)
SELECT * FROM generate_series(1,10) WHERE rnd() > 0.5;'

c 'В фильтре упоминается функция random(), но не rnd(). Она будет вызываться напрямую, минуя «обертку» в виде функции rnd().'

###############################################################################

stop_here
cleanup
demo_end
