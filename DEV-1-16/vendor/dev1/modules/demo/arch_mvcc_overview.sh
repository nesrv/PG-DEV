#!/bin/bash

. ../lib

init

s 1 "CREATE DATABASE $TOPIC_DB;"
s 1 "\c $TOPIC_DB"
psql_open A 2
s 2 "\c $TOPIC_DB"

start_here 6

###############################################################################
h 'Видимость версий строк'

c 'Как убедиться в том, что одна и та же строка может существовать в нескольких версиях?'
c 'Создадим таблицу:'

s 1 'CREATE TABLE t(s text);'

c 'И вставим одну строку. Напомним, что если не начать транзакцию явно командой BEGIN, psql выполняет команду и немедленно фиксирует результат:'

s 1 "INSERT INTO t VALUES ('Первая версия');"

c 'Начнем транзакцию и выведем ее номер:'

s 1 'BEGIN;'
s 1 'SELECT pg_current_xact_id();'

c 'Транзакция видит первую (и пока единственную) версию строки:'

s 1 'SELECT *, xmin, xmax FROM t;'

c 'Здесь скрытые столбцы показывают номера транзакций, ограничивающих видимость версии строки: xmin — номер предыдущей транзакции, которая создала версию, а xmax=0 означает, что эта версия актуальна.'

c 'Теперь начнем другую транзакцию в другом сеансе:'

s 2 'BEGIN;'
s 2 'SELECT pg_current_xact_id();'

c 'Транзакция видит ту же единственную версию:'

s 2 'SELECT *, xmin, xmax FROM t;'

c 'Теперь изменим строку во второй транзакции.'

s 2 "UPDATE t SET s = 'Вторая версия';"

c 'Вот что получилось:'

s 2 'SELECT *, xmin, xmax FROM t;'

c 'А что увидит первая транзакция?'

s 1 'SELECT *, xmin, xmax FROM t;'

c 'Поскольку изменение не зафиксировано, первая транзакция продолжает видеть первую версию строки.'

c 'Обратите внимание на xmax — значение показывает, что в настоящий момент другая транзакция меняет строку. Вообще говоря, такое «подглядывание» нарушает изоляцию, поэтому поля xmin и xmax скрыты и в реальной работе их использовать не стоит.'

p

c 'Теперь зафиксируем изменения.'

s 2 'COMMIT;'

c 'Что теперь увидит первая транзакция?'

s 1 'SELECT *, xmin, xmax FROM t;'

c 'Теперь и первая транзакция видит вторую версию строки.'

c 'После фиксации первая версия строки больше не будет видна ни в одной транзакции.'

s 1 'COMMIT;'

P 9

###############################################################################
h 'Блокировки'

c 'Повторим наш опыт, но теперь пусть обе транзакции попытаются изменить одну и ту же строку.'

s 1 "BEGIN;"
s 1 "UPDATE t SET s = 'Третья версия' RETURNING *;"

c 'И во второй транзакции:'

s 2 "BEGIN;"
ss 2 "UPDATE t SET s = 'Четвертая версия' RETURNING *;"
sleep-ni 1

c 'Вторая транзакция «повисла»: она не может изменить строку, пока первая транзакция не снимет блокировку.'

s 1 "COMMIT;"

c 'Теперь вторая транзакция может продолжить выполнение:'

r 2
s 2 "COMMIT;"

c 'Обе транзакции зафиксировали свои изменения. Первый сеанс снова читает таблицу и видит актуальную строку — это результат, зафиксированный второй транзакцией:'
s 1 'SELECT * FROM t;'

###############################################################################

stop_here
cleanup
demo_end
