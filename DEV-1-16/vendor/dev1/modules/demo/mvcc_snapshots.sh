#!/bin/bash

. ../lib

init

psql_open A 2
psql_open A 3
psql_open A 4

start_here 6

###############################################################################
h 'Видимость версий строк'

c 'Воспроизведем ситуацию, показанную на слайде. Каждая из трех транзакций будет добавлять новую строку в таблицу.'

#
# 1                  |*snapshot RR------
# 2 |--T1---------------|
# 3        |--T2--|
# 4                         |--T3--|
#
# snapshot T1:T3:T1
#

s 1 "CREATE DATABASE $TOPIC_DB;"
s 1 "\c $TOPIC_DB"
s 1 "CREATE TABLE t(s text);"

c 'Первая транзакция (не завершится до создания снимка):'

s 2 "\c $TOPIC_DB"
PSQL_PROMPT2='T1=> '
s 2 "BEGIN;"
s 2 "INSERT INTO t VALUES ('first');"
s 2 "SELECT pg_current_xact_id();"
export T1=$(s_bare 2 "SELECT backend_xid FROM pg_stat_activity WHERE pid = pg_backend_pid();")

c 'Вторая транзакция (завершается сразу):'

s 3 "\c $TOPIC_DB"
PSQL_PROMPT3='T2=> '
s 3 "BEGIN;"
s 3 "INSERT INTO t VALUES ('second');"
s 3 "SELECT pg_current_xact_id();"
export T2=$(s_bare 3 "SELECT backend_xid FROM pg_stat_activity WHERE pid = pg_backend_pid();")
s 3 "COMMIT;"

c 'Теперь создаем снимок в транзакции в отдельном сеансе.'

s 1 "BEGIN ISOLATION LEVEL REPEATABLE READ;"
s 1 "SELECT * FROM t;"

c 'И завершаем первую транзакцию после того, как создан снимок:'

s 2 "COMMIT;"

c 'Третья транзакция начинается после создания снимка:'

s 4 "\c $TOPIC_DB"
PSQL_PROMPT4='T3=> '
s 4 "BEGIN;"
s 4 "INSERT INTO t VALUES ('third');"
s 4 "SELECT pg_current_xact_id();"
export T3=$(s_bare 4 "SELECT backend_xid FROM pg_stat_activity WHERE pid = pg_backend_pid();")
s 4 "COMMIT;"

c 'Очевидно, что в нашем снимке по-прежнему видна одна строка:'

s 1 "SELECT *, xmin, xmax FROM t;"

c 'Вопрос в том, как это понимает PostgreSQL.'

P 9

###############################################################################
h 'Снимок данных'

c 'Видимость версий строк определяется снимком. Посмотрим на него:'

s 1 "SELECT pg_current_snapshot(); -- txid_current_snapshot() до v.13"

c 'Снимок определяется в момент создания тремя основными значениями, которые функция выводит через двоеточия:'
ul 'xmin — номер самой ранней активной транзакции;'
ul 'xmax — номер, следующий за последней зафиксированной транзакцией (определяет момент создания снимка);'
ul 'xip_list — список номеров активных транзакций (в данном случае она одна).'

p

c "В снимке должны быть видны изменения транзакций с номерами:"
ul "xid < xmin;"
ul "xmin <= xid < xmax, за исключением транзакций из xip_list."

c "В нашем случае:"

ul "xid < $T1;"
ul "$T1 <= xid < $T3, за исключением $T1."

p

s 2 "SELECT *, xmin, xmax FROM t;"

c "Первая строка не видна — она создана транзакцией $T1, которая входит в список активных."
c "Вторая строка видна — она создана транзакцией $T2, которая попадает в диапазон снимка."
c "Третья строка не видна — она создана транзакцией $T3, которая не входит в диапазон снимка."

P 11

###############################################################################
h 'Виртуальные транзакции'

c 'Только читающие транзакции никак не влияют на видимость версий строк и не учитываются в снимках данных. Они не имеют настоящего номера:'

s 1 "SELECT pg_current_xact_id_if_assigned(); -- txid_current_if_assigned() до v.13"

c 'Настоящий номер присваивается при первом изменении, выполненном транзакцией, а также при вызове функции pg_current_xact_id().'

P 22

###############################################################################
h 'Горизонт транзакции и базы данных'

c 'Свой горизонт транзакция может увидеть в представлении:'

s 1 "SELECT backend_xmin FROM pg_stat_activity
WHERE pid = pg_backend_pid();"

c 'Хотя наша транзакция является виртуальной и не влияет на видимость других транзакций, она обращается к данным, используя снимок, и поэтому удерживает горизонт базы данных.'

c 'После завершения транзакции горизонт продвигается вперед, позволяя очищать неактуальные версии строк:'

s 1 "COMMIT;"
s 1 "SELECT backend_xmin FROM pg_stat_activity
WHERE pid = pg_backend_pid();"

###############################################################################

stop_here
cleanup
demo_end
