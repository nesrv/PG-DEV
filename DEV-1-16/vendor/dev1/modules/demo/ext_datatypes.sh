#!/bin/bash

. ../lib

init

start_here 6

###############################################################################
h 'Типы перечислений'

s 1 "CREATE DATABASE $TOPIC_DB;"
s 1 "\c $TOPIC_DB"

c 'Создадим новые типы перечислений для старшинства карт:'

s 1 "CREATE TYPE ranks AS ENUM (
    '6', '7', '8', '9', '10', 'Queen', 'King', 'Ace'
);"

c 'И для мастей:'

s 1 "CREATE TYPE suits AS ENUM (
    'clubs', 'diamonds', 'hearts', 'spades'
);"

c 'Напомним, что тип данных — отдельный объект базы данных, который хранится в системном каталоге:'

s 1 '\dT public.*'

c 'Чтобы вспомнить и составные типы, определим еще тип для карты:'

s 1 "CREATE TYPE cards AS (
    rank ranks,
    suit suits
);"

s 1 "DO \$\$
DECLARE
    card cards;
BEGIN
    card := ('Ace','spades');
    RAISE NOTICE '%', card;
    RAISE NOTICE 'Старшинство: % ... %',
        enum_first(card.rank), enum_last(card.rank);
    RAISE NOTICE 'Масти: % ... %',
            enum_first(card.suit), enum_last(card.suit);
END;
\$\$;"

c 'Обратите внимание, что названия значений перечислимого типа регистрозависимы.'

c 'Все значения в перечислении упорядочены, и этим можно пользоваться:'

s 1 "SELECT '6'::ranks < 'Ace'::ranks;"

c 'Однако сами типы перечислений считаются уникальными и поэтому значения разных перечислений нельзя сравнивать, даже если они определены одинаково:'

s 1 "CREATE TYPE suits_bis AS ENUM (
    'clubs', 'diamonds', 'hearts', 'spades'
);"

s 1 "SELECT 'hearts'::suits = 'hearts'::suits_bis;"

c 'При необходимости выполнить подобное сравнение придется либо реализовать собственный оператор, либо явно преобразовать типы в запросе, например так:'

s 1 "SELECT 'hearts'::suits::text = 'hearts'::suits_bis::text;"

c 'Можно получить список значений в виде массива (функция enum_range смотрит только на тип параметра; само значение может быть любым):'

s 1 "DO \$\$
DECLARE
    suit suits;
    rank ranks;
    deck cards[];
BEGIN
    RAISE NOTICE '%', enum_range(NULL::ranks);
    RAISE NOTICE '%', enum_range(NULL::suits);
    FOREACH rank IN ARRAY enum_range(NULL::ranks) LOOP
        FOREACH suit IN ARRAY enum_range(NULL::suits) LOOP
            deck := deck || (rank,suit)::cards;
        END LOOP;
    END LOOP;
END;
\$\$;"

c 'Кажется, мы забыли валета. Не беда, его можно добавить к перечислению:'

s 1 "ALTER TYPE ranks ADD VALUE 'Jack' BEFORE 'Queen';"

c 'А вот удалить значение из типа невозможно. Единственный вариант — удалить тип и создать его заново.'

p

c 'Если мы заглянем в системный каталог, то увидим, что упорядоченность значений перечисления обеспечивает столбец типа real. Обратите внимание на его дробное значение для добавленного нами валета:'

s 1 "SELECT enumsortorder, enumlabel FROM pg_enum WHERE enumtypid = 'ranks'::regtype ORDER BY enumsortorder;"

P 9

###############################################################################
h 'Диапазонные типы'

c 'Начнем с нескольких примеров работы с уже имеющимися диапазонными типами.'

c 'Диапазон целых чисел от 1 до 9, обе границы включаются (об этом говорят квадратные скобки). Что будет выведено?'

s 1 "SELECT '[1,9]'::int4range;"

c 'Результат выводится в каноническом виде, в котором левая граница включается, а правая — нет (круглая скобка). Конечно, значение правой границы при этом увеличивается на единицу. Канонический вид определен не для всех типов.'

c 'Диапазон может быть и открытым. Проверим, принадлежит ли число диапазону:'

s 1 "SELECT -100 <@ '[1,)'::int4range, 100 <@ '[1,)'::int4range;"

c 'Точно так же можно проверить включение одного диапазона в другой:'

s 1 "SELECT '[2,3]'::int4range <@ '[1,4]'::int4range;"

c 'Удобны функции, позволяющие работать с диапазонами как с множествами. Например, можно легко найти пересечение (общие точки) двух диапазонов:'

s 1 "SELECT '[1,3]'::int4range * '[2,4]'::int4range;"

p

c 'При создании нового диапазонного типа указываются:'
ul 'базовый тип, значения которого должны быть сортируемыми;'
ul 'функция разности двух значений, которая должна возвращать результат типа double precision.'

c 'Например, в PostgreSQL нет типа для диапазонов времени (без даты). Чтобы определить его, нам потребуется функция, возвращающая разность между двумя временами. Обычная разность возвращает значение типа interval:'

s 1 "SELECT '10:00'::time - '9:59'::time;"

c 'Но мы можем воспользоваться функцией extract epoch, которая вернет длину диапазона в секундах:'

s 1 "CREATE FUNCTION time_diff(a time, b time) RETURNS double precision
LANGUAGE sql STRICT IMMUTABLE
RETURN extract(epoch FROM (a - b));"

s 1 "SELECT time_diff('10:00','9:59');"

c 'Теперь можно определить тип диапазона, а вместе с ним — и мультидиапазона:'

s 1 "CREATE TYPE timerange AS RANGE (
    subtype = time,
    subtype_diff = time_diff,
    multirange_type_name = timemultirange
);"

c 'Последний параметр — необязательный, в его отсутствие соответствующий мультидиапазонный тип будет создан автоматически.'

c 'Новый тип можно использовать аналогично уже существующим. Например, найдем объединение (здесь показаны два способа записи констант диапазонного типа):'

s 1 "SELECT timerange('9:00','11:00','[]') + '[10:00,12:00]'::timerange;"

c 'Заметьте, что диапазон не приводится к каноническому виду. Чтобы это работало, необходимо реализовать соответствующую функцию и указать ее в определении типа. Мы не будем этого делать.'

p

c 'Новый мультидиапазонный тип позволяет представить несколько диапазонов как одно значение:'

s 1 "SELECT timemultirange(
      timerange('09:00', '13:00', '[)'),
      timerange('08:00', '10:00', '[)'),
      timerange('14:00', '18:00', '[)')
) AS working_hours;"

c 'Обратите внимание, что пересекающиеся диапазоны были объединены.'

P 11

###############################################################################
h 'Интервалы'

c 'Значения типа interval определяют длину временного отрезка, в отличие от диапазонного типа, значения которого состоят из начальной и конечной точек.'

c 'Интервал появляется естественным образом при вычитании двух моментов времени:'

s 1 "SELECT timestamp '01.02.2020' - timestamp '01.01.2020';"

c '(Хотя та же операция для дат (тип date) возвращает целое число.)'

c 'Интервалы используются в арифметике дат и времени. Например:'

s 1 "SELECT now(), now() + 2 * interval '1 month';"

c "Обратите внимание, что интервал '1 month' может иметь разную длину — от 28 до 31 дней в зависимости от месяца."

c 'При необходимости можно преобразовать интервал так, чтобы, например, каждый 24-часовой период считался одним днем:'

s 1 "SELECT interval '29 hours', justify_hours(interval '29 hours');"


P 13

###############################################################################
h 'Домены'

c 'Создадим доменный тип, ограничивающий временной диапазон рабочими часами и запрещающий неопределенные значения:'

s 1 "CREATE DOMAIN work_timerange AS timerange
NOT NULL
CHECK (VALUE <@ '[10:00,19:00)'::timerange);"

c 'Его можно использовать при создании таблицы:'

s 1 "CREATE TABLE work_events(
    event_name text,
    event_range work_timerange
);"

s 1 "INSERT INTO work_events VALUES (
    'обед', '[13:00,14:00)'
);"

c 'А так получится?'

s 1 "INSERT INTO work_events VALUES (
    'труд', '[14:00,22:00)'
);"

c 'Нет — нарушено условие проверки. А так?'

s 1 "INSERT INTO work_events VALUES (
    'лень', NULL
);"

c 'Нет — неопределенные значения не допускаются. А если так?'

s 1 "INSERT INTO work_events VALUES (
    'лень', (SELECT event_range FROM work_events WHERE false)
);"

c 'А так получится. Запрет неопределенных значений на уровне домена работает не так, как на уровне столбца. Ограничение NOT NULL надежнее указывать при создании таблицы.'

p

c 'Еще одна проблема связана с тем, что при любых операциях значения приводятся к базовому типу. Это не позволяет использовать домены для контроля типов в операциях. Вот пример:'

s 1 "CREATE DOMAIN distance AS float;"
s 1 "CREATE DOMAIN weight AS float;"

c 'Можно ли складывать метры с граммами?'

s 1 "SELECT 2::distance + 3::weight;"

c 'Оказывается, можно.'
c 'Поэтому практическое применение доменных типов довольно ограничено.'

P 16

###############################################################################
h 'Приведение типов'

c 'В качестве примера рассмотрим приведение типа timerange к типу interval.'

c 'Сработает ли такое приведение само по себе?'

s 1 "SELECT '[10:00,12:00]'::timerange::interval;"

c 'Увы, нет. Чтобы создать такое приведение, сначала напишем функцию:'

s 1 "CREATE FUNCTION timerange_to_interval(a timerange) RETURNS interval
LANGUAGE sql STRICT IMMUTABLE
RETURN make_interval(
    secs => extract( epoch FROM (upper(a)-lower(a)) )
);"

s 1 "SELECT timerange_to_interval('[10:00,12:00]');"

c 'Теперь можно создать приведение типов. Здесь мы указываем AS IMPLICIT, чтобы приведение срабатывало и неявно.'

s 1 "CREATE CAST (timerange AS interval)
WITH FUNCTION timerange_to_interval
AS IMPLICIT;"

s 1 "SELECT '[10:00,12:00]'::timerange::interval;"

p

###############################################################################
h 'Операторы'

c 'Пусть требуется узнать, сколько раз заданный интервал (тип interval) содержится в другом интервале. Например, сколько в интервале часов, или минут, или пятисекундных отрезков. Иными словами, нужно деление одного интервала на другой. Но в PostgreSQL для интервалов определен только оператор деления на целое число.'

c 'Напишем соответствующую функцию:'

s 1 "CREATE FUNCTION interval_div(a interval, b interval) RETURNS double precision
LANGUAGE sql STRICT IMMUTABLE
RETURN extract(epoch FROM a) / extract(epoch FROM b);"

c 'Теперь мы можем узнать, сколько раз можно послушать композицию Your Latest Trick, длящуюся 6 минут 33 секунды, если у нас есть полтора часа времени:'

s 1 "SELECT interval_div('1:30:00'::interval,'0:06:33'::interval);"

c 'Определим бинарный оператор, используя эту функцию:'

s 1 "CREATE OPERATOR / (
    FUNCTION = interval_div,
    LEFTARG = interval,
    RIGHTARG = interval
);"

c 'Имя оператора можно составлять только из специальных символов, список которых приведен в документации к команде CREATE OPERATOR. Если не указать LEFTARG, будет определен префиксный оператор. Постфиксные операторы не поддерживаются начиная с PostgreSQL 14.'

c 'Теперь можно пользоваться удобной инфиксной формой записи (здесь также показан другой способ записи интервалов):'

s 1 "SELECT interval '1 hour 30 min' / interval '6 min 33 sec';"

###############################################################################

stop_here
cleanup
demo_end
