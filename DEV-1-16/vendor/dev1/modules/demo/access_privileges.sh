#!/bin/bash


. ../lib

init

start_here 4

###############################################################################
h 'Роли'

c 'В этом модуле приглашение будет показывать имя роли, от которой выполняется команда.'

PSQL_PROMPT1='student=# '
s 1 "CREATE DATABASE $TOPIC_DB;"
s 1 "\c $TOPIC_DB"

c 'В первом приближении роль - это пользователь PostgreSQL. Простейший способ регистрации пользователя:'
s 1 'CREATE USER alice;'

c 'Зарегистрированная таким образом роль может зайти в сеанс.'
psql_open A 2 -d $TOPIC_DB -U alice
PSQL_PROMPT2='alice=> '
s 2 'SELECT session_user;'

c 'Нам далее потребуется еще один пользователь. Его создаст суперпользователь.'
s 1 'CREATE USER bob;'
psql_open A 3 -d $TOPIC_DB -U bob
PSQL_PROMPT3='bob=> '

P 8
###############################################################################
h 'Привилегии'

c 'Алиса может попытаться создать таблицу, однако у нее пока нет для этого необходимых привилегий.'
s 2 'CREATE TABLE t1(n integer);'

c 'Создать необходимую Алисе таблицу поможет суперпользователь. Но более перспективное решение - создать для Алисы схему, в которой она самостоятельно будет создавать требуемые объекты.'
s 1 'CREATE SCHEMA alice;'
s 1 'GRANT CREATE, USAGE ON SCHEMA alice TO alice;'

s 1 '\dn+ alice'
c 'В каждой строке access privileges отображается роль, ее привилегии и кем они были выданы:'
c '  роль=привилегии/кем_предоставлены'
c 'Названия привилегий обозначаются одной буквой. Привилегии для схем:'
ul '  U = usage'
ul '  C = create'

c 'Если параметр search_path настроен по умолчанию, то при наличии схемы, имя которой совпадает с именем пользователя, и необходимых привилегий на эту схему, создаваемые пользователем объекты будут находться в ней.'
s 2 'SELECT current_schema();'

c 'Алиса создает пару таблиц.'
s 2 'CREATE TABLE t1(n integer);'
s 2 'CREATE TABLE t2(n integer, m integer);'

p

c 'Боб в своем сеансе, пытается обратиться к объектам Алисы.'
s 3 'SELECT * FROM alice.t1;'
c 'Но пока у Боба нет доступа к схеме, так как он не имеет нужных привилегий.'

P 10
###############################################################################
h 'Управление привилегиями'

c 'Алисе надо выдать Бобу доступ к своей схеме.'
s 2 'GRANT CREATE, USAGE ON SCHEMA alice TO bob;'
c 'Почему привилегия не выдалась? Потому что Алиса не является владельцем схемы.'

s 1 '\dn+ alice'

c 'Суперпользователь делает Алису владельцем:'
s 1 'ALTER SCHEMA alice OWNER TO alice;'
s 1 '\dn+ alice'

p

c 'Теперь Алиса сможет выдать доступ Бобу:'
s 2 'GRANT CREATE, USAGE ON SCHEMA alice TO bob;'

c 'И Боб снова пытается прочитать таблицу:'
s 3 'SELECT * FROM alice.t1;'
c 'В чем причина ошибки на этот раз?'

c 'Сейчас у Боба есть доступ к схеме, но нет доступа к самой таблице.'
s 3 '\dp alice.t1'
c 'Пустое поле access privileges означает, что у владельца есть полный набор привилегий, а кроме него никто не имеет доступа.'

p

c 'Алиса должна дать Бобу доступ на чтение:'
s 2 'GRANT SELECT ON t1 TO bob;'

c 'Посмотрим, как изменились привилегии:'
s 2 '\dp t1'
c 'Теперь пустое поле «проявилось», и мы видим, что для Алисы в нем находится полный перечень привилегий. Вот обозначения привилегий для таблиц, не все из них вполне очевидные:'
ul '  a = insert'
ul '  r = select'
ul '  w = update'
ul '  d = delete'
ul '  D = truncate'
ul '  x = reference'
ul '  t = trigger'

p

c 'На этот раз у Боба все получается:'
s 3 'SELECT * FROM alice.t1;'

c 'А, например, добавить строку в таблицу он не сможет:'
s 3 'INSERT INTO alice.t1 VALUES (42);'

c 'Некоторые привилегии можно выдать на определенные столбцы:'
s 2 'GRANT INSERT(n,m) ON t2 TO bob;'
s 2 'GRANT SELECT(m) ON t2 TO bob;'
s 2 '\dp t2'

c 'Теперь Боб может добавлять строки в t2:'
s 3 'INSERT INTO alice.t2(n,m) VALUES (1,2);'

c 'А читать сможет только один столбец:'
s 3 'SELECT * FROM alice.t2;'
s 3 'SELECT m FROM alice.t2;'

c 'Если необходимо, Алиса может выдать Бобу все привилегии, не перечисляя их явно.'
s 2 'GRANT ALL ON t1 TO bob;'
s 2 '\dp t1'

c 'Теперь Бобу доступны все действия, например, удаление строк:'
s 3 'DELETE FROM alice.t1;'

c 'А удаление самой таблицы?'
s 3 'DROP TABLE alice.t1;'

c 'Удалить таблицу может только владелец (или суперпользователь), специальной привилегии для этого не существует.'

P 12
###############################################################################
h 'Передача привилегий'

c 'Создадим третью роль, для Чарли. Боб попробует передать Чарли права на таблицу t1, принадлежащую Алисе.'
s 1 'CREATE USER charlie;'

c 'У Боба есть полный доступ к t1:'
s 3 '\dp alice.t1'

c 'Но он не может передать свои привилегии Чарли:'
s 3 'GRANT SELECT ON alice.t1 TO charlie;'

c 'Чтобы это было возможно, Алиса должна выдать Бобу разрешение.'
s 2 'GRANT SELECT,UPDATE ON t1 TO bob WITH GRANT OPTION;'

c 'Звездочки справа от символа привилегии показывают право передачи, которое получил от Алисы Боб.'
s 3 '\dp alice.t1'

p

c 'Теперь Боб может поделиться с Чарли привилегиями, в том числе и правом передачи:'
s 3 'GRANT SELECT ON alice.t1 TO charlie WITH GRANT OPTION;'
s 3 'GRANT UPDATE ON alice.t1 TO charlie;'
s 3 '\dp alice.t1'

c 'Роль может отозвать привилегии только у той роли, которой она их непосредственно выдала. Например, Алиса не сможет отозвать право передачи у Чарли, потому что она его не выдавала.'
s 2 'REVOKE GRANT OPTION FOR SELECT ON alice.t1 FROM charlie;'

c 'Никакой ошибки не фиксируется, но и права не изменяются:'
s 2 '\dp alice.t1'

c 'В то же время Алиса не может просто так отозвать привилегии у Боба, если он успел передать их кому-либо еще:'
s 2 'REVOKE GRANT OPTION FOR SELECT ON alice.t1 FROM bob;'

c 'В таком случае привилегии надо отзывать по всей иерархии передачи с помощью CASCADE:'
s 2 'REVOKE GRANT OPTION FOR SELECT ON alice.t1 FROM bob CASCADE;'

s 2 '\dp alice.t1'
c 'Как видим, у Боба пропало право передачи привилегии, а у Чарли была отозвана и сама привилегия.'

c 'Аналогично можно отозвать по иерархии и привилегию.'
s 2 'REVOKE SELECT,UPDATE ON alice.t1 FROM bob CASCADE;'
s 2 '\dp alice.t1'

P 14
###############################################################################
h 'Атрибуты ролей'
c 'Роли имеют атрибуты, которые можно рассматривать в качестве особых привилегий. Так, например, предоставим Алисе право регистрации других ролей.'
s 1 'ALTER ROLE alice CREATEROLE;'
s 1 '\du alice'

c 'Атрибут LOGIN позволяет роли входить в сеанс, причем команда CREATE USER этот атрибут устанавливает сразу. А CREATE ROLE - нет. Проверим это от имени Алисы.'
s 2 'CREATE ROLE dave;'
s 2 '\du dave'
c 'При наличии атрибута LOGIN - это никак не отмечается в списке ролей. Напротив, отсутствие этого атрибута акцентируется.'

c 'Дэйв не может войти в сеанс.'
tolerate_lostconn=true
s 3 '\c - dave'
tolerate_lostconn=false
psql_close 3

c 'Теперь Алиса установит Дэйву атрибут, разрешающий вход в сеанс.'
s 2 'ALTER ROLE dave LOGIN;'

c 'И Дэйв может войти в сеанс.'
psql_open A 3 -d $TOPIC_DB -U dave
PSQL_PROMPT3='dave=> '
s 3 'SELECT session_user;'

c 'Алиса решает, что Дэйв имеет право зайти в сеанс лишь один раз.'
s 2 'ALTER ROLE dave CONNECTION LIMIT 1;'
s 2 '\du dave'

c 'Один сеанс Дэйва уже открыт, попробуем открыть еще один.'
eu student "psql -U dave -d $TOPIC_DB -l"

p

###############################################################################
h 'Удаление ролей'

c 'Удалить роль можно, если нет объектов, которыми она владеет. Удалим charlie и dave.'
s 1 'DROP ROLE charlie;'
s 1 'DROP ROLE dave;'

c 'Алиса владеет несколькими объектами.'
s 1 'DROP ROLE alice;'

c 'Чтобы удалить роль Алисы, можно передать ее объекты другой роли:'
s 1 'REASSIGN OWNED BY alice TO bob;'
s 1 '\dt alice.t?'
s 1 "\l $TOPIC_DB;"
s 1 'DROP ROLE alice;'

c 'Другой вариант — удалить объекты, принадлежащие роли:'
s 1 'DROP OWNED BY bob;'
s 1 "ALTER DATABASE $TOPIC_DB OWNER TO student;"
s 1 'DROP ROLE bob;'

c 'Надо только иметь в виду, что роль может владеть объектами в разных базах данных.'

###############################################################################

stop_here

demo_end
